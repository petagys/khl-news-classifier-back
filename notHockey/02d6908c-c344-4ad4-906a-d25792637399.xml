<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/primenenie-algebry-podstanovok-dlya-unifikatsii-programm]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Захаров В.А.]]></item>
    <item type="str"><![CDATA[Новикова Т.А.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Применение алгебры подстановок для унификации программ]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[ПРОГРАММА]]></item>
    <item type="str"><![CDATA[ОБНАРУЖЕНИЕ КЛОНОВ]]></item>
    <item type="str"><![CDATA[ЭКВИВАЛЕНТНОСТЬ]]></item>
    <item type="str"><![CDATA[ПОДСТАНОВКА]]></item>
    <item type="str"><![CDATA[УНИФИКАЦИЯ]]></item>
    <item type="str"><![CDATA[АНТИУНИФИКАЦИЯ]]></item>
  </keywords>
  <annotation auto="true" type="str" verify="true"><![CDATA[Для решения многих задач системного программирования, к числу которых относятся задачи реорганизации программ, деобфускации программ, выявления уязвимостей в программном коде и др., желательно иметь инструментальное средство, позволяющее обнаруживать фрагменты программ, имеющие сходное поведение. Современные средства обнаружения программных клонов позволяют выявлять лишь фрагменты программ, имеющие сходное синтаксическое устройство, поскольку более глубокий семантический анализ программ сталкивается с алгоритмической неразрешимостью проблемы функциональной эквивалентности программ. Для того чтобы избежать алгоритмически трудных задач проверки функциональной эквивалентности, авторы настоящей статьи предлагают воспользоваться более сильным разрешимым отношением эквивалентности программ логико-термальной эквивалентностью, введенной в 1972 г. В.Э. Иткиным. В данной статье разработан новый алгоритм проверки логико-термальной эквивалентности программ, основанный на операции вычисления точной нижней грани в решетке конечных подстановок. На основе этого алгоритма авторам статьи удалось также решить задачу логико-термальной унификации программ, которая состоит в построении для двух заданных фрагментов программного кода такой процедуры, которая представляет собой наиболее общую специализацию этих двух фрагментов.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[В.А.Захаров (ПСПРАН), Т.А. Новикова (ф-тп ВМКМГУ им. М.В. Ломоносова) {zakh@cs.msu.su} {taniaelfxi4naH.ru} Аннотация. Для решения многих задач системного программирования, к числу которых относятся задачи реорганизации программ, деобфускации программ, выявления уязвимостей в программном коде и др., желательно иметь инструментальное средство, позволяющее обнаруживать фрагменты программ, имеющие сходное поведение. Современные средства обнаружения программных клонов позволяют выявлять лишь фрагменты программ, имеющие сходное синтаксическое устройство, поскольку более глубокий семантический анализ программ сталкивается с алгоритмической неразрешимостью проблемы функциональной эквивалентности программ. Для того чтобы избежать алгоритмически трудных задач проверки функциональной эквивалентности, авторы настоящей статьи предлагают воспользоваться более сильным разрешимым отношением эквивалентности программ - логико-термальной эквивалентностью, - введенной в 1972 г. В.Э. Иткиным. В данной статье разработан новый алгоритм проверки логикотермальной эквивалентности программ, основанный на операции вычисления точной нижней грани в решетке конечных подстановок. На основе этого алгоритма авторам статьи удалось также решить задачу логико-термальной унификации программ, которая состоит в построении для двух заданных фрагментов программного кода такой процедуры, которая представляет собой наиболее общую специализацию этих двух фрагментов. Ключевые слова: программа, обнаружение клонов, эквивалентность, подстановка, унификация, антиунификация. 1. Введение Результаты статистических исследований, о которых говорится в работах [1], [2], [3], свидетельствуют о том, что суммарный объём клонов (фрагментов программ, имеющих сходное синтаксическое устройство) в больших проектах обычно составляет 7-20%, а в некоторых случаях доходит и до 50%. Наличие большого числа клонов приводит к увеличению стоимости поддержки кода, к возрастанию ресурсов, необходимых для компиляции и хранения скомпилированной программы, а также к увеличению вероятности возникновения новых и распространения существующих ошибок [4,5]. Поэтому от избыточного дублирования кода целесообразно избавляться при помощи существующих методов реорганизации (рефакторинга) кода, например, при помощи процедурной абстракции, также называемой “Выделением метода” (Extract Method) в терминологии Фаулера [6]. В статье [7] предложен метод процедурной абстракции, позволяющий для заданной совокупности программных клонов построить процедуру, вызов которой заменяет каждый из выделенных клонов. Однако применение этого метода требует предварительного выделения подобных фрагментов программ (клонов). К сожалению, специалисты в области анализа программного обеспечения ещё не выработали общепринятого формального определения понятия клона. В отличие от многих других широко используемых в программировании понятий (например, процедуры, алгоритма) в настоящее время не существует строгого математического определения понятия клона. Все исследователи сходятся в том, что клоном называются фрагменты, имеющие незначительные синтаксические отличия друг от друга, но до сих пор еще не сложилось общего мнения о том, какие именно синтаксические отличия можно признать незначительными. В обзоре [8] описано большое разнообразие методов выделения клонов на разных уровнях представления программы (текстовое представление, абстрактное синтаксическое дерево, граф потоков управления и данных). Однако при всем разнообразии этих методов они ограничиваются только поверхностным синтаксическим анализом программ и полностью игнорируют проверку семантических (функциональных) свойств программ. Вместе с тем, именно на основании анализа функций, вычислимых программами, можно дать строгое математическое определение отношения подобия фрагментов программ и разработать более изощренные алгоритмы выделения клонов. Задачу выделения программных клонов можно сформулировать, например, так: для пары программ жг,ж2, реализующих функции Ф, (х) и требуется выяснить, существует ли такая программа Ж0 (программа-шаблон), реализующая функцию Ф0(х), для которой равенства ФДх) = ц/х (O0(<^j (х))) И Ф2 (х) = у/2 (Ф0 ({Pi (х))) выполняются для некоторых функций ///(, <pi, i = 1,2, вычислимых очень простыми программами; эти программы осуществляют инициализацию переменных и последующую специализацию вычисленного результата. В этом случае программу-шаблон 7Г1] можно выделить в отдельный модуль (процедуру) и заменить обе программы жх, Ж 2 соответствующими вызовами этой процедуры. Нетрудно видеть, что в самой общей постановке задача распознавания клонов всегда имеет вырожденное решение - в качестве шаблона 7Г0 можно выбрать пустую программу, - и поэтому интерес представляют лишь такие варианты задачи, в которых на функции инициализации (р1 и специализации ///( налагаются дополнительные ограничения. В настоящей статье рассматривается один вариант задачи распознавания клонов, в котором на статус программы-шаблона Ж{) претендует одна из двух анализируемых программ ЖХ,Ж2, а в качестве процедуры инициализации переменных разрешается использовать только последовательную композицию операторов присваивания вида х1 := /,; х2 := /2;... хп := . В этом случае программа- шаблон (например, жх) становится процедурой, а вторая программа (в данном случае Ж2) заменяется вызовом этой процедуры с набором параметров ,..., ). В такой постановке задача распознавания клонов является частным случаем более общей задачи унификации программ. В задаче унификации выражений Ех и Е2 требуется отыскать пару наиболее общих эквивалентных примеров Е[ = Е181 и К = Е2в2 этих выражений. Чаще всего эквивалентность примеров Е[ и Е2 предполагает синтаксическое совпадение этих выражений. Интерес к задаче синтаксической унификации был обусловлен, в первую очередь, разработкой и применением метода резолюций в логике предикатов первого порядка [9] и развитием на его основе парадигмы логического программирования. Фактически, алгоритм унификации - это основной механизм вычисления логических программ. Задача унификации изучалась также и для языков более высокого порядка; в этих языках эта задача оказалась алгоритмически неразрешимой (см. [10]). Наряду с задачей синтаксической верификации во многих приложениях интерес представляет также и более сложная задача семантической унификации (или Е-унификации); в этом случае эквивалентность выражений Е[ и Е2 предполагает равенство этих выражений в тех или иных аксиоматических теориях. Некоторые результаты исследований задачи семантической унификации в различных логических и алгебраических теориях представлены в работе [11]. В настоящей статье впервые сформулирована и исследована задача семантической унификации последовательных императивных программ. Эта задача состоит в том, чтобы 143 для произвольной пары программ жх, Ж2 вычислить такую пару инициализирующих последовательностей операторов 6Х, 62 вида X] := ;х2 :=t2;...хп := 1п, для которой последовательные композиции программ 0{,7СХ и в2;ж2 оказываются эквивалентными. Очевидно, что алгоритмическая разрешимость задачи унификации программ возможна лишь в том случае, когда разрешимо то отношение эквивалентности программ, в рамках которого сформулирована эта задача. Известно, однако, что функциональная эквивалентность программ, семантика которых задана в свободных алгебраических системах, неразрешима [12]. Более того, как было показано в статье [13] нерекурсивно всякое невырожденное отношение эквивалентности программ, которое определяется на основании вычислений программ в интерпретациях (алгебраических системах). Поэтому в настоящей статье нами было выбрано одно из наиболее слабых разрешимых неинтерпретационных отношений эквивалентности программ - отношение логико-термальной эквивалентности. Две программы 7ГХ и 712 считаются логико-термально эквивалентными, если для любой синтаксически допустимой трассы !г' в одной из программ существует такая трасса 1т” в другой программе, что в обеих трассах логические условия (предикаты) проверяются в одной и той же последовательности для одних и тех же наборов значений переменных. Логико-термальная (л.-т.) эквивалентность была введена в статье [14]. Интерес к л.-т. эквивалентности программ был обусловлен двумя ее свойствами: 1) л.-т. эквивалентность программ 7ГХ и тг2 влечет функциональную эквивалентность этих программ [14], 2) отношение л.-т. эквивалентности программ разрешимо за полиномиальное время [15]. Было установлено также, что л.-т. эквивалентность - это одно из наиболее слабых рекурсивных отношений эквивалентности программ, аппроксимирующих отношение функциональной эквивалентности. В настоящей статье представлены два основных результата изучения задачи унификации программ: 1) новый алгоритм проверки л.-т. эквивалентности программ, использующий операции композиции и антиунификации в алгебре конечных подстановок, 2) алгоритм л.-т. унификации программ, разработанный на основе алгоритма проверки л.-т. эквивалентности программ. Статья состоит из 7 разделов. В разделе 2. введены основные понятия теории конечных подстановок. Во разделах 3 и 4 в терминах теории конечных подстановок определена модель стандартных схем программ и логикотермальная эквивалентность программ. В разделах 5 и 6 описан алгоритм проверки л.т. эквивалентности программ и алгоритм унификации программ. В заключении обсуждаются направления дальнейших исследований задачи унификации программ. 2. Алгебра конечных подстановок Рассмотрим конечный алфавит, состоящий из множества функциональных символов F , множества предикатных символов Р и множества предметных переменных Var. Множество термов Term(F, Var) - это наименьшее множество, удовлетворяющее следующим двум условиям: 1) Var <^Term(F,Var), и 2) если f(n>GF и {tut2,...,tn}^Term(F,Var), то f{n)(tl,t2,...,tn)^Term(F,Var). Атомарная формула (или просто атом) - это всякое выражение вида р('т> (tl,t2,...,tn), где р<'т'> G Р, а tl,t2,...,tn - термы. Множество атомарных формул обозначим записью Atom(F,Var) . Записи Vart и VarA обозначают множество переменных, входящих в терм t и атом А соответственно. Пусть X и Y - два конечных множества переменных. Подстановкой назовем всякое отображение д : X —> Term(FY), сопоставляющее каждой переменной из X некоторый терм из Term(F,Y). Множество всех таких подстановок условимся обозначать записью Subst(X, /' , Y). Если X = {Xj , Х2 ,..хп } и 6(xi) = tt для всех /, 1 <i <п, то подстановка 9 однозначно определяется множеством (списком) пар {Xj / tx, х2 /12,..., xn / tn }. Если /( = xi, то пара (связка) {хг / /(} может быть опущена в этом списке. Запись Vare будет использоваться для П обозначения множества переменных (J Vart , входящих в состав всех термов i=i ‘ подстановки 0. Результатом применения подстановки 0 к терму t,t GTerm(F,X\ называется терм tO, получающийся одновременной заменой в t каждой переменной xi термом B(xi) . Аналогично определяется результат применения подстановки к атому. Выражение ЕО, полученное в результате применения к выражению Е подстановки 0. будем называть примером выражения Е, специализированного подстановкой 0. Композиция вт] подстановок в g Sitbsl(X, /' , Y). rj е Subst(Y,F,Z) - это подстановка из множества Subst(X,F , Z), которая определяется равенством вт}(х) — (9(х))г/ для каждой переменной X, X е X. Всякая биекция 0 Y —^ Y называется переименованием. На множестве подстановок Subst(X ,F ,Y) определим отношение предпорядка -< и отношение эквивалентности ~: для пары подстановок отношение 0Х -< в2 выполняется, если существует такая подстановка 1) G Subst(Y, /' , Y), что 02 = в] 1}. и отношение выполняется, если О2 = д] р для некоторого переименования р . Отношение предпорядка -< индуцирует на множестве классов эквивалентности Subst(X,F,Y)/ ~ отношение частичного порядка <. Частично упорядоченное множество (Subst(X, F, Y) / <) образует решетку, наименьшим элементом которой является класс эквивалентности, порожденный так называемой пустой подстановкой {Xj / ух, х2 / у2,...,хп / у п }. Для того чтобы сделать решетку подстановок полной, добавим к множеству подстановок в качестве наибольшего элемента специальную мнимую подстановку т, удовлетворяющую равенствам тО = От = Г и Ехт = Е2Т для любой подстановки 0 и выражений Е1, Е2. Операция взятия точной верхней грани в этой решетке называется унификацией подстановок и обозначается символом Т, а операция взятия точной нижней грани называется антиунификацией подстановок и обозначается символом Х. Решетка (.Subst(X,F,Y)/ <) удовлетворяет условию обрыва убывающих цепей. Далее записи Эх Т 62 и 9г 62 будем использовать для обозначения произвольной подстановки из классов эквивалентности 0^ Т и в” I в" . Также для любой пары подстановок в', в' G Subst(X',F,Y) и 0", в" g Subst(X",F,Y) в том случае, если X' сл X" - 0 , мы будем использовать запись 8' и 9” для обозначения подстановки //. которая представляет собой теоретико-множественное объединение связок подстановок 9' и 9". Решетка подстановок была подробно исследована в статьях [16], [17]. В частности, установлено, что операция композиции обладает следующими двумя важными свойствами: 1. свойством монотонности: 9Х<92 => 1)6] -<Т}92 2. свойством левой дистрибутивности относительно операции антиунификации: Г}(91 Х 02) = (Г]9]) Х (>)62) . Именно эти свойства композиции подстановок обеспечивают корректность преложенного нами алгоритма проверки логико-термальной эквивалентности. Операции унификации и антиунификации подстановок - это основные алгебраические операции, которые будут использоваться для решения задачи унификации программ. Поэтому в этом разделе мы приведем также два наиболее эффективных алгоритма вычисления этих операций в решетке подстановок. 2.1. Алгоритм унификации подстановок Описанный ниже алгоритм унификации подстановок был предложен в работе [18]. В том случае, если множества термов из области значений подстановок задаются ориентированными ациклическими графами, этот алгоритм имеет линейную сложность как по времени, так и по объему используемой памяти. Пусть заданы две подстановки 9' — {х1 /х2 / /2,..., Xп / !'п } и 9” — {х1 / х2 / ¿2, • • •, хп / , принадлежащие множествам 8иЪ$^Х и Subst(X,F,Y") соответственно таким, что У Г\У" = 0 . Для того чтобы вычислить их унификацию в' Т в" составим систему термальных уравнений < = *? и будем применять в произвольном порядке к этой систем уравнений, до тех пор пока это возможно, следующие 6 правил переписывания уравнений. 1. Уравнение 5^) = ) замещается системой уравнений 2. Уравнение /= g(s[r,s",...,s',k) в том случае, если / ^ g , завершает работу алгоритма с результатом 9’ Т в" = Т: 3. Уравнение (тождество) 1 = 1 исключается из системы; 4. Уравнение ^ = _у в том случае, если _у - это переменная, а I - это терм, отличный от переменной, замещается уравнением у = t; 5. Уравнение у = ^ в том случае, если _у - это переменная, а t - это терм, содержащий у и отличный от у , завершает работу алгоритма с результатом 9' Т 9" = г; 6. Уравнение у = I в том случае, если _у - это переменная, / - это терм, не содержащий _у , и переменная у содержится еще хотя бы в одном уравнении системы, требует применения подстановки {у / ^ ко всем остальным уравнениям системы (их левым и правым частям); В том случае, когда образуется система уравнений, к которой неприменима ни одно из указанных выше правил, эта система будет состоять из уравнений ух = ,...,ук = 1к . в которых все переменные ух,...,ук попарно отличны и не содержатся в термах ^,..., . Тогда в' Т в- = в'{у, II,,-,у, И„ | = в-{у, И„-,У,/>„}. Операция унификации возникает при решении задачи унификации, которая состоит в вычислении наиболее общего примера двух выражений Е\ Е”. Если Е' = /->(/, Е' = р(.^} ,...,5И) - это атомарные формулы, и при этом 1а/)., Г) УагЕ, = 0 , то наиболее общим примером этих выражений является атом Е0 =р(х1',...,х„)90, где 90 ={х1!^,...,хп^п}^ {хх1 эп). Приведенный выше алгоритм унификации можно применять и для решения более общей задачи унификации конечных множеств пар выражений ЦЕ[,Е;иК,Е-2),...,(Е'т,Е-т)I Эта задача состоит в вычислении подстановки 0, применение которой приводит каждую пару выражений к общему виду. В этом случае работа алгоритма унификации начинается с системы уравнений Е[ = Е”, Е'2 = Е",..., Е’т =Е"т. 2.2. Алгоритм антиунификации подстановок Операция антиунификации подстановок имеет гораздо меньшую область применения, чем операция унификации. Антиунификация была введена Г. Плоткиным в статье [19] и активно использовалась для решения задач суперкомпиляции в статье [20]. В работе [21] было показано применение операции антиунификации подстановок для вычисления инвариантов программ и выделения синтаксических клонов. Оптимальный по времени алгоритм вычисления антиунификации подстановок, заданных ориентированными ациклическими графами, описан в статье [22]. Ниже приводится более простой алгоритм антиунификации подстановок, заимствованный из статьи [23]. Пусть заданы две подстановки 9' = {х1 /х2 / /2,..., Xп / !'п } и 9" = {х1 /х2Н'2,...,хп/0 из множества Е,У) , и пусть П П Z = У \ (и Уагг 'и и Усну,) - множество вспомогательных переменных, не !=1 г !=1 г входящих в состав термов из области значений подстановок 0' и 0". Антиунификация О' Х 0" вычисляется итеративным алгоритмом, который строит неубывающую последовательность подстановок Т)0,Т)Х , преобразуя систему аннотированных уравнений, порожденных подстановками 0' и 0". Каждое уравнение системы помечается некоторой вспомогательной переменной из множества Z. В начале работы алгоритма система аннотированных уравнений имеет вид ^ — tl ^2 ' 2 2 ,г ,гг г : I = I п п п и //„ = {х1 / г1, х2 / г2,..., хп / гп } . Далее на каждом / -ом шаге работы алгоритма к этой систем уравнений, до тех пор пока это возможно, в произвольном порядке применяются следующие 2 правила переписывания уравнений и вычисления последовательности подстановок Т}0,Т}г,________ 1. Аннотированное уравнение г: /(5^, 5',..., 5^ ) = / замещается системой уравнений ¿дг+1 • 7 * С — С ^Ы+пг • где 2м+\,2м+2,'"2м+т ~ переменные из множества I, ранее не использованные для разметки других уравнений; при этом Л г = Л г-1//(2Ы+1, 2 N+2 , ■ ■ ■ 2М+т ) } • 2. Если в системе есть пара одинаковых аннотированных уравнений г’’А'= ^ и 2" I" = х". то одно из уравнений (например, г': ^ = я') удаляется из системы; при этом //( = //( , {г'I г"} . Как только будет построена такая система аннотированных уравнений 2 М+1 • = - ’2М+к • = 5 к ’ К которой не применимо НИ одно из указанных двух правил, алгоритм прекращает работу. Результатом его работы является последняя из построенных подстановок 7). = О' Х 0". Пары подстановок {гм+]■/■} и *гд/ , /}. 7 = 1 соответствующие уравнениям сформировавшейся в конце работы алгоритма системы аннотированных уравнений, мы будем называть аннотирующими подстановками для вспомогательных переменных гм+1,..., гд/ к ; для них справедливы равенства в' = (в’ I в"){2и„ ...ги,„ /<>, в" = (в’ I в-){:и„ /*,'.....ги,„ /.<} Операция антиунификации возникает при вычислении наиболее специального шаблона двух выражений Ех, Е2, т.е. такого выражения Е0, примером которого является как Ег, так и Е2. Если Ег = р((] Ег = р(*] ,...,5И) - это атомарные формулы, то наиболее специальным шаблоном этих выражений является атом Е0 = р(хг ,...,хп)60, где в0 = {х1/^,...,хп/^}1{х1/з1,...,хп/зп}. 3. Стандартные схемы программ Стандартные схемы программ были введены в статье [12] в качестве математической модели для решения задач верификации и оптимизации последовательных императивных программ. Стандартная схема программ представляет собой конечную систему переходов (ориентированный размеченный граф), вершины которой соответствуют операторам ветвления, проверяющим выполнимость логических условий (предикатов), а переходы между вершинами (дуги графа) соответствуют линейным участкам программы, на которых выполняются последовательности операторов присваивания. Каждое логическое условие описывается атомарной формулой. Каждый оператор присваивания вида y'.= t может быть ассоциирован с подстановкой {уIt}', таким образом, линейному участку программы, состоящему из операторов ух := tl; у2 '■= t2;..., yn , может быть сопоставлена композиция подстановок 0 = {ylltl}{y2lt2}---{ynltn} , которая адекватно отражает в рамках алгебры подстановок вычислительный эффект выполнения операторов этого линейного участка. Формальное определение стандартной схемы программ (далее просто программы) таково. Пусть заданы два конечных множества переменных X = {xj,...,xn} и Y = {ух ,...,ут} . Переменные множества X - это входные переменные (параметры) программы, переменные множества Y -это внутренние (локальные) переменные программы. Помимо этих двух множеств переменных при выполнении операции антиунификации подстановок мы будем использовать множество вспомогательных переменных Z. Программой над множеством переменных X, Y называется размеченная система переходов л = (X, Y, V,entry,exit, —В,А0}, в которой V - это конечное множество точек программы, включающее точку входа entry и точку выхода exit, В'.V —> Atom(l'\ Y) - это функция привязки, сопоставляющая каждой точке программы атомарную формулу (логическое условие, проверяемое в этой точке), —>: (V \ {exit}) х {0,1} —> Subst(Y,F,Y) x V - это функция переходов, которая для каяедой точки программы, отличной от точки выхода, и для каждого истинностного значения логического условия в этой точке указывает подстановку, описывающую результат выполнения линейного участка программы, и точку программы, в которую передается управление после выполнения этого линейного участка, Л0 е 5иЬ$1(У,Р,Х) -подстановка, инициализирующая локальные переменные программы. В дальнейшем при обращении к функции переходов вместо записи -+(?,£) = (в,и) мы будем использовать более привычную запись Чтобы подчеркнуть особую роль некоторых вершин программы, условимся считать, что точке выхода программы exit приписана атомарная формула вида OUT(j/(| ,yf yf ) , которая выделяет выходные переменные среди локальных переменных программы. В этом случае можно ввести определение вычисления программы в заданной интерпретации на заданной оценке входных переменных (см. в [24]). Пусть задана произвольная интерпретация / = (D,F,P^ сигнатуры (F,Р). Оценкой множества переменных Var в интерпретации / называется всякое отображение d : Var —» D, сопоставляющее каждой переменной элемент из области интерпретации. Если Var = {z1,...,zkj, то для обозначения оценки 8 будем использовать запись {zx <— d(zx zk <— d(zk)}. Для обозначения множества всех оценок переменных Var в интерпретации / будем использовать запись Val (Var, /). Для каждой интерпретации / = (D,F,P^j и оценки б/, d G Va¡(XI). обычным образом определяются элемент области интерпретации t[d ], являющийся значением терма t, t G Term{X,F), и истинностное значение A{d] атомарной формулы A, A G Atom(X,F). Всякая подстановка 0, 0 G Subst(X, F, Y), в интерпретации / преобразует множество оценок переменных Val(XJ) в множество оценок переменных Val(Y,I) следующим образом: если 0 = {уг / tx, у2 /12,..., уп / tn }, то 0(d) = {yx <^№1У2 <^t2\d\..,yn <r- tn[d]}. Для каждой программы п = (Х, Y, V,entry,exit, —»,B,Ä0} и интерпретации / оценки переменных Val(XJ) играют роль входных данных, а оценки данных Vcil(Y,I) выступают роли состояний данных вычислений программы. Вычисление программы ж в интерпретации / для оценки входных переменных d,d G Val(X,I) - это максимальная последовательность сотр(ж, /, d) = (v0, d0), (Vj, dx), (v2 Д, (vt, dt), (v,.+1, dM удовлетворяющая следующим условиям: 1)v0= entry, d0=A0(d); 2) для любого i, i > 1, в программе ж существует переход v; Л,е >vi+1, где А = В(\Г )(б7 ), и при этом ^+1 = 9{di) . Если вычисление сотр(ж, I, d) бесконечно, то результат его не определен. Если вычисление сотр(ж, /, б/) завершается парой (ex/Y, d, ), и точке выхода приписана атомарная формула ОUT(yt ,yt yt ), то результатом вычисления является набор значений переменных (dN (yf ), dN (yf dN (_y; )). Таким образом, для каждой интерпретации / значением программы ж в этой интерпретации является частичная функция Ф j : Val(X, /) —> Dk , осуществляющая отображение оценок входных переменных в наборы значений переменных на выходе программы. Программы ж' и ж” считаются функционально эквивалентными, если для любой интерпретации / эти программы вычисляют одинаковые функции, т е. Ф, =: Ф, В работе [12] было доказано, что определенная таким образом функциональная эквивалентность программ алгоритмически неразрешима. Последующие исследования показали, что любое невырожденное отношение эквивалентности программ, определяемое на основе вычислений в интерпретации, неразрешимо даже для очень простых сигнатур (F,Р). В связи с этим в статье [14] была предложена иная разновидность программной эквивалентности, - логико-термальная эквивалентность, - которая занимает промежуточное положение между семейством чисто семантических отношений эквивалентности программ, наподобие функциональной эквивалентности, и семейством чисто синтаксических отношений эквивалентности, наподобие изоморфизма программ. 4. Логико-термальная эквивалентность программ В отличие от функциональной эквивалентности, опирающейся на семантическое понятие вычисления программы в интерпретации, определение логико-термальная эквивалентности программ основывается лишь на сопоставлении синтаксических характеристик анализируемых программ -множеств трасс, ведущих из входов программ в их выходы. Последовательность переходов в программе Ж tr=v —А°’в° >v —Al,gl >у —Лг’вг > — у —An’6n >у U У0 7 У1 7 |/2 7 VN 7 VN+l , в которой v0 = entry, мы будем называть трассой в программе Ж, ведущей в точку l’ v !. Если l’v ! = exit, то трасса tr будет называться полной трассой. Множество всех полных трасс программы ж обозначим записью СотрТг(ж). Префикс длины /, 0 </< N +1,трассы tr будет обозначаться записью tr |<г ; при этом мы полагаем tr |<0 = v0 и tr |<дг+1 = tr . Каждая трасса tr в программе Ж вычисляет подстановку в\1г] = вм---в2в1в0А0, которая представляет собой композицию инициализирующей подстановки Л0 и всех подстановок 60, д], 62,...6N, приписанных переходам этой трассы. Логико-термальная история (л.-т. история) полной трассы tr - это последовательность пар lth(tr) = (B(vo)0(tr |s0), Д0), • * * 5 5 (BtyWitr |ЙД A,.),... (B(vN)0(tr |sw), ДД (B(vN+l)0(tr),O) в которой первые компоненты пар - это примеры атомов В (vj), приписанных точкам трассы tr и специализированные подстановками 0(!г |<;), вычисленными в этих точках трассы, а вторые компоненты пар -это истинностные значения этих атомов, обеспечивающие прохождение трассы. Множество Detijz) = {lth(tr) : tr е СотрТг(ж)} л.-т. историй всех полных трасс программы ж называется детерминантом программы. Программы ж' и ж" считаются л.-т. эквивалентными, если Detijz') = Detij:"). Далее, не ограничивая общности, мы будем полагать, что в рассматриваемых программах через каждую точку проходит хотя бы одна полная трасса, т.е. в программах отсутствуют недостижимые и тупиковые точки. Программы такого вида будем называть редуцированными. Логико-термальная эквивалентность программ была предложена В.Э. Иткиным в статье [14]. В этой же статье была доказана теорема, устанавливающая взаимосвязь отношений логико-термальной и функциональной эквивалентности программ. Теорема [14]. Если программы ж' и Ж" л.-т. эквивалентны, то в любой интерпретации эти программы вычисляют одинаковые функции. Эта теорема показывает, что для проверки функциональной эквивалентности двух программ достаточно проверить их л.-т. эквивалентность. На основании этой теоремы л.-т. эквивалентность программ можно использовать при решении задач верификации и оптимизации программ. 5. Алгоритм проверки логико-термальной эквивалентности программ Первый алгоритм, разрешающий л.-т. эквивалентность стандартных схем программ был предложен в статье [14]. Сложность его оценивается двойной экспонентой, зависящей от размера проверяемых программ. Впоследствии были созданы более эффективные алгоритмы; в частности, в работе [15] был разработан алгоритм проверки л.-т. эквивалентности программ за время, полиномиальное относительно размеров программ. В этом разделе статьи описан еще более простой алгоритм проверки л.-т. эквивалентности программ. Мы сводим проверку л.-т. эквивалентности программ к вычислению точной нижней грани в регулярном множестве подстановок; это вычисление осуществляется итеративной процедурой, в которой применяются только операции композиции и антиунификации. Для завершения работы процедуре требуется совершить полиномиальное число шагов. Кроме того, после небольшой модификации эту процедуру можно использовать для решения задачи логико-термальной унификации программ. Следующее необходимое и достаточное условие л.-т. эквивалентности программ вытекает непосредственно из определения этого отношения эквивалентности программ. Теорема 1. Для того чтобы редуцированные программы ж' = (X, Y', V, entry', exit', —В', и ж" = (X,Y", V, entry", exit", -+”,В", Л”) были л.-.т. эквивалентными необходимо и достаточно, чтобы для любой конечной двоичной последовательности ©=A0,A1,...,AJV, всякий раз, когда в одной из программ (например, в программе ж') существует трасса tr' = v’—А°’е”—>v'—Al’gl' >yf——An,6>'n >yf u y0 T 4 T 2 T VN T VN+1 5 переходы которой размечены символами последовательности 0) в другой программе (в данном случае, в программе ж”) существует трасса переходы которой размечены символами той же последовательности (О , и при этом выполняется равенство B'(v'N+l )в[1г'] = B”(v”N+l )6?[//'"] Трассы tг' и //'". о которых говорится в теореме 1, будем называть логически согласованными трассами. Таким образом, теорема 1 сводит проверку л.т. эквивалентности программ к анализу пар логически согласованных трасс в этих программах. Этот анализ осуществляется в графе согласованных трасс программ ж' и ж". представляющем все пары логически согласованных трасс в этих программах. Предположим, что требуется проверить логико-термальную эквивалентность двух программ ж' = (X ,Y',V, entry', exit', В', Л'0) и ж" = {X, Y",V",entry",exit", ~^",В", Л"0), имеющих ОДНО И то же множество входных переменных X и непересекающиеся множества локальных переменных Y', Y", Y'r'Y" = 0 . Граф логически согласованных трасс этих программ Т\ж', 7z”\ = (V' х V", w0, =>, Л0 j устроен следующим образом Вершинами графа являются всевозможные пары w = (v', V") точек программ к' и к". и каждой такой вершине приписана пара атомарных формул (B'(v'), B"(v")). В графе Т\тг\ ж"\ особо выделена корневая вершина w0 = (entry', entry") . Дуги (переходы) графа Т\ж',ж”\ определяются отношением переходов с V'xV”xSubst(Y'^Y",F,Y'^Y")xV'xV" Как и для программ, вместо записи (v', v",8,и',и") е=> мы будем использовать более естественную запись отношения переходов в (v , V ) => (и , и ) . Это отношение подчиняется следующему требованию: (УУ)4(и'У) О 3 A G {0,1}: V >vff л vff А’в" >и" / в = в'^в" для каждой пары точек (V,v") и (и',и") графа Т\ж',ж”] и подстановки в, в g Subst(Y'<jY",F,Y'<jY") . И, наконец, Л0 = Л'0 Л" - это инициализирующая подстановка графа логически согласованных трасс. Маршрутом в графе логически согласованных трасс Т\ж',ж"~\ будем называть всякую последовательность дуг path = (v'0, v"0) => (v[, v”) => (v'2, v\) => • • • => (v^+1, v" +1), начинающуюся в корневой вершине w0 = (entry\ entry”). Как и в случае программ, выражение 0\path\ будет обозначать композицию 6N • • •626160Я0, состоящую из инициализирующей подстановки Л0 графа логически согласованных трасс и всех подстановок, приписанных дугам этого пути. Из теоремы 1 и описания устройства графа логически согласованных трасс Т\7г\тг''^ вытекает следующий критерий л.-т. эквивалентности программ к' и тг". Теорема 2. Редуцированные программы ж' и к” л.-т. эквивалентны тогда и только тогда, когда для любого конечного маршрута path , ведущем в графе Г[л_,1 к”\ из корневой вершины W 0 = (entry \ entry”) в вершину w = (v\v"), выполняется равенство ] )Q\paih\ = B"(v": ] )6\path]. Поскольку в графе Т\тг\ ж”] могут существовать вершины, в которые ведет бесконечно много маршрутов, условия проверки л.-т. эквивалентности программ, представленные в теореме 2, нуждаются в дальнейшем упрощении. Для этого воспользуемся следующей леммой. Лемма 1. Для любой пары атомарных формул А], А2 и для любой пары подстановок 0\ 0" справедливо соотношение А,в' = А2в' л Ахв” = А2в” о Ax{0’ie”) = А2(в'1в”) Доказательство. (=>) Если Ах6' = А26' и Ах6” = А26”. то это означает, что атомы А}, А2 унифицируемы и имеют наиболее общий унификатор [Л , для которого верны неравенства jU <6' и // -< в". Операция антиунификации вычисляет точную нижнюю грань О' Х 0" подстановок е\ в” , и поэтому /и -< О' Х 0" . Следовательно, подстановка в’I в” унифицирует атомы Аг, А2. т.е. верно равенство А^в' i в") = А2(в' i в"). (<=) Очевидно в силу определения точной нижней грани подстановок. □ Для заданного графа Т\ж\ ж"] логически согласованных трасс в программах ж' и тс” мы будем использовать запись PathSet(w) для обозначения множества всех маршрутов, ведущих из корня графа в вершину w . Тогда из теоремы 2 и леммы 1 следует Теорема 3. Редуцированные программы тс' и тс" л.-т. эквивалентны тогда и только тогда, когда для любой вершины w = (V, v") в графе Т\ж\ ж"], выполняется равенство B'(v')6\w] = В"(, где pafePathSetW d[palh] . Таким образом, задача проверки л.-т. эквивалентности программ сводится к задаче вычисления для каждой вершины W графа Г[7г\ ж"] точной нижней грани множества всех подстановок, вычислимых на маршрутах, ведущих в вершину W. Для решения этой задачи предлагается следующая процедура глобальной разметки графа логически согласованных трасс. 5.1. Процедура глобальной разметки графа Т\ж\ж"] В этой процедуре глобальной разметки графа Г[л_,1 ж"] каждой вершине W этого графа приписывается подстановка ijw, которая приближает сверху искомую точную нижнюю грань 0\w]; это приближение уточняется по ходу работы алгоритма. В начале работы процедуры корневой вершине И’п = (entry \ entry") приписывается подстановка >]И^ =Л0, а всем остальным вершинам w,w^w0, приписывается наибольшая в решетке подстановок мнимая подстановка Т . Далее, до тех пор пока это возможно, применяется следующее правило переписывания подстановок 7)w, которыми помечены вершины графа: если в графе Г[^г', ^г"] существует дуга u=>w , для которой не выполняется неравенство TJW -< вт]и , то вершине W вместо подстановки //и приписывается подстановка *7* = *7W 'l' вг!и. Процедура переписывания завершает работу в том случае, если для всех дуг в u=>w графа Т\ж\ж"\ выполняется неравенство J]w -<0?JU. Теорема 4. Каковы бы ни были программы ж' и ж" процедура глобальной разметки графа Т\ж\ ж"] логически согласованных трасс в программах ж' и ж" завершает свою работу и вычисляет в каждой вершине W подстановку = 0[w] = ipathePathSet(w) 9[path\. Доказательство. Свойство обрыва убывающих цепей в решетке подстановок гарантирует завершаемость работы процедуры переписывания. Воспользовавшись индукцией по числу шагов процедуры и применяя свойство левой дистрибутивности композиции подстановок относительно операции антиунификации ri(9l Х в2) = (j]d]) Х (т]92), можно показать, что на каждом шаге работы процедуры неравенство ^pathePathSet(w) 9[раЩ < //и выполняется для каждой вершины W графа Т\ж\ж"]. Воспользовавшись индукцией по длине маршрута и применяя свойство монотонности композиции подстановок 0Х <02 => 7)01 -< 7)02 , можно показать, что для каждой вершины W графа Т\ж\ж"] и для каждого маршрута path, ведущего в вершину W, по окончании работы процедуры переписывания выполняется неравенство 7)w -< 0\path\. Это означает, что вычисленная в конце работы процедуры глобальной разметки подстановка 7jw удовлетворяет равенству 7jw = IpathGPathSet(w) 0[path]. □ Таким образом, для проверки л.-т. эквивалентности программ ж' и ж” достаточно построить граф Т[ж\ж"] логически согласованных трасс в программах ж' и ж", применить описанную выше процедуру глобальной разметки и затем проверить для каждой вершины w = (v\ v") в графе Т\ж\ж"] выполнимость равенства B'(vr)7jw = B"(v")/Ju . где //и - это 159 подстановка, вычисленная процедурой глобальной разметки для вершины w . Теоремы 2-4 гарантируют завершаемость и корректность предложенного алгоритма проверки л.-т. Заметим также, что процедура глобальной разметки графа Г\ж',ж"], применяющая алгоритм антиунификации, вычисляет не только точные нижние грани подстановок 9\w] =\' pathspathSet(w) Q\path\ для каждой вершины w , но также и конечные множества пар аннотирующих подстановок для вспомогательных переменных. Эти аннотирующие подстановки будут играть ключевую роль в решении задачи унификации программ. 6. Логико-термальная унификация программ Условимся, что для каждой программы ж = (X, Y, V, entry, exit, —>, В, Л0 j и подстановки // запись ЖГ) будет обозначать программу Ж = (X, Y, V, entry, exit, —>, В, 90Г]}, полученную из исходной программы заменой инициализирующей подстановки 0{) композицией подстановок д07]. Программа Ж17 называется примером программы ж. Подстановка // называется логико-термальным унификатором пары программ ж' и ж", если примеры ж'т} и ж"г) этих программ л.-т. эквивалентны. Унификатор // программ ж' и ж” считается наиболее общим л.-т. унификатором, если для любого л.-т. унификатора /и этих программ выполняется неравенство 7) -< [Л . Задача л.-т. унификации программ состоит в том, чтобы для любой заданной пары программ вычислить их наиболее общий л.-т. унификатор. Задачу л.-т. унификации программ можно свести к задаче унификации множества пар атомарных формул, но это множество в общем случае может содержать бесконечно много пар атомов. Предположим, что имеются две программы ж' = lyX',Y', V',entry',exit', —,В',Лг0^ и ж” = [Х”, Y", V, entry”, exit”, —В”, Л") , у которых множества входных переменных X', X” и локальных переменных Y', Y" попарно не пересекаются. Рассмотрим граф Г[л_,1 ж"] логически согласованных трасс в программах ж' и ж". Как и прежде, запись PathSet(w) обозначает множество всех маршрутов, ведущих из корня графа в вершину w . Теорема 5. Подстановка Г), Г] G Subst(X'X",F,X'X"), является л.-т. унификатором программ ж’ и ж” тогда и только тогда, когда Г) является унификатором множества пар атомарных формул {(В' (y')6\path\, В"(у")в[раЩ) : (v', v") е V х V", path е PathSet((v’,v"))} . Справедливость теоремы 5 следует из теоремы 3 и определения л.-т. унификатора программ. Таким образом, для унификации программ ж' и ж” достаточно разработать способ унификации бесконечного множества пар атомарных формул. Решить эту задачу при помощи одного лишь алгоритма унификации, описанного в разделе 2.1, невозможно. Для ее решения мы воспользуемся комбинацией двух алгоритмов - процедурой глобальной разметки графа логически согласованных трасс и алгоритмом унификации конечного множества пар атомарных формул. Поочередно проводя глобальную разметку графа логически согласованных трасс и унификацию конечного числа пар атомарных формул, описанная ниже процедура л.-т. унификации программ формирует конечную последовательность подстановок , приближающих снизу л.-т. унификатор заданной пары программ ?JN, который вычисляется на последнем этапе работы процедуры. 6.1. Процедура л.-т. унификации программ. В начале первого этапа работы процедуры полагаем //, = {х[/ х[,...,х'п/ х'п, х" / х”,..., х"т / х”т } (тождественная подстановка) На каждом i -ом этапе работы процедуры строится граф Г[7г7/(, 7r"l]i ] логически согласованных трасс в примерах ж'т]1,ж''7]1 программ ж' и ж" . Затем к графу Т\ж'г){,ж”г1{\ применяется процедура глобальной разметки, которая вычисляет для каждой вершины w подстановку (9[и’], (9[и’] g Subst(Y' Y", F, X' kj X" \jZ) , и конечное множество пар аннотирующих подстановок { ({z/s'\.\zIS"}) :zeZJ для вспомогательных переменных, возникающих по ходу применения операции антиунификации. В графе Г[7г7/(, ж”)]^ ] выделяем множество вершин Wt. = {w : w = (V, v") a B'{v's)9\w'\ ^ B"(v")e\w\}, в которых нарушается условие л.-т. эквивалентности примеров программ ж'т}1,ж',Г}1, описанное в теореме 3. Если IV! = 0. то согласно теореме 3 примеры программ ж'г)[, тг")]1 являются л.-т. эквивалентными, и подстановка т¡i объявляется результатом работы процедуры л.-т. унификации программ ж' и ж" . Если Жг- Ф 0 , то к конечному множеству пар атомарных формул применяется модифицированный алгоритм унификации. На вход этого алгоритма поступает система уравнений { В'{у')в[м>] = В"(у")в[м>] : м’ = (у,У)^Ж1}. К этой системе, до тех пор пока это возможно, применяются 7 правил переписывания уравнений, заимствованных из алгоритма унификации. Первые 5 правил в точности совпадают с правилами 1-5 из раздела 2.1., в котором описан алгоритм выполнения операции унификации подстановок. Последние два правила представляют собой следующие модификации правила 6 из раздела 2.1: 6.1. Уравнение X = ^ в том случае, если X - это входная переменная из множества Х'иХ", I - это терм, не содержащий X, и переменная X содержится еще хотя бы в одном уравнении системы, требует применения подстановки {х/^} ко всем остальным уравнениям системы (их левым и правым частям); 6.2. Уравнение г = t в том случае, если г - это вспомогательная переменная из множества Z, снабженная парой аннотирующих подстановок {г / л7} и {г / л ”}. а / - это терм, не содержащий 1, требует замены каждого уравнения системы ^ ^ (включая само уравнение г = ^) парой уравнений = 1”\21 н \ и Если ни одно из правил 2 или 5 «аварийного» завершения работы алгоритма унификации не применяется, то модифицированный алгоритм унификации прекращает свое выполнение, как только будет построена система уравнений, к которой неприменимо ни одно из перечисленных правил 1-5, 6.1, 6.2. Образованная в этом случае система уравнений состоит только из уравнений Х1 Xк =ík, в которых все переменные Х1,..., хк - это попарно различные входные переменные из множества Х’^Х” , не содержащиеся в термах t1,...,tk. Тогда результатом работы /-ого этапа процедуры л.-т. унификации объявляется подстановка Т]м = //({х, Xк /tk} . Теорема 6. Каковы бы ни были программы Т[' и 71", описанная выше процедура унификации программ завершает свое выполнение. Подстановка TJN, вычисленная этой процедурой, является наиболее общим унификатором программ ж' и ж". Доказательство. Чтобы убедиться в завершаемости описанной процедуры, достаточно заметить, что для последовательности подстановок Г)х, г\2,..., rjN, вычисленных на каждом этапе ее работы, имеет место строгое включение Var a Var^ . Следовательно, процедура не может иметь более этапов выполнения. Чтобы обосновать корректность процедуры, достаточно доказать, используя индукцию по числу этапов, справедливость следующих двух утверждений: 1) последовательность 1)],1)2,..., //, является строго возрастающей последовательностью в решетке подстановок, и 2) для любого члена Tji этой последовательности и для любого л.-т. унификатора р программ 7l' и ж" выполняется неравенство 7]i ~< р. Справедливость первого утверждения следует из определения последовательности подстановок Т]х, i]2,..., rjN . Для доказательства последнего из этих двух утверждений следует воспользоваться теоремой 5 и заметить, что согласно описанию процедуры л.-т. унификации каждая из подстановок 7)м является наиболее общим унификатором непустого множества пар атомарных формул {(B'(v')e[path\ B"(v")d[path]) : (v\ v") e path e R\ для некоторого подмножества маршрутов R с: PathSet(_(y,,v'r)) в графе логически согласованных трасс в программах 7t' и 71" . Предложенный нами алгоритм л.-т. унификации программ можно применять для решения задачи процедурной абстракции. Предположим, что унификатором пары программ к' = {X\Y\V \ entry', exit',, В', и 7г" = (Х”,Y”\V"entry", exit", В", Л"') является подстановка //, = {x”l/tm}, в которой все термы зависят только от переменных из множества X' (от входных параметров программы ж'). Тогда программа ж” является примером программы ж'. В этом случае программу ж' можно объявить отдельной процедурой, а все вхождения программы ж" можно заменить вызовом этой процедуры call ж\^,...^т) со списком параметров 7. Заключение Основной результат этой статьи - это решение двух задач, возникающих при анализе последовательных императивных программ, - задачи проверки эквивалентности программ и задачи унификации программ. Для решения обеих задач был задействован математический аппарат алгебры подстановок с двумя основными операциями - операцией взятия точной верхней грани (унификация) и точной нижней грани (антиунификация) двух подстановок. На основе этих операций были предложены алгоритм проверки логикотермальной эквивалентности и алгоритм логико-термальной унификации программ. Эти алгоритмы можно использовать для решения многих задач семантического анализа и эквивалентных преобразований программ, включая задачи оптимизации, верификации и реорганизации программ, Вместе с тем, практическое применение предложенных нами алгоритмов требует решения целого ряда вопросов, касающихся сложности рассмотренных задач. Вот лишь некоторые из них. 1. Оба операции над подстановками - унификации и антиунификация, - могут быть выполнены за время, пропорциональное размерам исходных данных. Однако наибольшая эффективность выполнения этих операций достигается на разных формах представления подстановок: для эффективного выполнения операции унификации желательно, чтобы термы были представлены в виде ориентированных размеченных ациклических графов, в то время как операция антиунифкации наилучшим образом приспособлена для работы с древесным представлением термов. Поскольку в алгоритме л.-т. унификации программ задействованы обе операции, необходимо отыскать такую форму представления термов, которая была бы оптимальной для обеих операций. 2. Для проверки л.-т. эквивалентности программ достаточно уметь вычислять любую (не обязательно точную) нижнюю грань двух подстановок при условии, что операция вычисления этой нижней грани будет обладать свойством левой дистрибутивности относительно операции композиции подстановок, и для нее будет справедлива лемма 1. В связи с этим целесообразно изучить вопрос о выборе оптимальной по сложности вычисления операции взятия какой-либо нижней грани двух подстановок, которую можно использовать в процедуре глобальной разметки графа логически согласованных трасс для проверки л.-т. эквивалентности программ. 3. Предложенный нами алгоритм л.-т. унификации программ - это многопроходная процедура разметки графов логически согласованных трасс программ. Поэтому одно из направлений повышения эффективности алгоритма л.-т. унификации программ состоит в сокращении числа проходов этой процедуры. Отметим также, что алгоритмическое решение задач проверки логикотермальной эквивалентности программ и выполнения логико-термальной унификации программ создает хорошие предпосылки для решения задачи, имеющей более важное прикладное значение, - вычисление наиболее специального шаблона двух программ (задачи логико-термальной антиунификации программ). ]]></text>
</doc>
