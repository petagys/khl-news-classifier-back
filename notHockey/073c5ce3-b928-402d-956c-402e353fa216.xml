<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/dinamicheskaya-podderzhka-rasshireniy-protsessora-v-kross-sisteme]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Рубанов В.В.]]></item>
    <item type="str"><![CDATA[Гриневич А.И.]]></item>
    <item type="str"><![CDATA[Марковцев Д.А.]]></item>
    <item type="str"><![CDATA[Миткевич М.А.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Динамическая поддержка расширений процессора в кросс-системе]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[В статье рассматривается задача моделирования расширений процессора в виде акселераторов (сопроцессоров) для автоматической настройки кросс-системы, включающей в себя ассемблер, компоновщик, симулятор, отладчик и профилировщик. Рассматриваемый подход основан на описании моделей акселераторов на разработанном языке спецификации с последующим использованием этих моделей кросс-системой во время ассемблирования, потактовой симуляции и отладки прикладных программ, содержащих команды акселераторов, не известные на этапе построения основного инструментария (определяемые соответствующими моделями). В статье рассматривается математическая модель поддерживаемых акселераторов и интерфейса с основным процессором. Описывается язык спецификации конкретных моделей акселераторов, дается обзор технологий настройки кросс-системы для поддержки описанных таким образом расширений.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[В.В. Рубанов, А.И. Гринееич, Д.А. Марковцев, МЛ. Миткевич Аннотация. В статье рассматривается задача моделирования расширений процессора в виде акселераторов (сопроцессоров) для автоматической настройки кросс-системы, включающей в себя ассемблер, компоновщик, симулятор, отладчик и профилировщик. Рассматриваемый подход основан на описании моделей акселераторов на разработанном языке спецификации с последующим использованием этих моделей кросс-системой во время ассемблирования, потактовой симуляции и отладки прикладных программ, содержащих команды акселераторов, не известные на этапе построения основного инструментария (определяемые соответствующими моделями). В статье рассматривается математическая модель поддерживаемых акселераторов и интерфейса с основным процессором. Описывается язык спецификации конкретных моделей акселераторов, дается обзор технологий настройки кросс-системы для поддержки описанных таким образом расширений. 1. Введение В статье рассматривается задача моделирования расширений процессора в виде акселераторов (сопроцессоров) для автоматической настройки инструмен-тария кросс-разработки для поддержки этих расширений. Под инструмен-тарием кросс-разработки (кросс-системой) понимается набор программных компонентов (ассемблер, компоновщик, симулятор, отладчик и профилиро-вщик) для разработки прикладных программ с использованием хост-машины, отличной от целевой аппаратуры. Под поддержкой расширений кросс-системой подразумевается ассемблирование, потактовая симуляция и отладка прик-ладных программ, содержащих команды, не известные на этапе построения основного инструментария (реализуемых специфическими для пользователя акселераторами). Рассматриваемый подход основан на предоставлении пользо-вателю возможности описать модели акселераторов на разработанном языке спецификации с последующим использованием этих моделей для настройки компонентов кросс-системы. Данная задача возникает в связи с тем, что многие современные аппаратные решения строятся на основе использования стандартного процессорного ядра со специализированными расширениями в виде акселераторов. Часть системы команд ядра зарезервирована для команд обращения к интерфейсу запуска инструкций акселераторов. Однако семантика реальных действий и вычис-лений, которые инициируют такие команды, определяется конкретными акселераторами и не зависит от основного процессора. Производитель ядра и производители акселераторов могут быть разными компаниями, при этом инструментарий кросс-разработки от производителя основного процессора должен уметь поддерживать неизвестные для него расширения аппаратуры, которые создаются заказчиками. В данной работе под расширениями процессора понимается добавление акселераторов, которые могут вводить в систему новые элементы памяти (регистры, памяти данных) и определять семантику команд запуска инструкций акселераторов. Аппаратура на базе основного процессора с акселераторами представляется для прикладного программиста как вычислительная система с единой системой команд и одной программой. Память системы состоит из памяти основного процессора, разделяемой памяти и локальных памятей акселераторов. Для выделения класса поддерживаемых акселераторов и интерфейса с процессором была разработана абстрактная математическая модель, позволяющая моделировать состояние и поведение широкого класса акселераторов с потактовой точностью. Для описания конкретных моделей, в рамках данной абстрактной, предложен язык спецификации (КЕ), разработаны средства визу-ального редактирования спецификаций на этом языке и средства анализа и выявления ошибок в спецификациях. Реализован подход интерактивной пере-настройки кросс-системы, заключающийся в настройке компонентов (ассемблер, дисассемблер, симулятор, отладчик) на основании интерпретации описаний моделей акселераторов. Система используется в коммерческой эксплуатации, в ней успешно реализованы модели реальных акселераторов. Статья состоит из введения, трех глав и заключения. В первой главе описывается подход к моделированию акселераторов, вводится абстрактная модель акселератора и средства описания конкретных моделей на языке ШЕ. Во второй главе содержится описание технологии интерактивной перенастройки кросс-системы для поддержки заданных пользователем моделей акселератов. Третья глава содержит краткий обзор смежных работ. В заключении приводятся практические результаты, полученные при эксплуатации разработанной системы. Приводится план будущих направлений развития темы. 2. Моделирование расширений процессора В данной главе рассматриваются вопросы моделирования расширений процес-сора в виде акселераторов. Для этого вводится абстрактная (математическая) модель акселератора, охватывающая достаточно широкий класс возможной аппаратуры (см. 2.1). В рамках этой абстрактной модели определяются сред-ства описания конкретных моделей акселераторов в виде файлов на специа-льном языке КЕ (см. 2.2). Описанные таким образом модели акселераторов используются для автоматической конфигурации компонентов кросс-системы - симулятора, ассемблера, дисассемблера, отладчика и профилировщика (см. главу 3). 2.1. Абстрактная модель акселератора В нашей модели акселератор является сопроцессором, команды которому выдаются основным процессором. Акселератор работает синхронно с процессором. Акселератор может иметь собственную локальную память и имеет доступ к общей памяти между процессором и всеми акселераторами. 2.1.1. Состояние акселератора 2.1.1.1. Память акселератора Ячейка памяти представляет собой набор двоичных переменных (далее битое), с возможными значениями О или 1. Число битов определяет разрядность ячейки. Набор из одной или более ячеек одинаковой разрядности образует область памяти. Набор из одной или более областей образует память. Память будем обозначать большой буквой 8. Состояние ячейки памяти определяется набором конкретных значений всех ее битов. Состояние памяти определяется состоянием всех ячеек ее областей. Состояние памяти будем обозначать маленькой буквой в. Обозначим через N сумму разрядностей всех ячеек памяти 8, тогда память может находиться в одном из 2 ' состояний. Множество состояний памяти будем обозначать {в}. Заметим, что это множество однозначно задается структурой памяти. Дескриптор структуры памяти Е представляет собой следующий набор чисел: число областей О и набор из О пар (\¥ь 8,). задающих разрядность ячеек области и их количество Б;. В нашей модели память системы состоит из памяти основного процессора 8Р, разделяемой памяти и локальных памятей акселераторов 5"г: 5 = ^ р , Б 8 , {5 “} ^ |, ЫА - число акселераторов Рассмотрение памяти процессора не принципиально для данной статьи, так как акселератор имеет доступ только к разделяемой и своей локальной памяти. Пара из этих памятей формирует полную память акселератора: БЛ = {5х ,5“} Множество возможных состояний памяти акселератора обозначим как Каждая область в локальной и разделяемой памяти характе-ризуется скоростью доступа - числом, означающим, сколько тактов проходит после записи в ячейку этой области, прежде чем измененное значение может быть прочитано; до этого момента при чтении считывается старое значение. Обычно в памяти акселератора можно выделить следующие области: ■ Набор из одной или более памятей данных ■ Набор из одного или более регистровых файлов я Одиночные регистры 2.1.1.2. Управляющее состояние Акселератор имеет фиксированное количество управляющих слотов, совокупность которых обозначается РА. Каждый слот имеет номер, который далее будет отождествляться с соответствующим слотом. Каждый слот представляет собой пару целочисленных переменных (полей): поле номера команды ¡у и поле состояния команды I. Множество значений поля команды (Ні; конечно. Ноль всегда принадлежит {П[|. Существует взаимно однозначное соответствие между {П[ |\0 и множеством дескрипторов команд, определение которого будет дано ниже. Поэтому мы будем отождествлять номер п є и>!} и соответсвующий дескриптор / Множество значений ПОЛЯ состояния команды есть натуральные числа (включая 0). Состояние слота с номером п обозначается 1п = (п^, () и определяется значениями полей этого слота. Множество возможных состояний слота {/} = {п^} х N. Слот в состоянии (0, 0) называется свободным, в ином случае активным. Управляющим состоянием р акселератора называется совокупность состояний всех его управляющих слотов. Множество управляющих состояний акселератора обозначим {р\ , = {І\"і, где Д'л число слотов акселератора. Активные слоты соответствуют выполняющимся командам акселератора, число управляющих слотов задает максимальное количество параллельно выполняющихся команд. В состоянии активного слота значение поля номера команды задает выполняющуюся команду, а значение поля состояния команды соответствует количеству тактов, прошедших с начала выполнения этой команды. 2.1.1.3. Состояние акселератора Состояние акселератора а задается парой из состояния памяти и управляющего состояния: а={в, р}. Множество состояний акселератора обозначим как {а}А = х{р}А . Элементом состояния акселератора называется любая ячейка памяти акселератора или любой управляющий слот. Состоянием элемента называется соответственно состояние ячейки или слота. Параллельной композицией функций (р1,(р2...(рп (заданных на множестве состояний акселератора) назовем функцию со = <р] || ср2 ||... || ([>„ (также заданную на множестве состояний акселератора), получаемую следующим образом: пусть А ={а} = РА множество всех элементов состояния акселератора, А-- множество элементов, состояние аа которых было изменено функцией (р/: аєА1<^аа Если пересечение всех А ■, / = 1. .п не пустое множество, то значение функции со не определено. В ином случае значение со задается следующим образом: fa' =а ,<x<eA\YA. , здесь а’а и аа - новое и , \ a a’ i а =со =\ , старое состояние элемента \а = q>.(a),a еА. г [ сс г i а соответственно 2.1.2. Модель акселератора Операцией [элементарной] называется, заданная на множестве состояний памяти акселератора {s}a (см. 2.1.1.1) функция ц/, формирующая следующее состояние памяти акселератора на основе предыдущего. Операции соответствуют действиям, которые могут быть выполнены за один такт (например, сложение двух регистров): V- Множество операций акселератора обозначим ' V 1 = {у/}. Для любого акселератора в этом множестве присутствует так называемая пустая операция, не изменяющая состояние и обозначаемая ц/0. Каждая элементарная операция характеризуется функциональными ресурсами, которые необходимы для выполнения этой операции. Обозначим множество всех ресурсов акселератора как RÁ, а множество всех его подмножеств (включая пустое) как Va. Функция гА, отображающая множество операций 11' 1 на множество РА, называется функцией ресурсов. Она задает набор ресурсов для каяедой операции в 11' 1: rÁ : Т'4 -> Va Обозначим множество всех подмножеств в 11' 1, которые состоят из операций, использующих не пересекающиеся ресурсы, как ПА : со е С1А <=> V i//;, у/ . eco, i Ф j ->■ гА (у/ {)п гА (iу .) = 0 Таким образом, элемент множества ПА задает группу операций ¡i//( |. которые могут выполняться параллельно (в рамках одного такта). Применением параллельной композиции (см. выше) этот элемент задает функцию на множестве состояний памяти акселератора {s}a. Далее элементы множества ПА будем отождествлять с задаваемыми ими функциями и называть комплекс-операциями. Заметим, что в этом смысле 'I'1 с flA . Определим два управляющих действия: продвижения next и окончания end. Каяедое представляет собой параметрическую функцию на множестве управляющих состояний акселератора. Параметром функции является номер слота щ є[1. Действие next увеличивает на 1 значение поля состояния команды t для слота, заданного параметром щ . Действие end переводит соответствующий слот в холостое состояние. Множество из этих управляющих действий обозначим UA = {next, end}. Дескриптором команды акселератора называется функция / , вычисляющая пару из комплекс-операции ю є Q1' и управляющего действия ueUA на основании состояния памяти акселератора л є ¡.vj , и состояния команды / eN (см. 2.1.1.2): множество конечно и каждому элементу / приписывается номер п! >1 (например, в порядке возрастания машинного кода в соответствии с отображением, задаваемым функцией декодирования, см. ниже). При этом для дескриптора команды всегда верно следующее (единственность конца команды): Дескриптор команды / однозначно задает функцию потактового поведения команды Ьу, определенную на множестве состояний акселератора и параметризуемую номером слота щ . Значение функции Ьг не определено, если значение поля номера команды в соответствующем слоте щ не совпадает с номером соответствующего дескриптора / . В ином случае функция Ьу(п1)\{а}А —>• \а\ , задается следующим образом: 1. На основании состояния памяти в и значения поля состояния команды I в слоте с номером п1 с помощью дескриптора команды определяется пара из комплекс-операции со и управляющего действия и : /: х N —» С1А х UA Множество дескрипторов команд акселератора обозначается Iа = {/]}. Это /(s, т) = {(о,end} =>Vt > т : f(a>(s\ t) = undefined {co,u} = f(s,t) 2. С помощью со определяется следующее состояние памяти л'=ю(У), а управляющее действие задает следующее управляющее состояние р' = и(щ, р). Пара (У,//) задает значение Ь^{щ^,р). Таким образом, множество дескрипторов команд однозначно задает множество функций потактового поведения Вл, имеющее столько же элементов. Множество кодов инструкций акселератора СЛ = {сі} представляет собой множество двоичных чисел одинаковой разрядности. Каждый элемент этого множества соответствует одному из возможных значений поля код инструкции акселератора в машинном коде команды запуска акселератора (см. 2.1.3.1). Функция декодирования с1Л задает отображение множества кодов инструкций акселератора СА на множество дескрипторов команд Iа : ал : СА -» Iа Функция декодирования однозначно задает декодер акселератора - функцию П1: ВЛ : Сл х{р}А ->{р}А\ Функция I)1 определяется следующим образом: если 3и0 : = (0, 0), то ^¡=(/иЛХ ПФП0 А . , иначе значение и не определено. Г„={с1А{с)Л),п=п0 Иными словами, в случае наличия свободного управляющего слота декодер инициирует состояние этого слота в (/, 1), где / определяется по коду инструкции с помощью функции декодирования сіА . Тактовая функция ТА на множестве состояний акселератора {а}д, определяет изменение состояния акселератора на каждом такте: ТА : {а}А —» {а}А Эта функция однозначно задается параллельной композицией (см. 2.1.1.3) функций потактового поведения , соответствующих дескрипторам команд /, заданным в поле П/ каждо го активного управляющего слота. Иными словами для каждо го такта управляющее состояние акселератора определяет набор активных команд, характеризуемых функциями потактового поведения. Параллельная композиция этих функций задает отображение Т 1 (поведение акселератора) для текущего такта. Если активных слотов нет, то состояние акселератора не меняется. р' = Ба (с,р) = Абстрактная модель акселератора МА определяется следующими описанными выше элементами: МА = ^Л,РЛ,СЛ,ПЛ,ТЛ} 2.1.3. Симуляция акселератора Для симуляции акселератора, заданного моделью Л/ 1 (см. 2.1.2), необходим генератор тактов, а также определенное начальное состояние памяти «о є ¡л| ,. В начальном управляющем состоянии р0 все слоты свободны. В рассматриваемой системе акселераторы и основной процессор работают тактово-синхронно (тактовый генератор единый для всей системы), то есть такт работы акселератора равен такту работы процессора. Кроме тактового генератора, единственным внешним событием для акселератора является выдача очередной команды основным процессором (см. 2.1.3.1 ниже). 2.1.3.1. Запуск команд акселератора В рассматриваемой модели аппаратуры множество команд основного процессора должно иметь непустое подмножество, представляющее собой команды запуска акселераторов. Такие команды инициируют запуск определенной инструкции соответствующего акселератора. С точки зрения основного процессора команда запуска акселераторов определяется тремя полями машинного кода (порядок полей несущественен, также поля не обязательно должны быть непрерывными): {КОП, номер акселератора, код инструкции акселератора} Действия основного процессора при выполнении команды запуска акселератора заключаются в активации акселератора с номером в соответствующем поле и выдаче этому акселератору кода инструкции акселератора для дальнейшего декодирования и выполнения команды в самом акселераторе параллельно с работой процессора. Для основного процессора выполнение команды запуска акселератора всегда занимает один такт. В терминах абстрактной модели выдача команды акселератора основным процес-сором заключается в передаче кода инструкции акселератора в функцию деко-дера акселератора I) ' (СА это подмножество множества значений поля код инструкции акселератора). За один такт процессор может выдать не более одной команды акселератора. Заметим, что код инструкции акселератора в свою очередь может содержать КОП команды акселератора и операнды. Акселератор может параллельно выполнять несколько многотактовых команд, в том числе с одинаковым дескриптором. То есть основной процессор может выдавать новую команду акселератора, до того как отработали предыдущие команды. В рамках рассматриваемой модели это возможно, если все операции, выполняемые параллельно на каяедом такте, используют непересекающиеся ресурсы (см. 2.1.2). На практике это 70 возможно, если позволяет конвейер и функциональные устройства акселератора, при этом ответственность за корректную (своевременную) выдачу команд акселератора лежит на прикладном программисте. 2.1.3.2. Тактовое поведение акселератора В ответ на событие от тактового генератора, в рассматриваемой модели действия акселератора сводятся к изменению состояния в соответствии со своей тактовой функцией Iа . Эта функция определяет поведение акселератора на каяедом такте. 2.1.3.3. Обмен данными и синхронизация с процессором Обмен данными между процессором и акселераторами осуществляется через разделяемую (общую) память (см. 2.1.1.1). Заметим, что дополнительная информация от процессора к акселератору может также поступать в виде параметров инструкции (см. 2.1.3.1). Заметим, что разные акселераторы не имеют доступа к локальной памяти друг друга. Разделение доступа к общей памяти в нашей модели соответствует типу CREW (Common Read Exclusive Write). Это означает, что процессор и акселераторы могут одновременно (в рамках текущего такта) читать из ячейки памяти, однако одновременная запись запрещена. В рассматриваемой модели области памяти могут иметь задержку записи, характеризуемую скоростью доступа к памяти (см. 2.1.1.1). По умолчанию, все области памяти имеют задержку 1, то есть изменения могут быть прочитаны только на следующем такте (flip-flop модель). Заметим, что если задержка больше ноля, то возможна одновременная запись и чтение одной и той же ячейки, при чтении считывается предыдущее значение. Команды акселератора могут занимать фиксированное или переменное (в зависимости от данных) число тактов. С точки зрения прикладного программиста (компилятора) существует три способа синхронизации вычислений основного процессора и результатов работы определенной команды акселератора: 1. Когда команда акселератора всегда имеет фиксированное число тактов выполнения, программист может статически просчитать, когда будут готовы результаты вычислений (процессор и акселераторы работают синхронно, см. 2.1.3). 2. Акселератор в процессе выполнения может выставлять определенные флаги (менять ячейки) в общей памяти. Программа основного процессора может считывать значения этих флагов и определять готовность результатов вычислений акселератора. 3. Частным случаем пункта 2 является вызов акселератором прерывания основного процессора. Обработчик прерывания может прочитать результаты вычислений акселератора. 2.2. Средства описания конкретных моделей акселераторов Для задания конкретной модели акселератора необходимо определить следующие параметры, множества и функции: тА = ^.A,Ns,CA,dA,IA,x¥A,RA,rA} Соответствующие определения были даны в 2.1.1 и 2.1.2, где также было показано, что они однозначно задают все элементы абстрактной модели: Еа ~^Sa, Ns ~^Ра , dA ~^DA, 4>A,RA,rA ~^Qa, Ia,Qa ~^Ba ~^TA . Для описания конкретных моделей акселераторов в ИСП РАН был разработан язык спецификации ISE (Instruction Set Extension). Кроме собственно спецификации соответствующих элементов конкретной модели акселератора (см. выше), в язык также входят средства описания дополнительной информации об ассемблерном синтаксисе команд акселератора, отображении ассемблерных команд в машинные коды и описание форматов для визуализации областей памяти в отладчике. Модель акселератора далее будет отожествляться со спецификацией этой модели на языке ISE. 2.2.1. Дескриптор структуры памяти Существуют отдельные синтаксические конструкции для описания следующих типов областей памяти: ■ Памяти данных ■ Регистровые файлы ■ Одиночные регистры С помощью этих конструкций можно задать дескриптор структуры памяти ЪЛ (см. 2.1.1.1). Пример. Структура памяти простого акселератора: • две памяти данных LDM и ТМ размером 2048 слов каяедая с разрядностью 16 и 64 бита со скоростью доступа 3 такта • Регистровый файл GRF из двух 16-ти разрядных регистров GR0 и GR1 • Одиночный регистр-аккумулятор ACR разрядностью 36 бит DECLARE_MEMORY(INT(16, 3), 2048) LDM; DECLARE_MEMORY(INT(64, 3), 2 048) ТМ; DECLARE_REGISTERS_FILE(INT(16) , 2) GRF; DECLARE_REGISTER(UINT(36)) ACR; // debugging names and registers file structure MEMORY(LDM, "Acc LDM"); MEMORY(ТМ, "Acc TM"); REGFILE_BEGIN(GRF, "General Registers") REGISTER(O, "GRO"); REGISTER(1, "GR1"); REGFILE_END() 2.2.2. Описание поведения К семантике поведения акселератора относятся следующие элементы модели тА : множество ресурсов RÁ, функция ресурсов г1. множество операций ' V 1, множество дескрипторов команд Ia и функция декодирования с/'1 (вместе с СА). 2.2.2.1. Операции Для задания операций из 1I' 1 используется язык C++. Ячейки памяти акселератора доступны в качестве глобальных переменных (регистровые файлы и памяти в виде массивов). Для удобства описания могут объявляться собственные локальные переменные. Также могут быть использованы возможности специальной библиотеки (например, N-битные типы данных INT<N>, UINT<N>, типы данных с фиксированной точкой FIXED<I,F>, операции битовых манипуляций и т.п.). Используемые в операции ресурсы обозначаются в виде вызова функции UseResources (resources) (тем самым задается функция гА). В существующей реализации список используемых в данной операции ресурсов передаются в виде битовой строки, где каждый ресурс соответствует определенному биту. Множество ресурсов RÁ задается в виде перечисления (enum) со значениями элементов по степеням двойки: enum Resources {MAC_ADDER=1, MAC_MULTIPLIER=2, ALU_ADDER=4}; Пример 1. Операция по сложению двух 36-ти разрядных чисел: void ADD_36_36(INT<36>& res, INT<36> a, INT<36> b) { UseResources (MAC ADDER) ; res = a + b; } Пример 2. Операция по перемножению двух 16-ти разрядных знаковых чисел: void SMUL_16_16(INT<32>& res, INT<16> a, INT<16> b) { UseResources () ; res = a * b; } Заданная на C++ операция может быть оформлена в виде отдельной функции (см. примеры выше) или встраиваться непосредственно в тело функции поведения команды (см. примеры в 2.2.2.2). 2.2.22. Дескрипторы команд Дескрипторы команд акселератора из / ' задаются соответствующими функциями поведения команд. Функция поведения может принимать аргументы в виде параметров инструкции pt. Тем самым одна функция поведения может описывать набор дескрипторов (один дескриптор соответствует одному конкретному набору значений параметров). Тело функции поведения может описываться на языке C++. Отображение в операции для соответствующих значений состояния команды t неявно задается путем использования специальной функции FinishCycle (). Вызовы данной функции отделяют операции внутри функции поведения, относящиеся к последовательным тактам исполнения (значениям параметра t дескриптора команды). Для описания динамического характера выбора операций в зависимости от состояния акселератора (аргумент дескриптора s) в описании функции поведения команды допускается использование управляющих конструкций языка С, в частности циклов и ветвлений (см. пример 3 ниже). Вызов функции FinishCycle () означает окончание всех операций для текущего такта команды и соответствует управляющему действию next. Возврат из функции поведения команды соответствует управляющему действию end. Использо-вание такого решения позволяет эффективно описывать дескрипторы команд, тем самым определяя потактовое поведение команд акселератора. Пример 1. Однотактовая команда перемещения между регистрами, содержащая единственную операцию, задаваемую конструкцией GRF [ greg] = LRF[lreg]: ACC_FUNCTION Move_LREG_GREG(INT<4> lreg, INT<4> greg) { GRF[greg] = LRF[lreg]; FinishCycle ( ); } Пример 2. Двухтактовая команда перемножения и аккумуляции результата. На первом такте происходит перемножение операндов (операция SMUL1616 - см. пример 2 в 2.2.2.1), на втором - аккумуляция результата (операция ADD 36 36 - см. пример 1 в 2.2.2.1): ACC_FUNСТION MAC_LREG_GREG(INT<4> grs, INT<4> grt) { SMUL 16 16 (mulres, GRF[grs] , GRF[grt] ) ; FinishCycle(); ADD_36_36 (ACC, ACC, mulres) ; FinishCycle(); Заметим, что две выдачи подряд этой команды процессором приведут к ситуации, когда одновременно будут исполняться две различные стадии этой функции (стадия умножения второй команды и стадия сложения первой команды). Такой эффект может быть использован для моделирования конвейера акселератора. Пример 3. Команда свертки векторов, расположенных в памятях DM0 и ТМО. Длительность команды зависит от данных (длина векторов задается регистром LOOPREG). Заметим, что в теле цикла за один такт выполняются несколько операций, использующих непересекающиеся ресурсы. Для синхронизации с процессором используется механизм прерывания: ACC_FUNСТION CONV_ACC_DMO_TMO(INT<4> dreg, INT<4> treg) { SMUL 16 16 (mulres, DM0[AR[dreg]++], TMO[AR[treg]++] ) ; FinishCycle() ; while (LOOPREOO ) { ADD_36_36 (ACC, ACC, mulres) ; SMUL 16 16 (mulres, DM0[AR[dreg]++], TMO[AR[dreg]++]); LOOPREG FinishCycle(); } ADD_36_36 (ACC, ACC, mulres) ; InterruptProcessor(); FinishCycle(); } 2.2.2.3. Функция декодирования Функция декодирования dA задается описанием множества пар из формата машинного слова команды и ссылки на функцию поведения команды: INSTRUCTION(<format string>, <invoker name>); Формат машинного слова команды задается строкой в следующем алфавите: 1. Битовые символы: ‘0’ и ‘Г 2. Параметрические символы: ‘ A-Z’ и ‘a-z’ 3. Групповой символ: ‘*’ 4. Разделительный символ: Символы из пунктов 1-3 называются значимыми символами. Заметим, что число значимых символов в строке формата команды должно быть равно разрядности машинного слова в системе. Непрерывная цепочка параметрических символов задает операнд. Декодер акселератора выделит указанные биты и передаст полученное значение в функцию поведения команды в виде параметра pi. Различные операнды разделяются групповым или разделительным символом. Операнды нумеруются в порядке справа налево. Битовые символы задают фиксированные значения в соответствующих позициях машинного слова. На месте параметрических и групповых символов в машинном коде команды может быть любое битовое значение. Разделительные символы используются для косметических целей, а также для отделения подряд идущих операндов. Пример: INSTRUCTION("11-**-0 00 0-00 00-0 001-LREG-GREG" , Move_LREG_GREG); Функция поведения MoveLREG_GREG (см. пример 1 в 2.2.2.1) имеет два параметра по 4 бита каяедый (LREG [ 4 ; 7 ] и GREG [ 0 ; 3 ] ). Биты [20;21] могут принимать любые значения для данной команды (в данном примере эти биты относятся к коду акселератора и используются командой запуска акселератора основного процессора). Остальные биты фиксированы и составляют КОП инструкции аскелератора. Заметим, что совокупность всех строк форматов машинного слова задает множество допустимых кодов инструкций данного акселератора ( СА в 2.1.2). Число управляющих слотов Ns задается директивой SLOTS ( <NS>). 2.3. Ассемблерный синтаксис команд акселератора Отдельная секция файла описания модели акселератора отвечает за определение синтаксиса ассемблера для системы команд этого акселератора. Более точно, эта секция определяет синтаксис для подмножества системы команд основного процессора, соответствующего командам запуска инструкций этого акселератора (см. 2.1.3.1). Это полезно для адекватного отра-жения на уровне ассемблера соответствующей семантики команд, так как одни и те же (в смысле машинных кодов) команды основного процессора (для запуска акселераторов) могут иметь разную семантику, в зависимости от конкретной конфигурации акселераторов в системе, специфичной для каждо го заказчика. В дополнение к определению семантики команд акселераторов (см. 2.2), возможность настраивать синтаксис для этих команд является важной функциональностью рассматриваемой системы, позволяющей легко получать готовую для производственного использования кросс-систему, адаптированную для специфичной конфигурации «процессор + акселераторы пользователя». Описание ассемблерного синтаксиса системы команд состоит из трех секций: 1. Секция типов операндов и псевдонимов 2. Секция команд 3. Секция ограничений (constraints) Детальное рассмотрение средств описания синтаксиса команд выходит за рамки данной статьи. Ниже приводится только краткий обзор основных возможностей. 2.3.1. Отображение ассемблерных команд в машинное слово Общий шаблон допустимого ассемблерного синтаксиса для команд акселератора задается в виде: command ::= mnemonic [parameter {, parameter}*] {|| mnemonic [parameter {, parameter}*]}* mnemonic ::= const string parameter ::= operand {[const string] [operand]}* operand ::= const string const string ::= любой текст без запятых и пробелов Примеры возможных команд: DMOVE ACRl.h, DM0(DAO—), ACR1.L, ТМ0(ТА0++) MOVE GRA, DM1(TAO+25) || ADD GR3, ACR2.H На языке ассемблера команда состоит из мнемоники (нескольких мнемоник для параллельных команд) и набора параметров, разделенных запятой. Каждый параметр может содержать несколько частей - операндов, принадлежащих к каким-либо из описанных типов. В рамках одного параметра операнды должны отделяться непустыми строками константных символов. Комбинация мнемоник ассемблерного синтаксиса отображается в поле КОП соответс-твующей команды. Операнды (operand) отображаются на поля-операнды машинного слова. Возможно задание отображения на не непрерывные поля (когда биты поля перемежаются битами других полей). Пример: .types grn [grO:0] [grl:l] [gr2:2] [gr3:3] const6b $ -32 31 .mnemonics MOVE {grn#0;2},{const6b#2 ; 4#8 ; 2 } % 0xA8C0 OxFCCO Описание задает команду MOVE с двумя операндами. Первый операнд типа gm является регистром общего назначения, код регистра размещается в 2х битах начиная с 0-го. Второй операнд является константой в диапазоне [-32; 77 31] и располагается в машинном слове в двух частях: в 4х битах, начиная со 2-го, и 2х битах, начиная с 8-го. КОП равен 1010-10ХХ-11ХХ-ХХХХ. 2.3.2. Ограничения 2.3.2.1. На отдельные операнды Ограничения на отдельные операнды определяются соответствующим типом, к которому принадлежит операнд. Однако для наглядной генерации ошибок можно задать более широкий тип для операнда и воспользоваться механизмом общих ограничений (см. 2.3.2.2) для выделения допустимых значений. 2.3.2.2. На взаимосвязь операндов команды Ограничения на взаимосвязь операндов команды задаются в виде набора логических высказываний относительно сравнений арифметических выражений, которые могут содержать значения любых использованных в команде операндов. Считается, что ограничения выполнены, если все логические высказывания для данной инструкции принимают значение «истина». Выражения ограничений поддерживают следующие операции: Логические операции &&, ||, ! Операции сравнения <, >, <=, >=, ==, о Арифметические операции +, *, /, % Битовые операции 1, &,л, ~ В выражениях могут быть использованы числовые константы и, собственно, ссылки на операнды. Если несколько операндов имеют одинаковый тип, то следует использовать псевдонимы типов для различения операндов в выражениях ограничений. Пример. Операнды 1 и 2 не должны быть равны: ADD {GRs # 8;4}, {GRt#4;4} % 0x796000 0xf9f000 (GRs <> GRt) % "Operands must be different for ADD" Заметим, что с помощью описанного механизма также можно задавать ограничения на отдельные операнды. Таким образом, возможны две стратегии работы с ограничениями на значения операндов: с одной стороны можно создать систему общих типов и затем сужать множества значений с помощью логических высказываний, а с другой - работать с большим количеством специфических типов. В первом случае - можно достичь более конкретных сообщений об ошибках в операндах инструкции, во втором -упрощается описание системы команд. Пользователь может выбрать любую стратегию. 2.3.2.3. На комбинации команд Каждо й команде можно назначить некоторый набор свойств и задать для них значения и области активации. В качестве значения свойства может выступать либо константа, либо значение одного из операндов команды. Область активации задает диапазон соседних команд, на котором данное свойство активно. Область активации по умолчанию [1;1] затрагивает только текущую команду. Механизм описания свойств (дополненный предикатами совместимости - см. ниже) фактически является модифицированным описанием таблиц использования ресурсов (reservation tables). Пример: MAC {acr#14;1},{grs#4;4},{grt#0;4} % 0x6c2000 Oxffb8 00 [read_grn:grs, read_grn:grt, write_acr:acr:2;2] Данная команда обладает следующими свойствами: ■ read gm - двойное свойство со значениями равными значениям операндов grs и grt. Область активации по умолчанию затрагивает только текущую команду (здесь означает, что значения регистров, заданных операндами grs и grt, читаются на первом такте). ■ write acr - значение свойства равно значению операнда асг. Область активации [2;2] затрагивает следующую команду (здесь означает, что значение асг будет записано на втором такте). На механизме описания свойств базируется способ задания ограничений на использование ресурсов. Задается список предикатов совместимости свойств. Предикат совместимости свойств задает в квадратных скобках набор из пар свойств (пары разделяются запятыми, свойства в паре знаком =). Предикат истинен для пары команд, когда выполняются следующие условия: первая команда обладает всеми свойствами из левых частей пар, вторая обладает всеми свойствами из правых частей пар; при этом для каждой пары значения свойств совпадают на пересечении их областей активации. Предикаты совместимости оцениваются ассемблером для всех пар команд при ассемблировании программы, таким образом обнаруживаются конфликтующие команды. Заметим, что оценки работают гарантированно корректно только на линейных участках. Пример: [write acr=read acr] % warning: "WAR conflict for ACRs " Данный предикат будет верен, если у пары команд значение свойства writе_асг первой команды совпадет со значением свойства read_acr второй команды на пересечении областей активации этих свойств. В данном примере это отражает конфликт по данным (по аккумуляторным регистрам) типа WRITE AFTER READ. Зарезервировано специальное свойство «апу», которым по умолчанию обладает любая инструкция. [апу=Х] дает истинный предикат, если вторая инструкция обладает свойством X (независимо от его значения). 2.3.3. Сообщения об ошибках 2.3.3.1. Ошибки симуляции Число Ns (см. 2.1.1.2) определяет максимальное количество параллельных команд в акселераторе. Симулятор генерирует ошибку, если процессор пытается выдать команду, когда нет свободных слотов. Другой механизм обнаружения ошибок выполнения основывается на использовании ресурсов (см. 2.1.2). Если в пределах одного такта один и тот же ресурс используется разными параллельно выполняющимися командами, симулятор генерирует ошибку выполнения. Для обеспечения CREW модели доступа к данным симулятор обнаруживает запись разными процессами в одну и ту же ячейку памяти и генерирует ошибку выполнения. 2.3.3.2. Ошибки ассемблирования Для ограничений 2.3.2.2 и 2.3.2.3 пользователь может задавать специализированный текст сообщений об ошибке и критичность ошибки (warning или error). Существует возможность задавать как индивидуальные тексты для каждо го ограничения, так и ссылаться на общую таблицу сообщений. Данный подход предоставляет пользователю возможность точной настройки диагностики ошибок ассемблирования с детализированными описаниями, что является необходимым условием промышленной эксплуатации кросс-системы. 3. Динамическая настройка кросс-системы В данной главе приводится краткий обзор нашей технологии динамической настройки кросс-системы для работы с моделями акселераторов, заданных в соответствии с 2.2 и 2.3 в виде файлов описания акселераторов. 3.1. Конфигурация системы Под процессом конфигурации системы подразумевается определение конкретного набора акселераторов (типа и номера каждого акселератора). Тип акселератора (конкретная модель) определяется файлом спецификации на языке ISE. Интегрированная среда позволяет задать упорядоченный список акселераторов (файлов описания акселераторов), который и определяет конфигурацию системы, используемую для настройки соответствующих компонентов кросс-инструментария. В рамках одной сессии интегрированной среды пользователь может многократно менять как конфигурацию системы, так и сами файлы описания акселе-раторов (и, конечно же, прикладную программу). Однако изменение конфигу-рации невозможно в режиме отладки, когда работает симулятор. Для смены конфигурации сессия отладки должна быть остановлена. Для редактирования файлов описания акселераторов может быть использован 81 визуальный front-end, который поддерживает средства анализа и верификации спецификаций (напри-мер, обнаружение конфликтующих машинных кодов для разных команд). 3.2. Настройка симулятора Для настройки симулятора используется информация из файла описания акселератора, соответствующая элементам, описанным в 2.2. В существующей реализации для настройки симулятора используется два альтернативных подхода: • Компиляция файла описания акселератора внешним компилятором C++ • Интерпретация файла описания во время работы (run-time) В первом случае файл описания акселератора транслируется внешним компилятором в динамическую библиотеку DLL. Заметим, что в этом случае синтак-сис, описанный в 2.2, трактуется как макросы, определения переменных (2.2.1) и функции (2.2.2) C++. Функция-декодер задается таблицей соответствия шаблонов машинных команд и указателей на функции команд (2.2.2.3). Инфор-мация о синтаксисе команд (2.3) не используется симулятором и для компиля-тора в этом случае представляется в виде строки инициализации специальной глобальной переменной для использования ассемблером и дисассемблером. Программный интерфейс (API) этой библиотеки DLL содержит набор функций для извлечения информации об акселераторе. Память акселератора симулируется в виде переменных и массивов в адресном пространстве DLL. Функции поведения команд акселератора (включая операции) компилируются в исполняемый код хост-машины. Симулятор основного процессора обращается к соответствующим функциям DLL для выдачи команд акселе-ратора и инициировании очередного такта (тактовый генератор находится в отладчике). Для синхронизации потактового выполнения команд основного процессора и всех акселераторов используется модель нитей с ручным переключением контекста. Такие возможности предоставляются в операционной системе Windows в виде примитивов Fibers. Для платформы UNIX используется библиотека QuickThreads (David Keppel, 1993). Директива FinishCycle ( ) в этом случае вызывает явное переключение нитей (fibers). В случае отсутствия внешнего компилятора C++, используется другой подход, когда функции поведения команд интерпретируются внутренней виртуальной машиной во время симуляции. Однако в этом случае существует ряд ограни-чений на использование конструкций и типов языка C++ при описании модели акселератора, так как не все возможности поддерживаются интерпретатором. 3.3. Настройка ассемблера/дисассемблера Для обеспечения динамической настройки ассемблера на новые команды акселераторов был разработан «универсальный» ассемблер, интерпретирующий описание синтаксиса системы команд и отображения в машинные коды, заданное в соответствии с 2.3, в процессе ассемблирования входной программы. Заметим, что часть системы команд основного процессора, не относящаяся к командам запуска акселераторов, также задается в виде 2.3. Таким образом, кроме собственно текста прикладной программы, входной информацией для ассемблера является набор файлов описания для системы команд ядра процессора и всех акселераторов системы. Объединение этих описаний задает общий ассемблерный синтаксис всех команд системы «процессор + акселераторы». В конкретной реализации, информация о синтаксисе извлекается ассемблером либо из указанных в параметрах командной строки библиотек DLL или непосредственно из файлов описания акселераторов. При этом описание системы команд ядра основного процессора зашито в самом ассемблере, так как она не изменяется пользователем. Заметим, что в текущей версии динамически настраиваемым является только синтаксис отдельных команд. Общий синтаксис ассемблерного файла фиксирован: • Секции • Объявление переменных • Выражения • Конструкции для макропроцессора • Отладочная информация С-компилятора Дисассемблер извлекает информацию о синтаксисе команд из набора файлов описания также динамически во время своей работы (in run-time). 3.4. Настройка отладчика Под настройкой отладчика подразумевается настройка соответствующих окон для отображения состояния памяти акселераторов во время симуляции, включая разбиение на именованные области. С помощью отладчика пользователь также может вручную изменять значения определенных ячеек. Во время старта отладочной сессии отладчик считывает информацию о структуре памяти акселераторов (см. 2.2.1) из соответствующих библиотек DLL или непосредственно из файлов описания акселераторов. Также для настройки подсветки синтаксиса ассемблерных команд в редакторе используется инфор-мация из синтаксической части (см. 2.3). Оттуда же берет информацию и один из профилировщиков (а именно, профилировщик покрытия системы команд). 4. Смежные работы Для спецификации аппаратуры на низком уровне используются языки HDL (Hardware Description Languages), наиболее известными из которых являются Verilog [6] и VHDL [7]. Задачей этих языков является создание спецификации, пригодной для синтеза реальной аппаратуры. Поэтому, задание аппаратуры на данном уровне абстракции является трудоемким и непригодным для быстрого проведения исследования альтернатив дизайна, далее DSE (Design Space Exploration). Также автоматическое построение кросс-системы затруднительно на основании описания HDL, так как информация о системе команд не определяется явно (см. [1]). Интересный подход для моделирования аппаратуры разрабатывается в рамках программы Open SystemC Initiative [8], первоначально представленной в 2000 году. В настоящее время все активности по SystemC спонсируются и управляются комитетом из индустриальных компаний: ARM, Cadence, CoWare, Fujitsu, Mentor, Motorola, NEC, Sony, ST, Synopsys. SystemC это библиотека C++ классов, которая упрощает создание поведенческих моделей аппаратных систем за счет предоставления набора макросов и классов, реализующих элементы аналогичные конструкциям HDL. С помощью этих конструкций (см. [9]) возможно структурное описание системы, используя понятия модулей, процессов, портов, сигналов, интерфейсов, событий и т.п. Библиотека также предоставляет набор типов, удобных для моделирования аппаратных элементов, таких как битовые строки и числа с фиксированной точкой. Однако модель системы на SystemC предназначена только для симуляции и последующего синтеза аппаратуры, система команд явно не выделяется и построение полной кросс-системы на основании модели на SystemC затруднительно (см. [5]). В этом смысле SystemC относится скорее к классу HDL языков, при этом существуют автоматические конвертеры из Verilog и VHDL в SystemC ([10] и [11]). Скорость симуляции моделей SystemC невелика ввиду слишком низкого уровня описания деталей аппаратуры, несущественных для кросс-системы. Однако заметим, что для описания поведения отдельных операций аппаратуры примитивы SystemC очень удобны, аналогичные конструкции предоставляются и в рассматриваемой работе для описания операций и команд (см. 0). В частности предоставляются типы данных, аналогичные SystemC; также синхронизация меяеду командами аналогична синхронизации между процессами SystemC (FinishCycle () аналогична функции wait() в SystemC). Для решения задачи автоматической генерации компонентов кросс системы предназначены языки класса ADL (Architecture Description Languages). Дополнительная информация и полный обзор языков ADL может быть найден в [1] - [5]. Здесь приведем только наиболее известные решения. Одним из первых языков ADL был nML [12], изначально разработанный в Техническом Университете Берлина, Германия (1991). nML использовался в качестве способа описания аппаратуры для симулятора SIGH/SIM и компилятора СВС (с языка ALDiSP). В nML система команд процессора описывается с помощью атрибутных грамматик. Атрибуты включают в себя поведение (action), ассемблерный синтаксис (syntax) и отображение в машинные коды (image). Оригинальный nML не содержит механизмов описания многотактовых команд. Однако nML получил дальнейшее развитие в бельгийском научно-исследовательском центре микроэлектроники IMEC, где в рамках дочерней компании Target Compiler Technologies была создана коммерческая среда разработки [13]-[14], ориентированная на DSP архитектуры (1995). В эту среду входят компилятор CHESS (с языка С), симулятор CHECKERS, ассемблер, дисассемблер и линкер. Также поддерживается синтез VHDL описания. В рамках этой коммерческой среды компания Target Compiler Technologies модифицировала nML для поддержки более сложной аппаратуры (в частности введены механизмы явного описания конвейера), хотя из маркетинговых заявлений компании (технические спецификации недоступны) до конца не ясно, какие именно средства описания ILP поддерживаются. Также nML поддерживает только команды фиксированной длительности и производительность симулятора, опубликованная в [14], невысока. Последователем nML стал язык Sim-nML [15], работы над которым ведутся с 1998 года в Индийском Технологическом Институте (Indian Institute of Technology Kanpur) при поддержке компании Cadence. Главным принципиальным нововведением стал дополнительный атрибут использования ресурсов (uses) в грамматике описания команд. Это позволяет описывать использование ресурсов и, тем самым, обнаруживать конфликты между командами. В рамках проекта Sim-nML были разработаны кодогенератор для компилятора, симулятор, ассемблер и дисассемблер. К сожалению, отсутствует интегрированная среда разработки и отладки. Язык ISDL был разработан в университете МП, США [16] и представлен на конференции по автоматизированному дизайну DAC [17] в 1997 году. Основной специализацией ISDL является описание VLIW архитектур. Изначально задумывалась реализация компилятора, ассемблера и симулятора, а также генератора Verilog описания. Аналогично nML, ISDL главным образом описывает систему команд процессора, включающую в себя семантику поведения, синтаксис ассемблера, машинные коды, а также описание ресурсных конфликтов, используя атрибутную грамматику. К важным достоинствам языка можно отнести возможность точно специфицировать задержки и конфликтные ситуации для ILP в виде логических правил, хотя явное описание конвейера отсутствует. Несмотря на довольно продуманный язык, к сожалению, отсутствуют в доступном виде реальные утилиты, поддерживающие его. Инициаторы проекта ограничились только реализацией ассемблера и некоторых модулей симулятора и кодогенератора для компилятора в качестве диссертационных работ MIT. Язык EXPRESSION [18]-[19] разработан в Университете Калифорнии (University of California, Irvine, США), впервые был представлен на конференции DATE в 1999 году. Этот язык поддерживает широкий класс встроенных систем с ILP и иерархиями памяти от RISC, DSP, ASIP до VLIW. 85 EXPRESSION содержит интегрированное описание структуры и поведения подсистемы процессор-память. Спецификация на EXPRESSION состоит из шести секций (первые три отвечают за поведение, последние три за структуру): • Спецификация операций (набор атомарных команд с кодами, описанием параметров и семантики (поведения)). • Описание формата команды (команда состоит из ячеек, ответственных за определенный функциональный модуль, которые могут заполняться атомарными операциями для параллельного выполнения). • Отображение общих операций компилятора на машинные операции, описанные в первой секции. Данное описание используется для кодогенератора компилятора. • Описание компонент (функциональные устройства, шины, порты и т.п.). • Описание конвейера и связей компонентов. • Описание иерархии памяти (регистровая память, кэш, SRAM, DRAM). Из описания EXPRESSION автоматически генерируются компилятор EXPRESS и симулятор SYMPRESS. К недостаткам решения на основе EXPRESSION следует отнести невысокую скорость симуляции и относительную трудоемкость описания (из-за наличия детальной структурной составляющей). В этом смысле EXPRESSION стоит между чистыми поведенческими ADL решениями (типа nML) и структурными описаниями HDL уровня. Язык LISA [21]-[22] разрабатывался в университете RWTH Aachen (Германия) изначально в качестве средства описания аппаратуры для генерации симуляторов. Первые результаты работ по проекту LISA были опубликованы в 1996 году. Первоначальной целевой архитектурой были DSP процессоры. К ключевым характеристикам LISA можно отнести подробное описание конвейера на уровне операций с возможностью задания зависимостей и блокировок. Конвейерные конфликты задаются явно. Каяедая команда задается в виде набора операций, которые определяются как регистровые пересылки за время одного кванта синхронизации. Описание LISA состоит из двух основных частей: спецификации ресурсов и описания операций. Описание операций в свою очередь содержит следующие секции: • DECLARE (определение объектов и групп через другие объекты и операции - фактически правила грамматики). • CODING (описание бинарного кодирования операции). • SYNTAX (описание ассемблерного синтаксиса и параметров). • BEHAVIOR и EXPRESSION (описание поведения операции в виде кода на языке C/C++). • ACTIVATION (описание задержек (timings) и поведения конвейера). К сожалению, отсутствует полная публичная спецификация языка LISA, вся информация взята из различных статей. Согласно [20], из всех представленных подходов только система на основе языка EXPRESSION предоставляет средства для описания акселераторов. Однако, она ориентирована только на проведение фазы DSE, в ней отсутствуют такие производственные компоненты как ассемблер, дисассемблер, отладчик. Кроме того, ни одна из систем не поддерживает динамическую настройку компонентов, так как все компоненты создаются специальными генераторами кода в виде исходного кода на C/C++ и необходимо использование внешних компиляторов для получения готовой кросс системы. Настройка обработки ошибок в ассемблере также не поддерживается указанными языками. 5. Заключение В данной статье представлена технология динамической настройки кросссистемы для поддержки ассемблирования, симуляции и отладки программ, содержащих команды, неизвестные на этапе построения основного инструмен-тария. Семантика и синтаксис этих команд определяются конкретными акселе-раторами, создаваемыми пользователями при построении специфической конфигурации системы «процессор + акселераторы» и неизвестными производителю основного процессора (и соответственно кросс-системы). Для решения этой задачи была разработана абстрактная модель поддерживаемых акселераторов и интерфейса с процессором, охватывающая широкий спектр возможной аппаратуры. Предложенный язык спецификации ISE позволяет пользователям описывать спецификации конкретных акселераторов в рамках этой абстрактной модели. Созданные файлы спецификаций регистрируются в настройках интегрированной среды при описании конфигурации системы (см. 3.1). При этом компоненты кроссинструментария настраиваются в соответствии с этими спецификациями динамически (in-run-time). В результате прикладные программисты получают возможность писать и отлаживать программы с использованием новых команд. Спецификации и конфигурация акселераторов в системе могут многократно меняться в рамках одного сеанса интегрированной среды, в том числе с помощью визуальных средств редактирования, анализа и верификации. На основе описанной технологии в рамках коммерческого проекта в ИСП РАН была реализована настраиваемая кросс-система для DSP процессора заказчика (поддерживающего акселераторы). Авторам известно, что с помощью этой сис-темы пользователями были созданы рабочие модели реальных акселераторов: a. Быстрого преобразования Фурье b. Алгоритмов эхо подавления c. Операций с комплексными числами d. Операций кодирования видео e. Операций цифровой фильтрации звука Пиковая производительность симулятора центрального процессора (на хост-машине РШ-lOOOMHz) в рассматриваемой системе составляет порядка 10 миллионов тактов в секунду. При использовании конфигурации с одним акселератором (эхо подавления) производительность составила порядка 1 миллиона тактов в секунду (при этом симулируются процессор и акселератор, работающие параллельно), что обусловлено большими потерями на синхронизацию процессов выполнения процессора и акселератора. Дальнейшие наши работы в этой области направлены на расширение языка ISE и соответствующих утилит для поддержки моделирования полной системы, включая описание центрального процессора. Отдельное внимание уделяется увеличению производительности симулятора за счет использования JIT технологий и использования знаний о конкретной программе. Также предполагается расширить возможности системы для настройки компилятора с языка высокого уровня для генерации кода с учетом наличия акселераторов (в настоящее время команды акселератора на уровне языка С используются вручную в виде ассемблерных вставок). ]]></text>
</doc>
