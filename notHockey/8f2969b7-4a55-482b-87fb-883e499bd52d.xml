<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/simulyatory-gpss-world-i-actor-pilgrim-ekonomika-i-massovoe-obsluzhivanie]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Емельянов Александр Анатольевич]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Симуляторы gpss World и actor Pilgrim: экономика и массовое обслуживание]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[Система имитационного моделирования GPSS появилась более 40 лет назад без предварительного планирования и при неожиданно незначительных усилиях, потому что в этом была неотложная необходимость, не оставившая времени на изучение и создание альтернатив. Она быстро прижилась и стала «гранд-дамой» в сообществе имитационного моделирования. Но в экономике и других предметных областях появились новые задачи, на которые идеология GPSS не была рассчитана. Данная статья предназначена для тех, кто знаком с GPSS World и хотел бы расширить свои аналитические возможности с помощью Actor Pilgrim.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Система имитационного моделирования GPSS появилась более 40 лет назад без предварительного планирования и при неожиданно незначительных усилиях, потому что в этом была неотложная необходимость, не оставившая времени на изучение и создание альтернатив. Она быстро прижилась и стала «<гранд-дамой» в сообществе имитационного моделирования. Но в экономике и других предметных областях появились новые задачи, на которые идеология GPSS не была рассчитана. Данная статья предназначена для тех, кто знаком с GPSS World и хотел бы расширить свои аналитические возможности с помощью Actor Pilgrim. Имитационное моделирование контролируемого процесса или управляемого объекта — это высокоуровневая информационная технология, которая обеспечивает два вида действий: 1) создание или модификацию имитационной модели; 2) получение численных результатов с помощью созданной модели и их интерпретацию. Имитационное моделирование экономических процессов обычно применяется в следующих случаях: • для управления сложным бизнес-процессом, когда имитационная модель управляемого экономического объекта используется в качестве инструментального средства в контуре адаптивной системы управления, создаваемой на основе информационных технологий; • при проведении экспериментов с дискретно-непрерывными моделями сложных экономических объектов в ускоренном масштабе времени для получения и отслеживания их динамики в экстренных ситуациях, связанных с рисками, натурное моделирование которых нежелательно или невозможно. Первая рабочая программа под названием GPSS (General Purpose Systems Simulator) была создана Джеффри Гордоном в 1961 году для моделирования технических систем, систем массового обслуживания. В 1967 году появилась первая доступная для широкого использования система имитационного моделирования GPSS/360. Сейчас широко используется версия GPSS World. В GPSS-моделях основной динамической единицей стал транзакт (автоматически реализуется в модели на основе структуры данных). У этой системы есть два неоспоримых достоинства: • GPSS хороша тем, что существует уже на протяжении более 40 лет и получила широкое распространение; • за период эксплуатации различных версий GPSS накоплено хорошее методическое обеспечение. В последнее время для моделирования экономических процессов все чаще выбирают систему имитационного моделирования Pilgrim, которая появилась 20 лет назад. В настоящее время разработана версия Actor Pilgrim, где основной динамической единицей является актор, который автоматически реализуется в виде агентской программы. Ik3(9) 2007 В связи с наличием на рынке программных средств моделирующих пакетов и при свободном распространении их студенческих версий иногда хорошие специалисты, имеющие длительный опыт моделирования технических систем или систем массового обслуживания на GPSS, задаются вопросом зачем существуют несколько моделирующих систем. Неумение ответить на него обычно приводит к одному из двух негативных результатов. Во-первых, попытки найти возможность использования GPSS в тех случаях, на которые создатели этой системы не рассчитывали, приводят к серьезным методическим промахам и, как следствие, к значительным численным погрешностям. Обычно эти случаи связаны с финансовой или пространственной динамикой, с динамическим использованием геокоординат и геоинформации. Во-вторых, незнание экономической теории, бухгалтерского и финансового учета приводит к типовым грубым ошибкам. Са-sg мые распространенные связаны с попытка! ми отождествления путей транзактов и фи-Ц нансовых проводок, в результате чего по-§ грешности в оценках денежных средств на 2 конкретные моменты времени могут быть | огромными — в разы. 8 Тем не менее, у GPSS есть своя конкрет-s ная ниша в области экономики. Это типо-g вые задачи управления запасами, массовое ! обслуживание в сфере услуг, некоторые g задачи управления. GPSS поистине уни-^ кальная и замечательная система. В сере-■I дине 70-х годов прошедшего столетия та-£ кие известные зарубежные исследователи, S как Т. Нейлор и Р.Е. Шеннон отмечали эту ^ систему как одну из наиболее удачных, про-зз водя анализ многих пакетов моделирующих § программ. Причем другие исследованные 23 ими пакеты в настоящее время уже не ис-§з пользуются из-за морального износа, сме-¡^ ны hardware, software и ряда других причин, Sr а GPSS активно применяется. ! Цель данной статьи заключается в том, чтобы дать некоторый сравнительный анализ идеологий двух систем, используемых в настоящее время: GPSS World и Actor Pil-grim\ Начнем с определений Имитационное моделирование (simulation) — распространенная разновидность аналогового моделирования, реализуемого с помощью набора математических инструментальных средств, специальных имитирующих программных средств и технологий программирования, позволяющих реализовать в компьютере процессы-аналоги, провести целенаправленное исследование структуры и функций реальной сложной системы в режиме ее имитации в памяти компьютера, выполнить оптимизацию некоторых параметров системы. Следует отметить, что любое моделирование имеет в своей методологической основе элементы имитации реальности с помощью какой-либо символики (математики) или аналогов. Поэтому иногда в российских вузах и научных организациях имитационным моделированием называют целенаправленные серии многовариантных расчетов, выполняемых на компьютере с применением математических методов: математических формул, дифференциальных уравнений, методов линейного программирования и иных, которые по сути уже являются моделями. В этих случаях компьютер используется только как быстродействующее вычислительное устройство — калькулятор с памятью. С точки зрения информационных технологий такое моделирование (modeling) — обычные вычисления, выполняемые с помощью расчетных программ или табличного процессора Excel. Но имитационное моделирование представляет собой особую компьютерную работу, которую невозможно заменить или представить с помощью математических 1 Автор имеет на это некоторое право, поскольку активно использовал различные версии GPSS с 1978 года, является создателем системы Pilgrim, в разработке всех версий которой принимал непосредственное участие. 74 №>3(9)2007 методов или расчетов. Современный компьютер, на котором можно выполнять такую работу, является цифровой вычислительной машиной. Однако своими научными корнями современное имитационное моделирование связано со специальной «веткой» вычислительной техники, неизвестной значительной части компьютерных пользователей, — с аналоговыми вычислительными машинами — электронными устройствами, используемыми в составе измерительных или управляющих приборов в сложных автоматических системах (например, в автопилотах самолетов или космических кораблей). Имитационной моделью называется специальный программный комплекс, который позволяет имитировать деятельность какого-либо сложного объекта. Он запускает в компьютере параллельные взаимодействующие вычислительные процессы, которые являются по своим временным параметрам (с точностью до масштабов времени и пространства) аналогами исследуемых. В странах, занимающих лидирующее положение в создании новых компьютерных систем и технологий, научное направление Computer Science использует именно такую трактовку имитационного моделирования. Имитационную модель нужно создавать. Для этого необходимо специальное программное обеспечение — система моделирования (simulation system). Специфика такой системы определяется технологией работы, набором языковых средств, сервисных программ и приемов моделирования. Система моделирования может быть интерпретирующего или компилирующего типа. Например, GPSS — это система интерпретирующего типа, а Pilgrim — компилирующего. Имитационная модель должна отражать большое число параметров, логику и закономерности поведения моделируемого объекта во времени (временная динамика) и пространстве (пространственная динами- ка). Моделирование объектов экономики § связано с понятием финансовой динамики * объекта. | Виртуальным временем называется ре- ¡4 альное время, которое имитируется при вы- < полнении имитационной модели2. Например, моделирующая программа проводит имитацию работы предприятия в течение 1 года, причем выполняется она за 1 с. Здесь 1 год — это виртуальное время, а 1 с — астрономическое. Далее под временем будем понимать именно виртуальное время, не связывая его с астрономическим временем выполнения модели на компьютере. Если же осуществляется связь этих времен, то вводится понятие «масштаб времени». В виртуальном времени автоматически упорядочиваются все события, причем не обязательно пропорционально реальному времени, в котором развивается моделируемый процесс. События при выполнении модели выстроены в нужном порядке, и все статистические данные, полученные в результате ее выполнения, замерены в течение 1 с так, как будто они получены во время натурного эксперимента на предприятии в течение 1 года. Масштаб времени — это число, которое задает длительность моделирования одной единицы модельного времени, пересчитанной в секунды, в секундах астрономического реального времени при выполнении модели. Относительный масштаб времени — это дробь, показывающая сколько единиц модельного времени помещается в одной единице процессорного времени при выполнении модели в компьютере. Можно выделить четыре разновидности масштаба времени. 1. Реальный масштаб времени — вводится значение выбранной единицы измерения модельного времени, выраженное в секундах. Например, если в качестве единицы модельного времени выбран 1 ч, а в качестве масштаба задать число 3600, Иногда используется синоним виртуального времени — модельное время. 75 Ik3(9) 2007 то модель будет выполняться со скоростью реального процесса, а интервалы времени между событиями в модели будут равны интервалам времени между реальными событиями в моделируемом объекте (с точностью до поправок на погрешности при задании исходных данных). Относительный масштаб в этом случае равен 1:1. 2. Максимально ускоренный масштаб времени — задается число 0. В этом случае время моделирования определяется чисто процессорным временем выполнения модели. Например, если в модели произошли 3 события, причем длительность модельного времени между первым и вторым событиями составляет 1 мин, а между вторым и третьим — 24 ч, то в компьютере соответствующие интервалы астрономического времени — это длительность выполнения моделирующих программ, т.е. оба интервала приблизительно равны. Они зависят от используемого процессора электронной вычислительной машины (ЭВМ) и могут измени ряться малыми долями секунды. Это обстоя-| тельство позволяет достигнуть максимально-Ц го быстродействия модели и автоматически § исключать из процесса моделирования не-2 производительные отрезки модельного вре-| мени (например, соответствующие интерва-8 лы ночного времени, когда фирма не рабо-| тает). Относительный масштаб в этом слу-[о чае практически невозможно определить. ! 3. Пропорционально ускоренный мас-§ штаб времени — вводится значение выбран-^ ной единицы измерения модельного времени, выраженное в секундах. Причем это зна-£ чение меньше выбранной единицы. Напри-а мер, если в качестве единицы модельного ^ времени выбран 1 ч, а в качестве масштаба зз задать число 0,1; то модель будет выполнять-§ ся быстрее реального процесса. Причем 1 ч 2? реального процесса будет моделироваться §з в ЭВМ в течение 0,1 с (с учетом погрешно-^ стей), т.е. примерно в 36000 раз быстрее. | Относительный масштаб равен 1:36000. 4. Замедленный масштаб времени — вво-^ дится значение выбранной единицы измерения модельного времени, выраженное в се-76 кундах. Например, если в качестве единицы модельного времени выбран 1 ч, а в качестве масштаба задать число 7200, то модель будет выполняться медленнее реального процесса. Причем 1 ч реального процесса будет моделироваться ЭВМ в течение 2 ч, т.е. примерно в 2 раза медленнее. Относительный масштаб равен 2:1. Замедленный масштаб, как правило, не представляет интереса для проведения исследований с моделями. Однако замедленная работа необходима при исследовании самой системы имитационного моделирования (например, при калибровке общего модельного таймера). Модели на GPSS всегда работают в максимально ускоренном масштабе времени. P/Vgr/m-модели работают в любом масштабе времени (задается либо специальной командой в тексте модели, либо из главного меню управления моделью). Симулятор — это главное программное обеспечение в системе имитационного моделирования или в имитационной модели, которое обеспечивает корректность и точность симуляции моделируемых процессов в виртуальном времени. Модель на языке GPSS не компилируется в машинный код и не является программой в обычном понимании. Она выполняется посредством простого и эффективного интерпретатора, который и является симу-лятором. Но следует понимать, что режим интерпретации замедляет выполнение модели по сравнению с моделью в виде exe-программы, подготовленной компилятором и собранной редактором связей. Pilgrim-модель компилируется и выполняется как exe-программа в WindowsXP в виде обычного приложения Win API. Ее можно встраивать в программные комплексы, в интеллектуальные системы поддержки принятия решений. Зачастую она выполняется на вычислительной установке, где нет системы имитационного моделирования Pilgrim. Поэтому в составе Pilgrim-модели имеется компактный скоростной диспетчер процессов, который и выполняет функции симуляции. Моделирование процессов массового обслуживания Моделирование на GPSS: транзакты и блок-схемы Основной динамической единицей в йРББ-модели является транзакт, который по своим функциям аналогичен заявке или требованию в системе массового обслуживания. С помощью транзактов можно имитировать потоки людей, сообщений в системах телекоммуникаций, задач в вычислительной системе. Транзакт проходит через блоки модели, которые образуют направленный граф, называемый блок-схемой модели. Дуги графа — это допустимые пути передвижения транзактов. Схему модели не следует отождествлять с блок-схемой программы, созданной на алгоритмическом языке. Дело в том, что в отличие от обычной программы модель может иметь неограниченное число транзактов. В такой программе можно выделить только один псевдотранзакт, который представляет собой точку выполнения программы. Транзактная идеология, созданная Дж. Гордоном, оказалась весьма удачной при реа- №>3(9)2007 лизации системы имитационного моделиро- § вания ОРББ с выполнением моделей посред- * ством интерпретатора. Конечно, режим ин- | терпретации замедляет выполнение моде- ¡4 ли, но существенно упрощает алгоритм пла- < нирования виртуального времени. В памяти компьютера транзакт можно представить в виде таблицы с довольно сложной структурой данных. Модель выполняется с помощью программы-интерпретатора, которая, используя указатели (адресную арифметику), передает каждый транзакт от блока к блоку, если условия модельного времени и логические условия эту передачу разрешают. В блоках происходят изменения внутренней информации транзактов и накапливаются статистические данные. У каждого типа блока есть конкретное назначение и особое графическое изображение. Перечень блоков, упоминаемых в данной статье, и их графические обозначения приведены в табл. 1, где в квадратных скобках указаны необязательные позиционные операнды, а в качестве параметра «Имя» подразумевается слово (алфавитно-цифровой Таблица 1 Перечень блоков GPSS Изображение блока Операнд Функциональное назначение операнда 1 A Среднее значение интервала времени ADVANCE А, В [B] 1/2 интервала или функция-модификатор 1 1 A Имя очереди DEPART В la [B] Число, на которое уменьшается длина очереди (по умолчанию равно 1) 1 1 A Имя многоканального обслуживающего устройства типа STORAGE ENTER В [B] Число занимаемых единиц/каналов (по умолчанию равно 1) 1 A Среднее значение интервала времени GENERATE ) B 1/2 интервала или функция-модификатор C Время начальной задержки первого транзакта в, с, dTe] D Число генерируемых транзактов за время моделирования Уровень приоритета 1 E 77 Ив3(9) 2007 Продолжение табл. 1 78 №>3(9)2007 Окончание табл. 1 § Изображение блока Операнд Функциональное назначение операнда [A] Режимы перехода: ^TRANSFER^B*. безусловный - [,] статистический — .xxx параметрический — P функциональный — FN оба — BOTH все — ALL выборочный — PICK одновременный — SIM подпрограммный — SBR [B] Имя блока (параметра, функции) [C] Имя блока (аргумент режимов P и FN) [D] Шаг нумерации в режиме ALL идентификатор), номер (уникальная целая константа) или стандартный числовой атрибут (СЧА) GPSS-модели. Рассмотрим модель простейшего случайного процесса (рис. 1). Допустим, что есть блок GENERATE для генерации новых транзактов в различные моменты виртуального (модельного) времени и передачи в другие блоки модели. Блок TERMINATE имеет обратное назначение: удаляет поступающие в него транзакты. Подобный процесс получил название процесса размножения и гибели транзактов. Схема модели называется разомкнутой. Такие модели обладают двумя основными свойствами: 1) транзакты имеют конечное время жизни, которое существенно меньше всего виртуального интервала моделирования; 2) существуют один или несколько генераторов, которые впрыскивают транзакты в блок-схему модели, и соответственно должны быть терминаторы для уничтожения транзактов. Рассмотрим типовые случаи применения GPSS для моделирования систем массового обслуживания: • одноканальная система массового обслуживания с относительными приоритетами; • одноканальная система массового обслуживания с абсолютными приоритетами; • многоканальная система массового обслуживания с относительными приоритетами; • многоканальная система массового обслуживания с абсолютными приоритетами. 1. Одноканальная система массового обслуживания с относительными приоритетами. Транзакты поступают в очередь (блок QUEUE) в случайные моменты времени (рис. 2). С помощью блока SEIZE транзакт из очереди пытается попасть в виртуальное обслуживающее устройство, которое является аналогом службы сферы услуг, про- Ив3(9) 2007 I о <и о « 0 8 SI « 1 § g sc fi to « ■e OS C3 I Рис. 2. Одноканальная система массового обслуживания с относительными приоритетами давца, технической системы типа «турникет» в реальной жизни. Если очередь не пустая, то транзакты в ней упорядочены по правилу FIFO: «первым пришел — первым обслужен». Но если транзактам присвоить разные приоритеты, то правило FIFO распространяется только на группы транзактов с одинаковыми приоритетами, и чем больше приоритет, тем ближе к обслуживающему устройству находится транзакт. Для присвоения приоритетов транзакты предварительно пропускают через блоки PRIORITY, которые необходимо включить в блок-схему модели. Наконец, если транзакт оказался первым, т. е. в начале очереди, то после освобождения обслуживающего устройства он в него входит. В этом случае первое место в очереди освобождается для следующего транзакта (блок DEPART), а данный транзакт задерживается в устройстве на время обслуживания на какой-то, в общем случае— случайный интервал времени. Имитация обслуживания происходит в блоке ADVANCE. По завершении интервала времени транзакт выходит из устройства через блок RELEASE, после чего оно готово для нового обслуживания. Рассмотренную в данном примере дисциплину обслуживания в теории массового обслуживания называют правилом с относительными приоритетами. Если подставить рассмотренную на рис. 2 блок-схему вместо аморфной фигуры на рис. 1, то получится готовая модель, которую надо записать в операторах GPSS и выполнить на компьютере. Отметим, что специально описывать одноканальное устройство в модели не нужно (оно заводится автоматически). 2. Одноканальная система массового обслуживания с абсолютными приоритетами. Рассмотренная выше имитационная модель является хорошим средством для быстрого решения простейших задач массового обслуживания. Однако в реальной жизни процесс обслуживания более сложен. Например, ремонт очередного автомобиля в автосервисе может быть на некоторое время прерван, если пришла машина от более приоритетного клиента. Имитация подобных ситуаций возможна при использовании схемы, показанной на рис. 3. Эта блок-схема в общем похожа на предыдущую, но в ней используются другие блоки. Рассмотрим типовой режим работы данной модели. Процедура поступления в очередь и соблюдения порядка в очереди такая же, как в предыдущей модели. Но по- Рис. 3. Одноканальная система массового обслуживания с абсолютными приоритетами 80 N93(9)2007 ступление первого в очереди транзакта на обслуживание происходит по-другому. Существует два способа прерываний обслуживания: приоритетный режим и режим захвата. Не вдаваясь в подробности манипуляций с транзактами, кратко рассмотрим наиболее распространенный случай, который в теории массового обслуживания известен как правило с абсолютными приоритетами. С помощью блока PREEMPT первый тран-закт в очереди пытается попасть в виртуальное обслуживающее устройство, которое может быть занято. Если прерывания разрешены, и первый транзакт имеет приоритет выше, чем находящийся в устройстве, то обслуживание прерывается, а в узел поступает более приоритетный транзакт. После его выхода создаются условия для продолжения прерванного обслуживания транзакта, при котором интервал времени, заданный в блоке ADVANCE, в точности был бы выдержан. Однако возможны и другие варианты возобновления обслуживания (после прерывания в режиме захвата). 3. Многоканальная система массового обслуживания с относительными приоритетами. Процессы реальной сферы услуг значительно сложнее рассмотренных. Обычно в большом магазине не одна, а несколько касс, в зале парикмахерской — несколько мастеров. Поэтому одноканальное обслуживание, когда виртуальное устройство обслуживает один транзакт, является частным случаем. Общий случай — многоканальное массовое обслуживание. В GPSS многоканальное устройство и число каналов определяются оператором STORAGE, дополнительно включаемым в модель. Рассмотрим блок-схему (рис. 4). По количеству блоков и их расположению она похожа на предыдущие. Правила поступления в очередь и соблюдения порядка в ней такие же, как в модели, работающей по правилу относительных приоритетов. С помощью блока ENTER транзакт из очереди пытается попасть в один из каналов многоканального обслуживающего устройства. Если транзакт оказался первым « I s? .Si Рис. 4. Многоканальная система массового обслуживания с относительными приоритетами в очереди, то после освобождения любого канала обслуживающего устройства он в него входит. В этом случае первое место в очереди освобождается для следующего транзакта (блок DEPART), а данный транзакт задерживается в устройстве на время обслуживания на какой-то, в общем случае — случайный интервал времени. Имитация об-суживания происходит в блоке ADVANCE. По завершении интервала времени тран-закт выходит из канала через блок LEAVE, после чего канал готово к обслуживанию следующего транзакта из очереди. Следует отметить, что в блоке ADVANCE могут находиться несколько транзактов, обслуживаемых в разных каналах, причем моменты входа и время задержки для таких транзак-тов — разные. 4. Многоканальная система массового обслуживания с абсолютными приоритетами. Сразу отметим, что GPSS не предлагает изящного решения для построения такой модели. Разработчик может принимать различные решения. Самое простое заключается в том, чтобы для этих целей завести несколько одноканальных устройств, по одному для каждого виртуального канала. Для каждого такого псевдоканала нужно создать отдельные цепочки блоков PREEMPT- 81 Ik3(9) 2007 DEPART-ADVANCE-RETURN, но для правильного использования созданного таким образом многоканального устройства нужно создать диспетчер посредством других блоков GPSS. Через него должен проходить каждый транзакт, для которого посредством сложных тестирований и анализов условий выбирается правильный канал, реализуемый с помощью отдельного однока-нального устройства. Блок-схема модели после создания диспетчера увеличится в несколько раз. Поскольку все диспетчеры уникальны и зависят от опыта и вкуса разработчика, здесь они рассматриваться не будут. Моделирование в системе Pilgrim: акторы и узлы Акторы, теория акторов и ее развитие — теория акторных сетей ANT (Actor Networks Theory) — нашли применение в абстрактном моделировании социальных, экономико-конкурентных, политических и правовых sg процессов в тех областях, где есть опреде-! ленные трудности с применением абстракт-Ц ных моделей. В области software за послед-51 нее десятилетие известно несколько при-2 менений акторного подхода: о со 0 <á • в объектно-ориентированном програм- 1 мировании акторы выступают как объекты; g • появились новые языки, например, Ак-! торный Пролог; g • стала применяться новая разновид- ^ ность акторов (агентских программ), используемых для управления вычислитель- £ ным процессом, процессами в коммуника- s ционных и потребительских узлах Internet, ^ в имитационном моделировании и, возмож- зз но, в иных случаях. i 2? Основной динамической единицей в Pil- §з grim-модели является актор, который по не- ¡^ которым своим функциям аналогичен тран- | закту в GPSS. С помощью акторов точно также можно имитировать потоки. Актор прохо- ^ дит через узлы модели, которые образуют направленный граф, но блок-схемой изо-82 бражения многих реальных моделей назвать уже трудно, и не только потому, что устоявшийся термин «блок»заменен словом «узел». Дуги графа показывают не только пути перемещения динамических единиц — акторов, но и, например, пути денежных проводок, которые связаны с узлами (пути проводок от счета к счету невозможно представить путями транзактов). Кроме того, реальные модели, где кроме временной динамики имитируются финансовые и геопространственные процессы, отображаются на нескольких модельных слоях, которые иногда объединить невозможно. Графы, расположенные на различных слоях, тоже имеют связи между собой. Актор отличается от транзакта тем, что он является не таблицей, а компьютерной программой, которую иногда называют агентской программой. Р/'/дг/т-модель является скомпилированной программой, т. е. модель выполняется сама как независимая exe-про-грамма, а не в режиме прогона с помощью интерпретатора. Каждый узел «с точки зрения компьютера» —это автономный вычислительный процесс, выполняемый программой, реализующей функции узла. Актор во время моделирования внедряется в узлы, становясь участником вычислительного процесса, и, иногда, меняя функции или функциональные возможности узла (если это для чего-то необходимо). Теоретически с помощью актора ключ можно превратить в одно-канальное обсуживающее устройство, очередь — в одноканальное устройство, а у многоканального устройства уменьшить или увеличить число каналов, и все это — в процессе работы модели при выполнении определенный условий. Подобно транзакту, актор переходит от узла к узлу, а также имеет свой жизненный цикл. Каждый транзакт и каждый актор уникальны во время выполнения модели в смысле индивидуального номера и набора постоянных или изменяемых параметров. В смысле индивидуальности актор, кроме номера, времени рождения и времени гибели в модели, имеет по сравнению с транзактом неограниченные возможности, поскольку он — N93(9)2007 программа. Поэтому актор динамически может менять не только функции узлов, но и свои собственные, подключая к себе другие программы или трансформируясь в процессе моделирования «до неузнаваемости». Неизменными остаются только индивидуальный номер, время рождения и время гибели. Следует предупредить начинающих разработчиков, что создание моделей с трансформациями акторов и узлов — это «выс- ший пилотаж» в моделировании и систем- § ном программировании. Сначала нужно ос- * воить возможности Pilgrim — подобные тем, | которые предоставляет стандартный GPSS. ¡4 В узлах происходят некоторые изменения < внутренней информации акторов и накапливаются статистические данные. Полный список узлов и их обозначения приведены в табл. 2, где в фигурных скобках перечислены выбираемые альтернативы операндов. Таблица 2 Перечень узлов Actor Pilgrim Изображение узла Операнд Функциональное назначение операнда ( actor Л w A Имя генератора акторов B Номер данного узла-генератора ----- C Приоритет актора (начальное значение) {D} Постоянный интервал генерации актора (none) Равномерное распределение интервала (unif) Нормальное распределение (norm) Экспоненциальное распределение (expo) Эрланговское распределение (erln) Бета-распределение (beta) {E} Постоянный интервал генерации актора (none)* Среднее значение интервала (unif, norm, expo)* Средняя величина слагаемого (erln)* Первый параметр бета-распределения (beta)* {F} Максимальное отклонение от среднего (unif)* Среднеквадратичное отклонение (norm)* Параметр закона Эрланга (erln)* Второй параметр бета-распределения (beta)* Константа zero (none, expo)* {G} Третий параметр бета-распределения (beta)* Константа zero (none, unif, norm, expo, erln)* H Номер узла — приемника выходящих акторов attach A Имя ресурса 1 B Число затребованных элементов ресурса {C} Очередь с приоритетами (prty, либо none для FIFO) D Номер узла manage (менеджера ресурсов) A Имя генератора семейства акторов B Номер порождаемого семейства акторов Y C Число акторов в порожденном семействе {D} Передача акторам параметров родителя (copy) Параметры родителя не передаются (none) E Номер узла — приемника акторов-детей F Номер узла — приемника актора-родителя 83 Ив3(9) 2007 Продолжение табл. 2 л —»I direct I—». down 106 dinam 107 S s 3 о « 0 8 SI « 1 § g sc ^ s со « ■e OS CO _J key U». /Ю8\ A À hold ; ; reis _»[ manage]—». Тжл /parent fi 7 ™ Г pay 111 Программа proc 112 А Ж activ I I passiv A B C D E F A B A B C A B A B A B A B C D E F G A B C {D} {E} Функциональное назначение операнда Имя управляемого терминатора Начальный номер уничтожаемых семейств Конечный номер уничтожаемых семейств Номер семейства уничтожающего актора Число уничтожаемых акторов из семейств [B,C] Номер узла — приемника уничтожающего актора Имя директора финансов Номер узла-приемника после фактического выполнения проводки, запрошенной актором Имя функции перехода актора на нижний слой Номер узла-приемника на нижнем слое модели Номер узла возврата на прежний слой Имя очереди с геодинамическими приоритетами Номер узла — приемника proc (управляемого процесса) Имя ключа Номер узла — приемника выходящего актора Имя менеджера ресурсов Номер узла-приемника после фактического получения ресурсов, запрошенных актором Список параметров и их значения создаются автоматически (независимо от разработчика) Имя функции проводок и перечислений Номер узла send, на который передается сумма Значение денежной суммы (или стоимости) Номер узла send, с которого передается сумма Очередь с приоритетами (prty, либо none для FIFO) Номер узла-приемника на нижнем слое модели Номер узла возврата на слой расположения pay Имя управляемого процесса Имя подключаемой программы или dummy Номер исходной точки пространства или none Временная динамика: распределение интервала обслуживания в узле (как операнд D в узле actor) Временная динамика: параметр интервала обслуживания (как операнд E в actor) Пространственная динамика: на Земле (earth) на плоскости (plane) произвольная (cosmos) нет пространства (none) Пространственная динамика: интервал непрерывного нахождения узла proc в точке пространства 84 queue 113 rent 114 send 115 serv 116 term 117 fh3(9) 2007 Окончание табл. 2 Функциональное назначение операнда {F} G H A {B} C A B C {D} E F A B C {D} E A B {C} {D} {E} {F} {G} H A Временная динамика: параметр интервала активности (как операнд F в узле actor)_ Пространственная динамика: скорость перемещения узла proc между точками пространства_ Как параметр D в узле actor Номер узла — приемника выходящего актора Имя очереди Очередь с приоритетами (prty, либо none для FIFO) Номер узла, обслуживающего очередь Имя функции получения ресурсов Требование на число элементов ресурса Номер склада ресурсов (узла attach) Очередь с приоритетами (prty, либо none для FIFO) Номер узла-приемника на нижнем слое модели Номер узла возврата на слой размещения rent Имя узла — счета send Номер узла send, на который проводится сумма Величина суммы, перечисляемой в проводке Очередь с приоритетами (prty, либо none для FIFO) Номер узла direct (директора финансов) Имя сервера Число каналов обслуживания Сервис с абсолютными приоритетами (abs) Обслуживание без прерываний (none) Постоянный интервал сервиса актора (none) Равномерное распределение интервала (unif) Нормальное распределение (norm) Экспоненциальное распределение (expo) Эрланговское распределение (erln) Бета-распределение (beta) Постоянный интервал обслуживания (none)* Среднее значение интервала (unif, norm, expo)* Средняя величина слагаемого (erln)* Первый параметр бета-распределения (beta)* Максимальное отклонение от среднего (unif)* Среднеквадратичное отклонение (norm)* Параметр закона Эрланга (erln)* Второй параметр бета-распределения (beta)* Константа zero (none, expo)* Третий параметр бета-распределения (beta)* Константа zero (none, unif, norm, expo, erln)* Номер узла — приемника выходящего актора Имя терминатора « ! s? * В скобках указано соответствующее значение параметра D. S5 Ne3(9) 2007 Для создания Pilgrim-моделей массового обслуживания, аналогичных рассмотренным выше GPSS-моделям, непринципиально, что является динамической единицей: транзакт или актор. Но в моделях других типов актор предоставляет такие возможности разработчикам, которые нельзя реализовать с помощью транзактов. Тем не менее начнем знакомство с Pilgrim именно на примере моделей массового обслуживания, чтобы провести первое сравнение систем моделирования. Новые акторы зарождаются в узле actor — генераторе акторов, назначение которого аналогично блоку GENERATE. Далее они передаются в различные моменты виртуального модельного времени в другие узлы модели. Узел term — терминатор, имеет обратное назначение: удаляет из модели поступающие в него акторы (аналогичен блоку TERMINATE). Пример этого процесса показан на рис. 5. S I 3 о <и о « 0 8 « 1 § g j= с CL s to « ■e OS CO Рис. 5. Процесс размножения и гибели акторов Далее аналогии с йРвБ заканчиваются. Перейдем к четырем примерам систем массового обслуживания, описанным выше. Сначала рассмотрим простейший граф модели, показанный на рис. 6. queue serv 2 3 Рис. 6. Общая схема массового обслуживания Акторы поступают в очередь, которая упорядочена по приоритетам или по правилу FIFO. Из очереди акторы переходят в узел serv — обслуживающее устройство (иногда его называют сервером). Сервер имеет один или несколько каналов. Интервал обслуживания и его распределение задаются в этом же узле. Более приоритетные акторы могут прерывать обслуживание менее приоритетных, если это специально указать. С точки зрения текста модели в терминах Pilgrim схема имеет один и тот же вид для всех четырех случаев (в примерах выбран экспоненциальный закон интервала обслуживания). 1. Одноканальная система массового обслуживания с относительными приоритетами: top(2): queue("Очередь",prty,3); place; top(3): serv("Сервер1",1,none,expofzerofzerof4); place; 2. Одноканальная система массового обслуживания с абсолютными приоритетами: top(2): queue("Очередь",prty,3); place; top(3): serv("Сервер1",1fabsfexpo,zerofzerof4); place; 3. Многоканальная система массового обслуживания с относительными приоритетами (10 каналов): top(2): queue("Очередь",prty,3); place; top(3): serv("Сервер1",10,none,expofzerofzerof4); place; 4. Многоканальная система массового обслуживания с абсолютными приоритетами (10 каналов): top(2): queue("Очередь",prty,3); place; top(3): serv("Сервер1",10,abs,expofzerofzerof4); place; Если в приоритетном упорядочивании очереди нет необходимости, то правило FIFO можно отменить, после чего быстродействие модели несколько увеличится. Для этого в узле queue заменяют значение параметра B с prty на none. Все рассмотренные режимы удобно представить в виде табл. 3. С целью снижения компьютерного времени моделирова- se N93(9)2007 Таблица 3 § £ Параметры унифицированном схемы массового обслуживания ^ № п/п Свойства узлов queue и serv Обслуживание в узлах queue и serv Значения параметров 1. Очередь queue: тип обслуживания В порядке поступления (FIFO) С относительными приоритетами B = none B = prty 2. Сервер serv: число каналов Один Много (больше одного) B = 1 B > 1 3. Сервер serv: тип обслуживания В порядке поступления из queue С абсолютными приоритетами C = none C = abs ния алгоритмы работы с очередью и сервером выбираются автоматически по комбинациям значений параметров, приведенных в последнем столбце таблицы. Из рассмотренных примеров видно, что узел serv в конструкции top(3): serv("Сервер1",10,prty,expo,zero,zero,4); place; является аналогом созданного в GPSS-мо-дели оператором STORAGE многоканального устройства и его работы по обслуживанию транзактов с помощью цепочки блоков ENTER-DEPART-ADVANCE-LEAVE, с привлечением дополнительного блока PRIORITY для упорядочивания очереди. Оператор STORAGE интересен тем, что его элементы можно рассматривать как единицы общего ресурса (этим же интересен и узел serv). Транзакт может распоряжаться одним или несколькими элементами, затем освободить их и перейти к другому блоку. Также представляет интерес и иное использование ресурсов, многочисленные аналоги которого есть в реальной жизни: транзакт захватывает элементы, потом мигрирует по блок-схеме модели вместе с ними, а затем возвращает их (причем не обязательно в то же устройство типа STORAGE). Однако в GPSS это невозможно, а в Pilgrim используется развитая система управления ресурсами, позволяющая моделировать гораздо более сложные процессы. Самодостаточные процессы: замкнутые схемы моделей Выше были рассмотрены типовые модели массового обслуживания. Их особенность в том, что вся активность приходит из внешних генераторов (аналог внешней среды) и уходит. Схемы таких моделей называются разомкнутыми. Но в реальной жизни любая развивающаяся система стремится к самодостаточности, т. е. пытается обеспечить себя всем необходимым для развития, а из внешней среды получать только дополнительные ресурсы в обмен на продукты своей деятельности. Свойство самодостаточности можно имитировать только замыкая пути транзак-тов или акторов, т.е. создавая замкнутые схемы моделей. Сначала рассмотрим сравнительно простой пример такой модели. Пример 1. Оптимизация производства на швейной фабрике3. 1. Постановка задачи. На швейной фабрике 50 швейных машинок работают по 8 ч в день и по 5 дн. в неделю. Каждая из этих машинок может в любой момент времени выйти из строя. В этом случае ее заменяют резервной машинкой, причем либо сразу, либо по мере ее появления. Тем временем сломанную машинку отправляют в ремонтную мастерскую, где ее чинят и возвращают в цех, но уже в качестве резервной. Эта поучительная модель впервые реализована и описана Т.Дж. Шрайбером. 87 Ik3(9) 2007 В существующем замкнутом цикле движения машин легко выделить четыре фазы (рис. 7). Всего в системе находятся 59 машинок, причем в разные моменты времени возможны различные случайные сочетания, например: 2 в ремонте, 2 ждут ремонта, 50 в работе и 5 резервных находятся в цехе и готовы к использованию (ситуация показана на рис. 7). Предполагается, что наладчики в мастерской могут параллельно чинить машинки. Резерв: Цех: 5 готовых к работе 50 исправных машинок машинок в работе Мастерская: Очередь: 2 наладчика чинят 2 машинки ждут ремонта 2 машинки | Рис. 7. Основные фазы производства а ц Управляющий хочет знать, сколько наладчиков следует нанять для работы в мастер-2 ской, сколько машинок следует иметь в ре-| зерве сверх 50 собственных, какую платить 8 за это арендную плату, чтобы резервными 5 машинками можно было подменить те, кото-д рые временно вышли из строя. Цель — ми-| нимизация стоимости производства. | 2. Исходные данные. Оплата рабочих ™ в мастерской 3,75 долл. в час. За машинки, ■I находящиеся в резерве, надо платить по 30 £ долл. в день. Почасовой убыток при исполь-■а зовании менее 50 машинок в производстве ^ оценивается примерно в 20 долл. на машин-25 ку. Этот убыток возникает из-за снижения ¡Л производительности. Опыт эксплуатации по-2? казывает, что на наладку сломанной машин-<з ки уходит в среднем 7 ч, распределение нор-^ мальное, среднеквадратичное отклонение ! равно 3 ч. Когда машинку используют в производстве, время наработки до отказа составляет в среднем 157 ч, распределение экспоненциальное4. Время, необходимое для перевозки машинки из цеха в мастерскую и обратно, мало, и его не учитывают. Между рабочими в мастерской не делают никаких различий. Не делают различий также и между машинками. Иными словами, распределение времени ремонта не зависит от того, кто какую машину ремонтирует. Распределение времени наработки до отказа одинаково как для собственных, так и для арендуемых машинок. Плата за арендуемые машинки не зависит от того, используют их или они простаивают. По этой причине не делают попыток увеличить число собственных машинок в работе в любой период времени. Предполагаем, что машинку снимают с работы только в том случае, если она ломается. Необходимо построить на GPSS или Pilgrim модель такой системы и просчитать на ней расходы при различном числе арендуемых машинок, доступных управляющему, и найти такую величину, которая минимизирует стоимость эксплуатации системы. 3. Построение модели. Сначала следует разобраться в том, какие ограничения существуют в системе, а затем определить, какие элементы GPSS или Pilgrim следует использовать для удовлетворения этих ограничений. В нашей производственной системе существует три ограничения: • число наладчиков в мастерской; • максимальное число швейных машинок, одновременно находящихся в цехе; • общее число машинок, циркулирующих в системе. Для моделирования первых двух ограничений удобно использовать многоканальные устройства, а третье — следует моделиро- 4 В своей постановке задачи Т.Дж. Шрайбер предположил, что на наладку тратится время 7±3 ч, распределение равномерное, а время наработки до отказа составляет 157±25 ч, распределение также равномерное. Отклонения в расчетах в связи с особенностями случайных процессов в данной задаче составляют десятки процентов. 88 N93(9)2007 вать транзактами (акторами). В результате такого выбора количество наладчиков мастерской и машинок, находящихся в производстве, задается некоторыми константами, которые занимают в модели определенное место. Сами швейные машинки представляются динамическими объектами, перемещаемыми из одного места в другое в процессе их циркулирования в модели. Моделирование на GPSS Рассмотрим состояния определенной машинки в процессе полного оборота в цикле системы. Предположим, что машинка в настоящий момент находится в резерве. Тогда многоканальное устройство NOWON, используемое для моделирования находящихся в работе машинок, заполнено, и резервные машинки не могут войти в него. Машинка, находящаяся в состоянии резерва, может получить возможность войти в работу, с помощью моделирующего ее тран-закта, когда одна из машинок, наконец, выйдет из строя. После того, как машинка станет неисправной, транзакт покидает многоканальное устройство NOWON и тем самым открывает возможность другой резервной машинке войти в работу. Теперь транзакт ожидает (если в этом есть необходимость) входа в многоканальное устройство MEN (рабочие мастерской). Войдя в него, транзакт играет роль ремонтируемой машинки. Когда он уходит из этого многоканального устройства, тем самым освобождая рабочего, последний может приняться за ремонт следующей машинки. Тем временем транзакт вновь возвращается в ту точку модели, в которой он снова начинает делать попытки войти в многоканальное устройство NOWON. Общее число машинок, циркулирующих в системе, равно 50 собственным машинам плюс некоторое число арендуемых для резерва (в нашем примере их 9). Обратите внимание, что многоканальное устройство NOWON можно рассматривать как 50 рабочих мест для швейных машинок. Эта точка зрения отвечает тому ограничению, что од- новременно не могут работать более 50 швей- § ных машин. Такая довольно сложная задача * на GPSS или Pilgrim может быть промодели- | рована очень просто. Модель этой же сис- ¡4 темы на языке программирования (напри- < мер, на Fortran) значительно сложнее. Блок-схема модели на GPSS приведена на рис. 8. Видно, что в схеме постоянно должно быть 59 транзактов, причем они не уничтожаются (нет терминатора). Однако как-то Первоначальный ввод N0W0N9+ транзактов Рис. 8. Реализация модели на GPSS 89 Ne3(9) 2007 нужно в начальный момент поместить их в модель. Кроме того, непонятно, до каких пор можно моделировать, так как таймер не определен. Текст GPSS-модели дан ниже. Моделирование в системе Pilgrim Схема Pilgrim-модели показана на рис. 9. Она полностью отражает топологию четырех фаз рис. 7. Но и здесь остается нерешенным вопрос о начальной зарядке модели. Цех: 50 исправных машинок в работе CNTRL Единовременная генерация N0W0N+9=59 транзактов 5 готовых к работе машинок а) Таймер отсчитывает 3 года: 6240 ч при 40-часовой рабочей неделе б) N0W0N+9 акторов queue serv 1 2 N0W0N каналов MEN serv queue каналов 4 3 Мастерская: 2 наладчика чинят 2 машинки Очередь: 2 машинки в ожидании ремонта S I 3 о <и о « 0 8 « 1 § s j= с CL s со « ■е os сз Рис. 9. Реализация Pilgrim-модели Рис. 10. Схема зарядки и отсчета времени в GPSS-модели: а) зарядка модели; б) отсчет времени времени запускает в блок-схему модели (рис. 8) 59 транзактов. Если объединить схемы на рис. 8 и 10, то GPSS-модель фактически готова. Ее текст приведен ниже: *LOC OPERATION A,B,C,D,E,F,G SIMULATE ****************************************** Перейдем к созданию управляющих схем MEN STORAGE 9 для запуска замкнутых моделей, которые NOWON STORAGE 50 имеют два основных свойства: ****************************************** GENERATE ,,,59 1) некоторые или все транзакты в моде- AGAIN QUEUE STOCK ли могут иметь неограниченное время жиз- ENTER NOWON ни, если специально не управлять этим вре- DEPART STOCK менем; ADVANCE (Exponential(1,0,157)) 2) нужна специальная схема зарядки мо- LEAVE NOWON дели, выполняющая следующие функции: QUEUE REPAIR ENTER MEN • ввод в определенные узлы модели DEPART REPAIR в начальный момент времени группы тран- ADVANCE (Normal(1,7,2)) зактов; LEAVE MEN • управление модельным временем. TRANSFER ,AGAIN ****************************************** Рассмотрим реализацию схемы зарядки GENERATE 6240 сначала с помощью GPSS-, а затем — Pil- TERMINATE 1 grim-модели. START 1 Схема зарядки модели на GPSS В схеме зарядки используются 2 генератора и 1 терминатор (рис. 10). Первый генератор с именем CNTRL в нулевой момент 90 Реализация схемы зарядки на Pilgrim В схеме зарядки используются 3 узла: генератор акторов actor, генератор семейства creat и терминатор term (рис. 11). Гене- Рис. 11. Схема зарядки замкнутой Pilgrim-модели ратор в начальный момент ^ > 0 выпускает первый актор, который сразу попадает на вход генератора семейства. Семейство, состоящее из 59 акторов, создается в тот же момент времени t1 и поступает в основную схему модели, показанную на рис. 9, а родительский актор переходит в терминатор. В терминаторе он выполняет команду cheg в отношении генератора акторов, установив интервал времени между появлением первого актора и генерацией второго равным времени моделирования, определенному в переменной Protime. Таким образом, второй транзакт должен появиться в момент t1 + Protime, т. е. он не появится вообще. Время моделирования всегда задается непосредственно в операторе modbeg. Если объединить схемы на рис. 9 и 11, то Pilgrim-модель фактически готова. Текст ее приведен ниже: #include <Pilgrim.h> int Nowon = 50; // Число собственных // машинок int Men = 3; // Число наладчиков int Rent = 9; // Число арендуемых // резервных машинок float Protime = 624 0.0; // Время моделирования: // 3 года forward { modbeg ("Мануфактура"f7fProtimeflong) time(NULL),nonef1,none,none,1); ag ("Подготовка производства",5, none,none,1.0,zero,zerof6); №>3(9)2007 network (dummy,dummy) § { Ü top(1): queue ("Резерв машин",none,2); ^ i щ place; . top(2): serv ("Машины в работе"fNowonf none,expof157.0,zerofzerof3); place; top(3): queue ("Ожидание ремонта"fnonef4); place; top(4): serv ("Машинки в ремонте"fMenf none,normf7.0f2.0,zerof1); place; top(6): creat ("Подготовка машинок"fnonef Nowon+Rent,copy,1,7); place; top(7): term ("Производство готово"); cheg (5,nonefnonefProtimefzero, zero,7); place; fault (123); } modend ("Factory.doc",1,24fpage); return 0; } Способы реализации непрерывных моделей Непрерывные компоненты модели представляют процессы перемещения товаров транспортными средствами поверхности Земли с учетом дорожной сети, химическое производство или окружающую среду вокруг объекта экономики. Непрерывные компоненты, если они необходимы, могут быть представлены: • дифференциальными уравнениями (несмотря на применение аналоговых методов моделирования, иногда они бывают нужны); • расчетными формулами, реализующими конкретный математический метод; • методом Монте-Карло, который реализуется элементарно при наличии качественных датчиков псевдослучайных величин. В симуляторах GPSS World и Actor Pilgrim реализованы два способа реализации моделей непрерывных компонентов: пассивный и активный (управляемый). Непрерывные модели в GPSS Моделирование протекает в чередующихся непрерывной и дискретной фазах. При планировании событий процесс моделирования протекает в дискретной фазе, во время которой модельное время не меняется. Между такими моментами процесс моделирования протекает в непрерывной фазе. В течение этой фазы через небольшие приращения модельного времени, называемые мини-шагами, происходит интегрирование. В конце мини-шагов зафиксированные значения интегрируемых переменных возвращают промежуточные значения. Из непрерывной фазы в дискретную процесс моделирования переходит тогда, когда при пересечении интегрируемой переменной порогового значения генерируется транзакт. Таким образом, непрерывная и дискретная фазы взаимосвязаны. Параметр модели, называемый допустимым отклонением интегрирования, используется для ограничения локальной ошибки округ-ig ления при интегрировании. Этот параметр ! применяется ко всем процессам интегриро-Ц вания, выполняющимся в процессе модели-§ рования. Допустимое отклонение устанав-2 ливается перед запуском модели. 0 со § 1. Пассивный способ реализации 1 непрерывных компонентов g GPSS World позволяет строить модели, ! в которых можно выразить изменение пере-g менных в виде их производных по времени. ^ Для включения в модель системы обыкновенных дифференциальных уравнений любого £ порядка в GPSS World имеются команда | INTEGRATE и блок INTEGRATION. Интегриро-^ вание осуществляется численным методом зз (используется одна из разновидностей метода да Рунге-Кутта). Для задания дифференци-2? ального уравнения и пороговых значений пе-§з ременной предназначена команда INTEGRATE. ¡^ Непрерывно интегрируемые переменные | могут использоваться и в дискретной части процесса моделирования, в том числе и для ^ изменения пороговых значений. Во время моделирования при пересечении порогового 92 значения (если оно задано) в любом направлении создается новый транзакт с нулевым приоритетом и направляется в блок, указанный операндами команды INTEGRATE. Пример 2. Моделирование распространения эпидемии. Допустим, что в районе, население которого составляет 50000 человек, возникла эпидемия, и появилось 80 инфецированных больных. Предположим, что прирост больных за день пропорционален произведению числа здоровых, еще не переболевших и не приобретших иммунитет людей, на число больных. Коэффициент пропорциональности Factor (коэффициент распространения инфекции) включает разного рода профилактические меры, принимаемые во время эпидемии. Требуется определить как развивается эпидемия и каково будет максимальное число больных. Известно, что процесс развития эпидемии может быть представлен системой двух обыкновенных дифференциальных уравнений. Для моделирования количества незаболевших жителей используется уравнение Healthy(), а динамика числа больных жителей описывается уравнением Patient(). Число не заболевших жителей находится в переменной Xheal-thy, а количество больных — в Xpatient. Исходные данные: Factor = 0.0001, общее число жителей Xhealthy = 50000, число заболевших в начальный момент Xpatient = 80. Время моделирования задается с помощью блоков GENERATE и TERMINATE и равно 30 дн. В представлении GPSS World модель с непрерывными компонентами выглядят как описано ниже. *LOC OPERATION A,B,C,D,E,F,G SIMULATE ********************************************* Xhealthy INTEGRATE (HealthyO) Xpatient INTEGRATE (Patient()) ********************************************* Factor EQU 0.0001 Xhealthy EQU 50000 Xpatient EQU 8 0 N93(9)2007 ********************************************* GENERATE 3 0 TERMINATE 1 ********************************************* PROCEDURE Healthy() BEGIN TEMPORARY Hvary; IF(Xhealthy< 0)THEN Xhealthy = 0; IF (Xhealthy > 10e5 0)THEN Xhealthy=10e5 0; Hvary=(0 —Factor)#Xpatient#Xhealthy; RETURN Hvary; END; PROCEDURE Patient() BEGIN TEMPORARY Pvary; IF(Xpatient< 0)THEN Xpatient = 0; IF (Xpatient >10e5 0)THEN Xpatient = 10e5 0; Pvary = Xpatient#(Factor#Xhealthy —1); RETURN Pvary; END; где символ # представляет знак умножения в арифметических выражениях. Графические результаты интегрирования показаны на рис. 12. 2. Активный способ реализации непрерывных компонентов Транзактное управление активностью реализовано с помощью блока INTEGRATION, который предназначен для включения или выключения процесса интегрирования переменной пользователя. Например, INTEGRATION Flow активизирует процесс интегрирования переменной пользователя Flow (поток), а INTEGRATION Flow,OFF выключает процесс интегрирования. Непрерывные компоненты Pilgrim-модели В системе Pilgrim достаточно качественные датчики псевдослучайных величин (32-разрядные float и 64-разрядные double). Поэтому при реализации непрерывных компонентов предпочтение отдается аналоговым методам: интегрированию по методу « ! s? .Si Рис. 12. Результаты моделирования развития эпидемии 93 Ik3(9) 2007 Монте-Карло, аналитическим решениям дифференциальных уравнений (в виде формул). И только иногда, если разработчику модели очень хочется включить решение дифференциального уравнения в численном виде, эта возможность ему предоставляется (либо он сам пишет подпрограммы подобные тем, которые мы рассмотрели в примере на GPSS, либо использует стандартную подпрограмму). 1. Пассивный способ реализации непрерывных компонентов Эти компоненты имитационной модели (например, модель процесса в природной среде, который можно только наблюдать, не имея возможности управления) запускаются сразу координатором network в нулевой момент модельного времени. Воздействовать на выполнение этих непрерывных компонент с помощью акторов из каких-либо узлов невозможно: они выполняются автономно от акторов и узлов, но жестко sg привязаны к единому модельному таймеру. ! Например, если для модели экологического Ц назначения нужны две непрерывные компо-§ ненты, то обращение к ним имеет вид: о g network(Atmosphere, Washout), со 0 8 где Atmosphere — программа расчета атмо-| сферного переноса загрязняющего вещего ства, оформленная следующим образом: 1 Э double Atmosphere(double delta) % I { // Текст программы "»2 ¡5^ return (1.00) ? }; s и ^ Washout — программа расчета смыва зз выпавших на поверхность загрязняющих § веществ в результате естественных дож- 2? дей, которая оформляется аналогичным об- §з разом: Л g double Washout(double delta) & { // Текст программы ^ return (1.00) }; 94 delta — интервал между событиями на отрезке [f, t+d], т.е. delta содержит новое значение d при каждом последующем обращении кэтим программам. Операция delta = d выполняется каждый раз координатором. Текст программы — либо расчетная программа (пишется на языке С++ разработчиком модели), либо обращение к стандартной математической программе из любого пакета (стандартный obj-модуль включается в exe-программу модели стандартными средствами C++). Если программа предназначена для решения дифференциальных уравнений, то интервал d делится на более мелкие шаги для обеспечения заданной точности (численные математические методы рассматриваются в специальной литературе). При реализации пассивных непрерывных компонентов очередной интервал, на котором выполняется непрерывная компонента — это отрезок времени между двумя ближайшими событиями в стохастической сети, т.е. управление программам Atmosphere и Washout передается автоматически при планировании очередного события, автоматически передается и значение интервала d, а время t получается из общедоступной глобальной переменной timer. 2. Активный способ реализации непрерывных компонентов Акторно-управляемые непрерывные компоненты связаны с узлами типа proc, позволяющими имитировать управляемые процессы. Соответствующие программы запускаются в узлах proc входящими акторами и выполняются до тех пор, пока актор, активизировавший непрерывную компоненту, не покинет соответствующий узел, т. е. время выполнения непрерывной компоненты равно ta — интервалу активности процесса в узле proc. Активностью процесса выполнения непрерывной модели можно управлять из других узлов. Например, с помощью командной функции passiv выполнение непрерывной N93(9)2007 модели в узле proc можно приостановить (актор при этом отправляется в специальный стек и отсчет времени активности ta приостанавливается), а с помощью другой функции activ — восстановить (актор после этого возвращается из стека и отсчет времени активности ta возобновляется). В результате реальный интервал пребывания актора в узле proc увеличивается на tz — время его содержания в стеке (на интервал времени между моментами выполнения команд passiv и activ). Такая возможность используется при моделировании систем управления непрерывным производством (но для моделирования многоуровневых прерываний в вычислительной системе удобнее использовать узел serv). Программа, реализующая непрерывную компоненту узла proc, также осуществляется одним из двух возможных способов: это либо расчетная программа на языке С++, либо обращение к стандартной математической программе из любого пакета средствами C++. Если программа предназначена для решения дифференциальных уравнений, то интервал активности ta делится на более мелкие шаги для обеспечения заданной точности. Управление программе, реализующей акторно-управляемую компоненту, передается автоматически из узла proc, при этом ей передается и значение интервала ta, а моменты входа актора в узел и его выхода получаются из общедоступной глобальной переменной timer. Пример 3. Рассмотрим пример химического производства. Имеется реактор, который в начальный момент загружен исходным сырьем (смесью компонентов) с начальной массой R. Длительность реакции определяется переменной Treaction. Поэтому время активного пребывания актора в узле proc ta=Treaction (рис. 13). В процессе реакции масса сырья уменьшается по закону Raw(t), поэтому Raw(0) = R, Raw(Treaction) = 0. Полезный продукт реак- « ! s? .Si w— Treaction Рис. 13. Графики уравнений химической кинетики ции появляется по закону Output(t), поэтому 0utput(0) = 0, Output(Treaction) = P, где P — суммарное количество продукта, полученного во время реакции. Наряду с продуктом в реакторе появляются отходы по закону Waste(t), причем Waste(0)=0, Waste(Treacti-on)=W, где W — это суммарное количество отходов, которое необходимо по завершении реакции выгрузить из реактора. Процесс химической реакции обычно описывается системой дифференциальных уравнений, называемых уравнениями химической кинетики. Функции Raw(t), Output(t) и Waste(t) получаются в результате решения этой системы уравнений. Если для такой системы имеется аналитическое решение (что бывает довольно часто), то необходимости в численном интегрировании нет — гораздо проще проводятся расчеты по формулам. Обычно графики функций, являющиеся аналитическими решениями, нелинейные. Однако допустим (только для простоты изложения), что решения Raw(t), Output(t) и Waste(t) — линейные функции. Кроме того, время реакции Treaction является линейно-убывающей функцией температуры Temperature, которая может изменяться в пределах от 10 до 90° C, причем при 10° C время реакции составляет 3 ч, а при 90° C равно 1 ч. Тогда вместо решения системы дифференциальных уравнений можно делать расчет по формулам для любого значения вре- 95 Ne3(9) 2007 мени t, если воспользоваться следующей системой уравнений: 2 Treaction = 1 - Raw( t) = R\1 Output( t) Waste( t) - ( Temperature - 90) 1 -t Treaction _P_ Treaction W t t Treaction 3 о <u о « 0 8 SI « 1 § g j= с CL fi со « ■е os ï сз Рассмотрим реализацию данного примера с помощью простейшей имитационной Pilgrim-модели, граф которой показан на рис. 14. Узел proc нужен для запуска непрерывной компоненты — химической реакции. Актор, поступающий на его вход, является сигналом для начала имитации непрерывного производства. Он запускает в узле программу SysDiffEqu, производящую расчеты с помощью описанной в нашем примере системы линейных уравнений. Узел serv имитирует выгрузку полезной продукции, отходов и подготовку реактора к следующему производственному циклу. Рис. 14. Модель непрерывного химического производства Поскольку температуру в реакторе можно изменять в процессе моделирования, при входе актора в узел proc время активной задержки актора ta каждый раз вычисляется заново, т.е. первое уравнение из рассмотренной системы решается в самом 96 узле proc сразу после того как в него войдет очередной актор. Программа SysDiffEqu каждый раз делит интервал активности на 10 отрезков и по формулам вычисляет значения функций Raw(t), Output(t) и Waste(t) для каждого момента времени. #include <Pilgrim.h> double R=3.0; //Масса исходного сырья,т double P = 2.5; //Масса полезной продукции,т double W=0.5; //Масса отходов,т double Treaction; //Длительность реакции,ч double Temperature; //Температура в реакторе,°С //------------------------------------------- // Непрерывная компонента модели //------------------------------------------- double SysDiffEqu(double duration) { int i; double step; // Шаг приращений double t=0.0; double Raw= R; double Output = 0.0; double Waste=0.0; step = duration/10. 0; for(i=1; i<=0; i++) { t += step; Raw -= R*step/Treaction; Output += P*step/Treaction; Waste += W*step/Treaction; } return 0; } //------------------------------------------- // Дискретная компонента модели //------------------------------------------- forward { modbeg ("Модель реактора"/6/50.0/(long) time(NULL),none,2,none,none,2); actor ("Производство",1,none,expo/3.0/ zero,zero,2); Temperature = 50.0; network (dummy,dummy) { top(2): queue("Очередь производства", none,3); place; №3(9) 2007 top(3): key ("Пуск реактора",4); place; top(4): Treaction=1.0-(2.0/80.0)* (Temperature-9 0.0); proc ("Химпроцесс",SysDiffEqu,1, none,Treaction,zero,zero,5); hold(3); place; top(5): serv ("Контроллер",1,none,norm, 0.5,0.1,zero,6); passiv(4); place; top(6): term ("Учетчик"); activ(4); rels(3) place; fault(123); } modend("Results.doc",1,12,page); return 0; } В рассмотренной модели ключ key служит для подачи команды на запуск реакции, а команды hold и rels нужны для блокировки реактора от случайных входных воздействий— до тех пор, пока реакция не завершится и реактор не будет разгружен. Команды activ и passiv использованы в основном для того, чтобы имитировать включение системы безопасности на период выгрузки из реактора полезного продукта и удаления отходов. Однако в более сложных случаях, например, при моделировании географически распределенной логистической системы, команды activ и passiv позволяют управлять псевдо-непрерывными процессами поставок. Полученные значения можно выводить в любом понятном виде, например, как таблицу через диалоговое окно MessageBox. Для этого в программу SysDiffEqu нужно добавить строковую переменную String, где будет формироваться содержимое таблицы посредством трех операторов sprintf (первый — для формирования заголовка, второй — вывода начальных значений в первой строке, а третий — вывода каждой промежуточной и последней строки). Дополненная программа SysDiffEqu показана ниже. double SysDiffEqu(double duration) { // Строка вывода // Шаг приращений char String[1024] int i; double step; double t = 0.0; double Raw = R; double Output = 0.0; double Waste = 0.0; step = duration/10.0; sprintf (String, "Время Сырье Продукт Отходы\п") ; sprintf (&String[strlen(String)], "%7.3lf %7.3lf %7.3lf %7.3lf\n", t,R,0.0,0.0); // Начальные значения for(i=1; i<=0; i++) { t += step; Raw -= R*step/Treaction; Output += P*step/Treaction; Waste += W*step/Treaction; sprintf(&String[strlen(String)], "%7.3lf %7.3lf %7.3lf %7.3lf\n", t,Raw,Output,Waste); // Текущие // значения } MessageBox (hwnd,String,"Состояние реактора:", MB_OK); return 0; } Результирующая таблица, появляющаяся в диалоговом окне MessageBox, показана на рис. 15. со § Л ■S Состояние реактора: [х] Бремя Сырьё Продукт Отходы 0,000 3,000 0,000 0.000 0,200 2,700 0,250 0.050 0.400 2,400 0,500 0.100 0.600 2,100 0,750 0.150 0.800 1,800 1.000 0.200 1.000 1,500 1,250 0.250 1,200 1,200 1,500 0.300 1.400 0,900 1,750 0.350 1,600 0,600 2,000 0,400 1,300 0,300 2,250 0,450 2,000 0,000 2,500 0.500 OK Рис. 15. Табличная индикация процесса в химическом реакторе 97 Ik3(9) 2007 ^ Управляющие программы-симуляторы GPSS и Pilgrim Основные функции программы-симуля-тора: • управление транзактами (акторами) и блоками (узлами); • сбор и обработка статистических данных во время моделирования; • управление виртуальным временем. Ниже отдельно рассмотрим интерпретатор GPSS и диспетчер Pilgrim. Интерпретатор GPSS Все операторы (в соответствии с блок-схемой) и исходные данные модели обрабатываются интерпретатором, который и выполняет перечисленные функции управляющей программы после предварительного ассемблирования модели. Транзактная идеология оказалась весьма удачной для управления модельным временем в режиме интерпретации. Рассмотрим ее подробнее sg с позиций управления. ! Выше были описаны некоторые дейст-Ц вия, выполняемые интерпретатором по от-51 ношению к транзактам. Это описание, все-2 таки, не является достаточным. Например, | нами был рассмотрен вопрос о движении 8 транзактов от блока к блоку. Тем не менее, | блок-схемы на рисунках являются скорее g статичными, нежели динамичными. Все еще ! не ясно, какой транзакт интерпретатор вы-g берет следующим для продвижения в мо-^ дели, или в чем заключается суть дисциплины обслуживания очереди «первым при-£ шел — первым обслужен внутри одного при-s оритетного класса». На эти вопросы можно ^ будет дать удовлетворительный ответ толь-зз ко после того как будет рассмотрена логика ка, на которой основана работа интерпре-2? татора. §з В основном логика работы интерпрета-¡^ тора становится понятной из рассмотрения | механизма отслеживания пути транзактов, движущихся в модели. Интерпретатор рас-^ сматривает каждый транзакт как элемент одного или нескольких списков. Списки яв- ляются открытыми, а не замкнутыми, следовательно, они имеют два конца: начальный и конечный. В качестве элемента списка тран-закт занимает определенное положение относительно его начала. Положение транзак-та в списке тесно связано с тем, как скоро транзакт должен снова вернуться в модель для продолжения движения. Последовательность обработки, в свою очередь, зависит от времени возникновения событий при выполнении моделирования. Интерпретатор создает списки следующих видов: • текущих событий, • будущих событий, • пользователя, • прерывания, • парности. Имеется только один список текущих и один список будущих событий. В общем случае могут существовать более чем один список пользователя, прерывания и парности. Списки текущих и будущих событий мы рассмотрим ниже. Изучение списков пользователя, прерывания и парности необходимо для построения довольно сложных моделей. Список текущих событий состоит из тех транзактов, для которых планируется их продвижение в одном или нескольких блоках в течение текущего значения модельного времени или в течение ближайшего времени. В список текущих событий входят те транзакты, движение которых заблокировано ввиду текущих условий в модели. По желанию пользователя транзакты могут быть перенесены из списка текущих событий в список пользователя. Это можно сделать для уменьшения времени моделирования, использования нетипичной дисциплины обслуживания или для того и другого, но с существенным увеличением сложности восприятия модели. Например, транзакт может быть временно заблокирован ввиду планирования его входа в блок SEIZE, когда требуемое одноканальное устройство находится в состоянии «занято». N93(9)2007 Список будущих событий состоит из таких транзактов, движение которых не планируется до наступления некоторого времени в будущем. Эти условия могут возникать только в двух следующих случаях: • транзакт попал в блок ADVANCE, и до некоторого времени нет попытки продвинуть его в следующий блок модели; • транзакт должен войти в модель в некоторый более поздний момент времени через блок GENERATE. Фактически существует и третий случай, при котором транзакт может попасть в список будущих событий, но он достаточно сложен и здесь рассматриваться не будет. Предположим, что мы имеем некоторую модель, записанную на GPSS, и хотим узнать где в модели находится соответствующий транзакт. Отметим, что ответ может быть дан двояко: 1)с точки зрения расположения тран-закта в блок-схеме, т. е. того, в каком блоке он расположен; 2) с точки зрения нахождения транзакта в списках, т.е. какому списку он принадлежит. Иначе говоря, транзакт логически одновременно существует и в блоке, и в списке. Ответ на поставленный вопрос, таким образом, зависит от контекста самого вопроса. Различия между этими двумя подходами надо хорошо помнить. Транзакты в списке будущих событий отсортированы в порядке запланированных будущих моментов времени. Предположим, например, что текущее значение таймера равно 48. Тогда транзакт, выход которого из блока ADVANCE запланирован на время 54, будет ближе к началу в списке будущих событий, чем транзакт, выход которого запланирован из блока ADVANCE (того же или другого) на время 59. GPSS изменяет состояние модели при просмотре списка текущих событий от на- чала к концу, транзакт за транзактом. При § анализе каждого транзакта интерпретатор * выбирает его и двигает в модели по некото- | рой траектории до тех пор, пока не встре- ¡4 тится одна из трех ситуаций. < 1. Транзакт входит в блок ADVANCE, где он должен пробыть некоторое вычисленное время. Когда это происходит, интерпретатор отправляет транзакт в список будущих событий, помещая его в ту позицию, которая соответствует времени выхода транзак-та из списка в следующий блок. 2. Возникает условие блокировки, означающее, что транзакт не может войти в следующий блок. Если это происходит, транзакт остается в списке текущих событий (и в блоке, в котором он находится). Отметим, что транзакт может успешно пройти несколько блоков, прежде чем возникнет условие блокировки. Интерпретатор GpSs, естественно, скорректирует его местонахождение в модели. 3. Транзакт входит в блок TERMINATE. При этом интерпретатор выводит транзакт из модели. Когда транзакт прекращает движение, интерпретатор выполняет одно из двух действий. 1. Продолжая просмотр списка текущих событий, он выбирает следующий транзакт и пытается продвинуть его в модели. 2. Без продвижения таймера интерпретатор начинает просмотр списка текущих событий от начала. Начало просмотра означает, что интерпретатор возвращается к началу списка, выбирает первый транзакт и двигает его в модели насколько это возможно. Когда транзакт прекращает продвижение, интерпретатор снова предпринимает одно из описанных действий и т.д. Просмотр начинается от начала списка только при выполнении специальных условий. Эти условия зависят от того, какая подпрограмма была выполнена для только что 99 Ik3(9) 2007 остановленного транзакта. Если он прошел блок SEIZE или RELEASE, то интерпретатор выполняет второе действие. (Выполнение подпрограмм некоторых других, пока не изученных блоков, вызывает просмотр списка таким же образом.) Причина возобновления просмотра при выполнении блока RELEASE заключается в том, что заблокированные ранее транзакты теперь, возможно, смогут возобновить продвижение ввиду освобождения устройства. Целью просмотра является в этом случае поиск тех тран-зактов от начала цепи текущих событий, которые принадлежат к этой категории. Следует пояснить, почему список текущих событий начинает просматриваться сначала в результате выполнения блока SEIZE. Вполне возможно, что где-то в модели есть заблокированные транзакты (в блоках, тип которых пока не изучен), ввиду того что есть свободные устройства. Следовательно, и занятие прибора и его освобождение в общем случае могут снять условия блокировки. sg Предположим, только что обработан тран-! закт, находящийся в конце списка текущих Ц событий. Следующего транзакта в этом спи-§ ске нет. (Могут быть другие транзакты в спи-2 ске текущих событий. Если это так, то они | располагаются в начале списка и заблоки-8 рованы.) В качестве следующего шага ин-| терпретатор проверяет транзакты от начало ла списка будущих событий. Он продвигает ! таймер модельного времени к значению, g запланированному для перемещения сле-^ дующего транзакта. Этот транзакт переносится из списка будущих в список текущих £ событий. Любые другие транзакты, движе-s ние которых можно возобновить в это «но-^ вое» значение времени, также переносятся зз из списка будущих в список текущих собы-§ тий. Каждый входящий транзакт занимает 2? положение в соответствии со своим уров-§з нем приоритета. Чем выше уровень приори-^ тета, тем ближе к началу списка располага-| ется транзакт. При наличии временных узлов каждый входящий транзакт располага-^ ется как последний элемент внутри своего приоритетного класса. 100 После того как перенос из списка будущих в список текущих событий завершен, интерпретатор начинает новый просмотр списка текущих событий. Весь цикл просмотра повторяется. Таким образом интерпретатор продвигает модель во времени. Описанные выше действия интерпретатора сведены в программные блок-схемы. На рис. 16 показана фаза коррекции таймера виртуального времени интерпретатором ОРББ. Фаза просмотра транзактов в списке текущих событий показана на рис. 17. Рис. 16. Фаза коррекции таймера виртуального времени интерпретатором GPSS Диспетчер процессов Pilgrim Рассмотрим механизм планирования событий и модельный таймер Pilgrim. В процессе моделирования образуются управляющие структуры данных. На фазе инициализации для каждого узла в памяти ЭВМ выделяется блок управления узлом kcb. Эти блоки уничтожаются при завершении моделирования. Если в процессе про- Рис. 17. Фаза просмотра транзактов в списке текущих событий гона модели появляется новый актор, то на все время его существования образуется блок управления актором acb. При входе актора в узел возникает блок управления событием ecb, который уничтожается после выхода актора из этого узла. Если актор захватывает какое-то количество единиц ресурса определенного типа, то к нему присоединяется блок управления ресурсом гсЬ с идентификатором этого ресурса. В этом блоке отмечается используемое актором количество единиц. Если ресурс полностью освобожден актором, то гсЬ уничтожается. В действительности acb, ecb и гсЬ не уничтожаются. Они переводятся в соответствующие списки отработанных структур, откуда будут извлечены вновь при возникновении новых акторов и событий. По окончании одного прогона модели все ^Ь, acb, ecb и гсЬ, включая отработанные, будут уничтожены специальной программой — «мусорщиком». Число управляющих структур acb и ecb в любой конкретный момент случайно. Кон- N93(9)2007 фигурация взаимосвязей kcb, acb и ecb так- g же изменяется от события к событию. Ал- * горитм планирования интервала времени | ( t, t + d) между двумя ближайшими события- ¡4 ми в упрощенном виде можно пояснить на < примере фрагмента конкретной конфигурации (рис.18). Видно, что список планируемых событий один, и нет отдельных списков текущих и будущих событий. Кроме того, для обеспечения высокого быстродействия модели список событий является двунаправленным. Актор, вошедший в узел, получает (или уже имеет) информацию о том, в какой следующий узел он должен перейти. При этом образуется ecb, в котором проставляется значение интервала времени задержки актора в этом узле (переменная ct типа float, ct > 0). Все ecb планируемых событий сцеплены в список, где они упорядочены по возрастанию величины ct. События, у которых ct = 0, готовы к своему завершению, если помимо этого выполнены и другие условия. Например, если узел, в который актор должен перейти (узел-приемник), не занят. В узле типа queue (очередь) может произойти только одно событие после того как все акторы покинут очередь. При входе нового актора в пустую очередь будет образован новый ecb. Узел типа serv (обслуживающий прибор) может принять в себя столько акторов, сколько он имеет обслуживающих каналов. Если такому узлу дать возможность приоритетного обслуживания, то более приоритетные акторы будут входить в каналы, вытесняя менее приоритетные в стек (пару ecb ^ acb), который динамически создается для такого узла. После обслуживания приоритетного актора пара ecb ^ acb возвращается в список планируемых ecb с соблюдением его упорядоченности. Очередь на рис. 18 содержит три актора, относящихся к ecb 2 — acb3, acb 1и2, а обслуживающий прибор, имеющий два канала (nc = 2), содержит два актора с приоритетами pr = 4 и pr = 3, в то время как в стек 101 Ne3(9) 2007 pr = 4 acb 5 Акторы tcb 4 и tcb 5 в каналах узла serv (kcb 2) ct>0 U kn st ecb 6 ct>0 t ' 1 rc ec i 1 1 serv , ct>0 * st ecb 5 kn w kcb 2 se TT- 1 re pr = 2 acb 4 st ecb 4 kn ecb 9 ec cb 8 ct>0_ pr = 2 Л < st ecb3 kn nb = &(kcb 2) г 1 rc Планируемый переход ou et > 0_Jr ecb 8 St» acb 7 tc = 0 I г I rc pr = 0 ecb 7 st acb 6 acb3 < st i » ecb 2 kn > i ev kcb 1 acb 1 S ¡ 3 о <u о « 0 8 SI « 1 § g j= с CL fi со « ■е os ï сз ~Г tc pr = 0 I < st ecb 1 kn chbeg reb 1 ch qc rcb2 Начало списка событий acb 2 Фрагмент очереди: узел queue - kcb 1 i<->i Список планируемых событий <-* Узлы: serv, queue и др. Стек прерванных неприоритетных акторов Рис. 18. Структуры данных диспетчера Pilgrim вытеснены три актора с прерыванием их обслуживания (pr = 2, pr = 2 и pr = 0). Диспетчер процессов Pilgrim имеет в своем составе специальную функцию — координатор network. Координатор использует следующие правила для определения актора, который надо перевести из одного узла в другой, а также для завершения соответствующего события и активизации на время d одной из двух возможных непрерывных компонент модели, которые предназначены для имитации процессов во внешней среде объекта. Например, первый процесс — атмосферное распространение загрязняющих веществ, а второй — естественный смыв с подстилающей поверхности осевших на нее загрязняющих веществ. Эти компоненты определяются как операнды network. В моделях в результате неправильно проведенного структурного анализа моделируемой системы может возникнуть блокировка. Диспетчер Pilgrim предоставляет специальные приемы для борьбы с этим явлением. Разработчик моделей имеет возможность автоматически проверять состояние интересующих его узлов и в случае необходимости разблокировать их. На этом можно закончить краткое сравнение свойств и возможностей систем имитационного моделирования GPSS World и Actor Pilgrim. В заключение приведены основные 1G2 N93(9)2007 Таблица 4 § Основные характеристики систем имитационного моделирования ¡s GPSS World и Actor Pilgrim i № п/п Свойство или способность Система моделирования GPSS World Actor Pilgrim 1. Количество операторов, реализующих блоки или узлы 53 16 2. Число операторов, не являющихся блоками или узлами 16 16 3. Методы или аналоги моделирования непрерывных процессов Рунге-Кутта-Фехлберга • как объекты; • внешняя среда 4. Основной функциональный элемент в схеме модели блок (программа) узел (процесс) 5. Основная динамическая единица имитационной модели транзакт (таблица) актор (программа) 6. Основной формат числа 32-разрядное целое 64-разрядное плавающее 7. Количество независимых датчиков псевдослучайных чисел в модели 7 в каждом узле есть свой датчик 8. Используемые законы распределения случайных величин любые любые 9. Моделирование в пространстве с привязкой к геокоординатам нет есть 10. Финансовая динамика: проводки и корреспонденция счетов нет есть 11. Динамическая работа с ресурсами произвольной мощности нет есть 12. Возможность «послойного» структурного анализа модели нет есть 13. Графический конструктор моделей «без программирования» нет два CASE-конструктора 14. Реализация процесса выполнения созданной модели в режиме интерпретации exe-программа типа Win API 15. Необходимость в дополнительном программном обеспечении необходимости нет нужна оболочка MS Visual Studio характеристики систем имитационного моделирования GPSS World и Actor Pilgrim (табл. 4). Кроме рассмотренных выше средств существуют эффективные возможности моделирования пространственной динамики, финансовых процессов, а также развитая система средств имитации работы с произвольными мобильными ресурсами. Послойное моделирование сложного процесса позволяет наблюдать поведение сложной системы в различных разрезах, например, в производственно-технологическом, в финансовом и др. Но это — уже в Actor Pilgrim. ]]></text>
</doc>
