<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/o-yazyke-nachalnogo-obucheniya-parallelnomu-programmirovaniyu]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Городняя Лидия Васильевна]]></item>
    <item type="str"><![CDATA[Боярских Алена Сергеевна]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[О языке начального обучения параллельному программированию]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[ЯЗЫКИ ПАРАЛЛЕЛЬНОГО ПРОГРАММИРОВАНИЯ]]></item>
    <item type="str"><![CDATA[НАЧАЛЬНОЕ ОБУЧЕНИЕ ПРОГРАММИРОВАНИЮ]]></item>
    <item type="str"><![CDATA[ПАРАДИГМЫ ПРОГРАММИРОВАНИЯ]]></item>
    <item type="str"><![CDATA[РОБИК]]></item>
  </keywords>
  <annotation auto="true" type="str" verify="true"><![CDATA[Рассматривается парадигма параллельного программирования в свете возрастания актуальности обучения параллельному программированию, что требует развития языково-информационной поддержки введения в программирование. Предлагается проект языка начального обучения параллельному программированию Кубик, продолжающий идеи языка начального обучения программированию Робик.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Рассматривается парадигма параллельного программирования в свете возрастания актуальности обучения параллельному программированию, что требует развития языково-информационной поддержки введения в программирование. Предлагается проект языка начального обучения параллельному программированию Кубик, продолжающий идеи языка начального обучения программированию Робик. Ключевые слова: языки параллельного программирования, начальное обучение программированию, парадигмы программирования, Робик, LSL. Введение Мир программирования и его техническая основа претерпели значительные изменения за последние десятилетия. В середине 1970-х гг. активное исследование методов параллельного программирования рассматривалось как ведущее направление преодоления кризиса технологии программирования. В настоящее время рост интереса к параллельному программированию связан с переходом к массовому производству многоядерных архитектур. Прежде всего следует отметить бурное развитие суперкомпьютеров и распределенных информационных систем, а также переход на многоядерные процессоры и широкое распространение графических процессоров. Возрастание актуальности обучения параллельному программированию требует развития языково-информационной поддержки раннего введения в программирование, дающего ознакомление с основными проблемами организации параллельных процессов и активной практикой последовательного программирования [1]. Решению этой проблемы посвящен проект языка начального обучения параллельному программированию Кубик, при разработке которого учтены основные факторы успеха наиболее известных учебных языков программирования, таких как Basic, Pascal, Logo, Grow, с целью проявления их специфики и типовых свойств. Особое внимание уделено наследованию методически обусловленного введения программистских понятий в языке начального обучения программированию Робик 1. Тщательная проработка понятий в этом языке может служить базисом для любой профориентации учебного процесса по информатике, программированию и информационным технологиям. Ведущее понятие языка Робик - «исполнитель» подразумевает, что исполнителей может быть много, и они могут обладать разными системами команд. Такое понимание допускает естественное развитие в направлении моделирования асинхронных процессов, реализация которых для учебных целей может быть выполнена средствами языков нового поколения, таких как C#, F#, LSL. * Работа выполнена при поддержке РФФИ (проект № 08-01-00899-а.). 1 Звенигородский Г. А. Первые уроки программирования. URL: http://green.iis.nsk.su/sop/html/2007-2008/ zveni-gorodski.rar ISSN 1818-7900. Вестник НГУ. Серия: Информационные технологии. 2012. Том 10, выпуск 2 © Л. В. Городняя, А. С. Боярских, 2012 Данная статья представляет проектные решения, принятые при реализации макетного образца языка Кубик, являющегося расширением языка Робик на проблемы обучения школьников параллельному программированию. Учебные языки программирования Обычно учебные языки программирования обеспечивают быстрое получение первых успехов и способствуют быстрому переходу от абстрактной алгоритмизации к практике отладки программ на производственных системах. Языки XXI в., как правило, поддерживают основные парадигмы программирования на ЯВУ - императивное, функциональное, логическое и объектно-ориентированное, что позволяет программировать решения задач с разным уровнем изученности в рамках единой языковой обстановки и получать навыки работы на всех фазах полного жизненного цикла программ. Учебные программы в языке начального обучения параллельному программированию (ЯНОПП) строятся из выполняемых разными исполнителями действий. Выполнение действий может быть обусловлено ожиданием времени (пауза) или другого сигнала, предикатом или вероятностью срабатывания. Последнее означает, что при исполнении ведется учет частоты выполнения вероятностных действий как в системах для разработки компьютерных игр. Можно объявить планируемую длительность выполнения действий или пауз между ними. При организации сложных данных и процессов используются общие структуры или средства композиции, такие как списки и множества, обеспечивающие представление отношений «после» и «одновременно». Все это выводит учебное программирование за пределы основных парадигм программирования. Постановка учебной задачи для представления параллельной программы на языке Кубик формулируется в терминах задания исполнителю или группе исполнителей, действующих в определенной обстановке. Решение задачи может быть получено как оперированием, позволяющим наблюдать взаимодействующие параллельные процессы, так и программированием, дающим отлаживать композиции из корректно взаимодействующих процессов. Кроме общих команд по изменению обстановки, объектов, статуса исполнителя и меню допустимых команд исполнителя, в языке Кубик имеются специальные команды для изменения системы команд исполнителя и обстановки, а также для синхронизации процессов в терминах барьеров - событий, происходящих в разных процессах одновременно. Языки параллельного программирования Независимая разработка специализированных языков параллельного программирования и языков управления процессами дала ряд интересных идей по представлению и масштабированию параллельных вычислений, с которыми можно ознакомиться в материалах о языках APL, Sisal, БАРС и др. Исторически первое предложение по организации языка высокого уровня для параллельных вычислений было сделано в 1962 г. Айверсоном в виде языка APL. Был предложен интересный механизм реализации многомерных векторов, на базе которого любое определение функции над скалярами автоматически распространяется на произвольные структуры данных из однотипных скаляров. Довольно известен язык функционального программирования Sisal (Streams and Iterations in a Single Assignment Language). Отметим, что функциональные языки способствуют разработке корректных параллельных программ. Sisal-программа представляет собой набор функций, допускающих частичное применение, т. е. вычисление при неполном наборе аргументов. В таком случае по исходному определению функции строятся его проекции, зависящие от остальных аргументов, что позволяет оперативно использовать эффекты смешанных вычислений и определять специальные оптимизации программ, связанные с разнообразием используемых конструкций и реализационных вариантов параллельных вычислений. Основные идеи языков параллельного программирования APL и VAL (предшественника языка Sisal) были развиты и обогащены в языке БАРС в трех направлениях: 1) в качестве базовой структуры данных были выбраны мультимножества (размеченные множества с кратностью элементов); 2) описание элементов памяти могло сопровождаться предписанием дисциплины доступа к памяти; 3) средства управления асинхронными процессами включали механизм синхросетей, координирующих работу независимо созданных функциональных фрагментов. Процедуры в языке БАРС приспособлены к варьированию дисциплины доступа к данным и схемы управления процессами обработки комплексов. Синхросети позволяют независимые описания процессов связывать в терминах разметки или барьеров. Узлы с одинаковой разметкой срабатывают одновременно. Полное представление об асинхронных процессах, их эффективности и проблемах организации дают работы по сетям Петри, освещающие и тонкости определения подклассов сетей, для которых алгоритмически разрешимы ряд известных проблем, обуславливающих сложность параллельного программирования. В этом плане представляет интерес эксперимент по развитию теоретико-множественной семантики языка Setl, в котором весьма общее построение формул с кванторами над множествами погружено в обычную схему последовательного управления процессами. Реализация языка Setl характеризуется богатым полиморфизмом. Для представления множеств используется около двадцати разных структур данных, выбор которых осуществляется системой программирования в зависимости от динамики операций над множествами. В результате программируемые функции не могут зависеть от реализационной структуры данных. В практике управления процессами используется понимание команд как позиций независимого порождения процессов. Такое понимание естественно согласуется с идеями теории множеств о независимости элементов множеств. Не исключено, что принятая в языке Sisal схема управления процессами может успешно заменить фортрановский стиль, принятый в языке Setl. Некоторые идеи языков параллельного программирования учтены при разработке языка Кубик (язык низкого уровня), предназначенного для начального обучения школьников параллельному программированию. Возможна производственная реализация языка Кубик с применением новых универсальных языков сверхвысокого уровня (таких как Python, Haskell, C#, F# и т. п.), абстрагирование данных и процессов в которых приспособлено к гибкому и строгому структурированию, удобному для доказательных построений. Синтаксис языка Кубик Основные понятия ЯНОПП Кубик - схемы программ, образующие программу действия, вычисления и данные - отчасти описаны в табл. 1-4. Таблица 1 Основные схемы программ на языке Кубик Синтаксис Примечания СХЕМЫ Схема определяет варианты управления действиями в многопоточной программе Пр = [ Общая память ] [ (Синхронизатор ... ) ] Поток ... Программа - это комплекс из потоков, выполняющийся в общей памяти - заданном контексте, возможно с выделением значимых барьеров-синхронизаторов. В последнем случае невыделенные барьеры стираются из потоков. По умолчанию общая память содержит систему программирования на входном языке. Должен существовать контекст, в котором синхронизация потоков корректна Общая память = Контекст Хранилище общедоступных данных многопоточной программы Синхронизатор = Барьер Значимые барьеры Продолжение табл. 1 Синтаксис Примечания Поток = Имя = { [ Барьер : ] Фрагмент ... } Поток - это комплекс из фрагментов, возможно синхронизованных по одноименным барьерам с другими потоками. Должен существовать контекст, в котором выполнимы все действия потока Фрагмент = Слой Слой состоит из действий, порядок выполнения которых не задан | Линия Линия задает порядок выполнения действий как порядок их вхождения | Обход Обход дает возможность определять ветвящиеся процессы | Включение Включение обеспечивает использование общих фрагментов потока или схемы | Назначение Назначение позволяет распределять работу программы | Итерация Итерация обеспечивает многократность выполнения потока | Схема [ ( { Имя | Фрагмент | Исполнитель } ... )] Схема предназначена для параметризации барьеров, фрагментов и исполнителей потока Схема = [СХЕМА] [(Параметр ... )] Поток Поток может быть параметризован как схема, ее параметры подставляются на этапе компиляции. Это макроподстановка, ограниченная синтаксическим контролем. Можно делать общие схемы для разных исполнителей и контекстов Слой = [ Дир ( [ , ] Дир ) ...] Слой состоит из действий = директив, порядок выполнения которых не задан Линия = ( Дир ( [ ; ] Дир ) ... ) Линия задает порядок выполнения действий как порядок их вхождения Обход = ЕСЛИ Выр ТО Дир | КРОМЕ Выр ТО Дир | [ВОЗМОЖНО] Выр % Дир Обход дает возможность определять ветвящиеся процессы с помощью условий или вероятности срабатывания директив. Выносится в отдельный поток, а заданное выражением условие срабатывания считается вычисленным лишь при выборе директивы. Тогда при невыполнении условия недостижимы барьеры, расположенные в директиве Итерация = ПОВТОР [ Выр РАЗ] Фрагмент | ПОКА [ Выр ] ПОВТОР Фрагмент | ПОВТОР Фрагмент ПОКА [ Выр ] Возможна неограниченная итерация в расчете, что ее ограничат смежные потоки с помощью синхронизации Включение = Схема | Схема ( {Имя | Фрагмент | Исполнитель }) | Функция ( Арг ... ) Включение обеспечивает использование общих фрагментов потока, задаваемых непосредственно схемой или с подстановкой имен синхронизующих барьеров, фрагментов и исполнителей, а также вызовы функций, включаемых в динамике Окончание табл. 1 Синтаксис Примечания Назначение = [ Исполнитель ! ] Фрагмент Назначение позволяет распределять фрагменты программы по исполнителям, знающим свой мир - контекст и систему команд. По умолчанию Исполнитель - это система программирования, а команды - директивы входного языка программирования Таблица 2 Виды действий, образующих программы на языке Кубик Действие Примечание Дир = [РЕЗУЛЬТАТ] Выр Директивы задают точки и методы взаимодействия фрагментов программы друг с другом, включая систему программирования. Простейшее действие - это вычисление выражения. Мир любого исполнителя содержит память для текущего результата его работы | выр [Фильтр] ^ структура Реорганизация заданной выражением структуры данных перемещает их элементы из левой части в правую с учетом определения структуры данных правой части и фильтра, выделяющего элементы из левой части. Результат - пара из полученной структуры и остатка преобразуемой | Фрагмент Действие может быть укрупненным, но не слишком сложным для отладки. Во фрагменте допустимо однократное присваивание | Имя = Выр | Имя = [ФУНКЦИЯ ] ( Парам .. ) Дир | Имя = [СХЕМА] [(Барьер ... ) ] Поток Действие может уточнять контекст программы, заданием новых ассоциаций с именами значений, функций или схем. Все имена уникальны, т. е. нет локализации по блокам. Фактически это присваивания, но с сохранением старых значений, которые можно достать специальными функциями Таблица 3 Основные методы представления вычислений в языке Кубик Вычисления Примечание Выр = Имя | Мир исполнителя . Имя Выражения задают способы получения значений по заданным данным и средствам их обработки. Значение имени = переменная или константа, может быть задана составным именем, дающим доступ к элементам чужого контекста | Значение Константа - непосредственно представимое данное типа чисел или строк Окончание табл. 3 Вычисления Примечание | ( Арг Операция Арг ) Результат бинарной операции. Имеются просачиваемые операции относительно структуры аргументов | Просачиваемые операции # ! + - * / в зависимости от реализации | ( Арг Фильтр ) Результат фильтрации - исчезает из Арг. Допустимо просачивание фильтра относительно структуры аргументов. Значение - пара из результата и остатка | Функция [( Арг ... )] Применение функции к ее аргументам. Допустимо просачивание функций относительно структуры аргументов. Аргументы - вычислимые выражения или функции | Структура ( Арг ... ) | Структура [ Арг ... ] Выборка-вырезка из структуры | Включение Включение фрагментов схемы = CALL Функция = Имя | Операция | [ФУНКЦИЯ] (Параметр .) Дир | Схема | Структура ( Функция ) Представление функции может быть именем, операцией, параметризованной директивой или схемой. Структура из функций дает структуру из результатов их применения к одним и тем же аргументам Фильтр = ? Операция Арг | Структура ( Фильтр ... ) Превращение бинарной операции в фильтр. Структура из фильтров дает структуру из результатов их применения к одному и тому же аргументу Таблица 4 Типичные виды данных в языке Кубик Данные Непосредственно представимые значения Значение = Число | Текст | Структура | Имя : | @ Дир | ИНОГДА Числа Строки Структуры данных Имена в качестве данных Рецепт = отложенное исполнение фрагмента программы = замыкание, т. е. пара из Дир и Контекста. Барьеры в рецептах не действуют Структура = [ОЧЕРЕДЬ] ((Выр [{ ; | , }] ) ...) Очереди, элементы которых доступны последовательно и размещены рассредоточено, новые добавляются в хвост очереди | [ВЕКТОР] [[ (Индекс.): ] (Выр [{ ; | , }] )...] Векторы с обычным индексированием элементов, размещенных в соседних регистрах В том и другом случае последовательность вычисления элементов не обязана совпадать с последовательностью размещения. ; символизирует последовательность, , - произвольный порядок Окончание табл. 4 Данные Непосредственно представимые значения Исполнитель = Имя | Мир исполнителя # Имя ... Исполнитель имеет заранее известное имя или получает имя, связывающее его с доступным ему миром исполнителя. Можно задать несколько исполнителей, работающих в общем мире Мир исполнителя = Контекст Контекст = Имя | [ (Имя = ( { Значение | Функция Контекст задан именем или структурой данных, связывающей имена со значениями, определениями функций или схемами управления | Схема } ). ] Сост имя = Имя | Контекст . Имя Примеры задач с решениями Задача языка Кубик - дать средства моделирования примеров из жизни, а также создания простых игр, на которых можно показать и пронаблюдать модели аппаратных решений и связанные с их применением явления на уровне автоматов, описанных в книге [2]. Программа решения строится на основе идей и конструкций учебных языков Grow и Робик с учетом современных технологий разработки новых информационных систем. Используются идеи олимпиадных задач и учебных примеров из школьных и факультативных курсов информатики. Отдельные приемы программирования на языке Кубик показаны ниже. Олимпиадная задача для младших школьников (3 котлеты на 2-х сковородах) • Для обжарки одной стороны котлеты требуется 5 минут. • Имеется 2 сковороды, на них надо как можно скорее поджарить 3 котлеты. • Примечание: на Intel-семинаре в Москве упоминалась как пример немасштабируемого алгоритма. • Надо предложить и ясно записать масштабируемое решение. 3 котлеты на 2-х сковородах Примечание ОЧЕРЕДЬ жарить = (2 2 2), %% по 2 стороны каждой из 3-х котлет готово =() %% тарелка для готовых котлет в конце строки ; не обязательна ВЕКТОР сковороды [1..2] ПОКА жарить ПОВТОР цикл для любого числа сковород и котлет жарить ^ сковороды %% из жарить два первых элемента %% перемещают на сковороды общая вертикаль выделяет блок ЖДУ 5 %% время сковороды = (сковороды - 1) %>%> одна сторона обжарена «жарки» внутренний цикл: ск [/] = ск [/] - 1 сковороды (? Ф 0 , ? = 0) ^ ( жарить, готово ) %% разделили требующие жарки и готовые %>%> «недожаренные» (= 1) направляются жарить %% «обжаренные (= 0)» - в готово - становятся в очередь - со 2-го витка цикла РЕЗУЛЬТАТ готово %% = (0 0 0) Вводные задачи из книги [2]. Решения первых двух задач показывают, что принципиальную сложность параллельных программ можно маскировать подбором языковых конструкций по внешней сложности сравнимых с изобразительными средствами для представления обычных последовательных программ. 1. Простой торговый автомат (ПТА). Описать поведение автомата, принимающего монету, а потом выдающего шоколадку. ПТА = { Read ( мон ) ; „ Сначала прием монетки, потом выдача шоколадки Print ( шок ) ; ПТА () } 2. Простой торговый автомат с доверием. Автомат допускает выдачу шоколадки до получения монетки - доверяет покупателю. ПТА = { Read (мон) , Print (шок ) , Прием монетки и независимо выдача шоколадки в любом порядке ПТА () } На задачах 3-6 демонстрируется возможность выделения специфичных фрагментов из программ, схемы управления в которых обладают подобием. 3. Простой торговый автомат (учет числа шоколадок в автомате). Автомат может по разным причинам не выдать шоколадку. Описать поведение автомата, сообщающего покупателю об отсутствии товара и возвращающего монету. ПТА_Ш = (N) Число шоколадок в автомате { ЕСЛИ N ТО { Read (мон ) ; Print (шок ); Учет остатка ПТА_Ш (N - 1) } , КРОМЕ N { Print («шоколадок пока нет» ) , „ Возврат монетки Print (мон ), } 4. Простой торговый автомат (подсчет выручки). Описать автомат, выполняющий подсчет выручки. Считаем, что монетоприемник по объему превышает объем возможной выручки. ПТА_М = (M) Выручка { ЕСЛИ N ТО М б { Read (мон ) Монетоприемник вмещает монет больше, чем ; число шоколадок в автомате ? Print (шок) ; Подсчет выручки ПТА_М (N + 1) } 5, 6. Счетчики (выделение специфичных процессов из общей программы) Учет = (1Ч_Шок) { ЕСЛИ 1Ч_Шок ТО Учет ( 1Ч_Шок - 1) } Выручка = ^_Мон) Выручка ( ^Мон + 1) %% зацикливание В программы 7 и 8 вставлены барьеры для возможной синхронизации 7, 8. Взаимодействие процессов. Имеются описания разных счетчиков, контролирующих работу автомата. Синхронизовать действия счетчиков. Расстановка одноименных барьеров представляет одновременность действий. ПТА_Б = %% определение с барьером для синхронизации { Read ( Мон); Print (Шок); Контроль : ПТА_Б } УЧЕТ_Б = (К_Шок) %% определение с барьером для синхронизации {ЕСЛИ ^Шок ТО Контроль: УЧЕТ_Б ( ^Шок - 1) } Программа 9 демонстрирует применение ранее представленных определений в композиции с синхронизацией управления, включая ограничение шагов рекурсии. 9. Определение взаимодействий ПТА_С_УЧЕТОМ = (Ч_Шок) [Контроль] { ПТА_Б , УЧЕТ_ Б (Ч_Шок) } %% общий барьер %>%> N шагов рекурсии В программах 10 и 11 показаны средства использования вероятностно обусловленных действий. 10, 11. Автомат с «заманиванием» ПТА_Б = { Read (Мон); Контроль : Print (Шок); ПТА_Б } ПОДАРОК = { Контроль: ВОЗМОЖНО ИНОГДА % Print («возьми подарок») ; ПОДАРОК} %% иногда = 20% вероятность срабатывания Выручка = ^_Мон) Контроль: Выручка ( ^Мон + 1) В программах 12 и 13 показано, что при определении синхронизации можно управлять областью действия барьера. 12, 13. Варианты взаимодействий. ПТА_УЧЕТ_ВЫР = (Ч_Шок ^Мон) ( Контроль) %% барьер во всех процессах [ ПТА_Б () , УЧЕТ_Б (Ч_Шок ), Выручка ( К_Мон ) ] %% автомат с учетом числа шоколадок и монет ПТА_УЧЕТ_ВЫР = (Ч_Шок 1Ч_Мон) [ Контроль] [ ПТА_Б () , УЧЕТ_Б (К_Шок ) ] %% процессы синхронизованы ПОДАРОК ] %% процесс без барьеров %>%> автомат с учетом шоколадок, возможно заманивание Любые совпадающие фрагменты программы (действия, имена, исполнители) могут быть вынесены из ее записи как параметры, что показано в программах 14-16. 14, 15, 16. Схемы (параметризация действий). С_ПТА = (мон шок) ( Яеа^мон ); Рйп^шок) ; Контроль: С_ПТА ) %% по умолчанию параметры сохраняются С_ПТА (жетон, игрушка) %% явная параметризация отложенных действий (Контроль) [С_ПТА (жетон, игрушка) , ВЫРУЧКА (0) ] При синхронизации рекурсий и циклов достаточно обеспечить конечность одного из совместно выполняемых фрагментов. 17. Управление рекурсией УЧЕТ = ( N ) ЕСЛИ N ТО Контр: УЧЕТ_Б ( N - 1) С_ПТА = (мон шок) ( Read (мон) ; Рпп^,шок) ; Контр: С_ПТА ) (Контр) [Ф_ПТА (жетон, игрушка) , УЧЕТ (4)] %% выдать 4 игрушки В случае низкоуровневого параллельного программирования отсутствие иерархии областей видимости имен компенсируется возможностью переименовывать любые фрагменты, в том числе и барьеры. 18, 19, 20. Переименование барьера. УЧЕТ_Б = ( N b ) ЕСЛИ N ТО b: УЧЕТ_Б ( N - 1) С_ПТА_Б = (мон шок p) (Read (мон) ; Print (шок ); p: С_ПТА_Б ) (Контроль) [ С_ПТА_Б ( жетон, игрушка, Контроль: ) , УЧЕТ ( 4, Контроль: )] %% в автомате 4 игрушки Таким образом, формируется техника параллельного программирования, нацеленная на ортогональное представление схем управления, их композиций и фрагментов, отвечающих за наполнение схем, т. е. за выполнение конкретных вычислений. Может рассматривать- ся как подготовка к фрагментному программированию, разрабатываемому В. Э. Малышки -ным и С. Е. Киреевым (ИВМиМГ). Задачи на параллельные алгоритмы. Механизм просачивания операций со скаляров на структуры данных здесь расширен как просачивание применения операций, функций, фильтров и исполнителей на структуры из функциональных объектов соответствующей категории. 1. Быстрая сортировка: ФУНКЦИЯ QS (Data) [ ЕСЛИ ( size (Data) < 2 TOData ) , КРОМЕ ( size (Data) < 2 (Pivot = Data [ liml (Data)] ; Low, Mid, High ^ Data (?(<, =, <) Pivot ) %% просачивание по списку операций и фильтров. ; ( QS (Low) || Mid || QS (High) ) ) ] 2. Параллельная сортировка: числа A [1 .. 2K]; ПОВТОР П [1 .. K] ! %>%>просачивание по вектору процессоров (ФУНКЦИЯ (i) ЕСЛИ A [ 2*i - 1] =< A [ 2*i] ТО A [ 2*i - 1] ~ A [ 2*i]} ; %% затем ЕСЛИ A [ 2*i] >= A [ 2*i + 1] ТО A [ 2*i] ~ A [ 2*i +1] ) [1 .. K] %% просачивание по индексам ПОКА ВЫПОЛНЯЛОСЬ ( ~ ) Научно-образовательный подход Объективная необходимость повышения качества подготовки специалистов любой области, в том числе и параллельного программирования, обусловлена существенными изменениями в обществе, которые основываются на изменении главной движущей силы его развития. Все больше ученых называют такой силой человеческий капитал. Если исходить из того, что человеческий капитал включает такие категории, как знание, умение, навыки, творчество, опыт [3. Р. 199], то важность повышения качества подготовки специалистов становится очевидной. 1Т-технологии являются реальным ресурсом повышения качества образовательной деятельности. Одним из направлений использования 1Т-технологий для усовершенствования учебного процесса является разработка и внедрение технологий дистанционного обучения, которые играют существенную роль как при очной, так при заочной формах обучения и обеспечивают самостоятельную работу студентов. Недостаток квалифицированных специалистов в настоящее время является одним из главных факторов, сдерживающих развитие отечественного суперкомпьютинга. На текущий момент отрасль испытывает острую нехватку инженеров и научных сотрудников, способных разрабатывать сложные массивно-параллельные программные решения и проводить на их базе научно-практические исследования различной направленности. В будущем доступность и уровень компетенций такого рода специалистов во многом будет определять возможность и экономическую эффективность применения вычислительных комплексов в науке и промышленности. В настоящее время в России проводятся летние и зимние школы, имеются учебные программы, предоставляющие компетенции в области параллельного программирования для студентов рамках вузов. Молодежные школы направлены на изучение современных технологий высокопроизводительных вычислений и возможностей их практического применения для решения актуальных задач науки и техники. Участники школы отбираются на конкурсной основе из числа студентов старших курсов, магистрантов, аспирантов и молодых специалистов вузов России. Московский государственный университет им. М. В. Ломоносова при поддержке Суперкомпьютерного консорциума университетов России объявил о проведении молодежной летней школы «Разработка параллельных приложений для петафлопсных вычислительных систем». Всероссийская научная школа для молодежи «Параллельное программирование» была проведена в два этапа: летняя сессия школы - «Суперкомпьютерное моделирование и визуализация в научных исследованиях» - прошла в МГУ; осенняя сессия школы - «Суперкомпьютерные технологии и высокопроизводительные вычисления в образовании, науке и промышленности» - прошла на базе ННГУ им Н. И. Лобачевского. Серьезная сертификационная программа Intel Programming Professional разработана специалистами корпорации в сотрудничестве с университетами России, чтобы помочь профессиональным разработчикам и начинающим специалистам грамотно и рационально применять современные инструменты и методы параллельного программирования и программирования для мобильных устройств. Привлечение большого числа участников в программу возложено на Национальный открытый университет ИНТУИТ. Курсы разработаны сотрудниками Intel совместно с преподавателями лабораторий Нижегородского, Санкт-Петербургского и Новосибирского государственных университетов (ННГУ, СПбГУ, НГУ). Восемь созданных на данный момент образовательных курсов имеют похожую структуру: лекционные занятия, практика и итоговое тестирование. Немало и других коммерческих IT-компаний открывают обучающие курсы и проводят тренинги по подготовке специалистов высокопроизводительного программирования. Однако многих стать участником такого рода образовательного мероприятия останавливает локальность их проведения. Мобильность обучения и безграничность в географическом плане могут обеспечить инновационные виртуальные школы, обучающие курсы по программированию. Полный спектр мероприятий научно-образовательного плана (молодежные школы, семинары, конференции, исследования моделей и парадигм параллелизма) поддержан в сфере влияния НГУ совместно с фирмами-производителями многопроцессорного оборудования (Intel, HP, IBM и др.) и институтами СО РАН (ИВМиМГ, ИВТ, ИСИ). Для поколения студентов, так называемых «digital natives» [4] поколения Y и Z, виртуальные методы обучения и Web 2.0 не являются чем-то новым, а скорее - повседневным вне учебного заведения. Оптимальное обучение этих учащихся без интерактивных коммуникаций в виртуальном пространстве уже немыслимо. За последние десять лет резко вырос уровень использования Интернета для осуществления учебного процесса, и первоначальная формула успешной интеграции интернет-услуг в образовательную практику претерпела существенные изменения в контексте развития новых технологий, включающих: • разработанный преподавателем контент, в том числе учебные планы, заметки, презентации и т. д.; • предпакетный цифровой контент, в том числе издательские цифровые ресурсы; • онлайн-аттестацию, проведение тестирований, опросов и т. д.; • асинхронные онлайн-форумы для взаимодействия между учащимися; • создание и обмен информацией по отдельным учебным приложениям и инструментам, таким как системы оценки, адаптивные кураторы, вики и т. д.; • обеспечение доступа ко всему вышеперечисленному на основе лицензионной схемы. С точки зрения лицензирования учебные платформы подразделяются на платформы на основе свободного программного обеспечения (open source platform) и коммерческие платформы (commercialplatform). Платформу на основе свободного ПО можно использовать, копировать, видоизменять и распространять с минимальными лицензионными ограничениями. Наиболее распространенными примерами являются платформы Moodle, SAKAI и OLAT. На- чинается освоение образовательного потенциала виртуального пространства, более полно воздействующего на каналы восприятия информации человеком. Виртуальная обучающая система Современные учебные платформы используют распределенные учебные ресурсы и инструменты, позволяющие преподавателям и учащимся выстраивать учебную деятельность, применяя разнообразные устройства в виртуальном пространстве. Преимущества использования инновационных учебных платформ заключаются в следующем. Улучшение организации обучения с использованием навыков в области ИКТ. Учебная платформа может упростить процесс создания, накопления и обмена информацией между учителями, учащимися, администраторами и родителями. Преподаватели смогут проанализировать реакцию аудитории, поскольку устройства коммуникации обеспечат им обратную связь. Расширение возможностей обучения дома. Пользуясь цифровым контентом и учебными платформами, преподаватель и обучаемый не ограничены временными и пространственными рамками. Интересен опыт Республики Корея, где в 2007 г. была запущена программа по предоставлению всем жителям страны электронной услуги «Учебная система кибердом». Учебная система кибердом включает LMS, которая соединена с другими системами поддержки, такими как система оценки, система консультирования, киберсообщество и т. д. Обычно учащиеся самостоятельно обучаются на базе учебной платформы, используют программу самотестирования, или обращаются за помощью к киберучителю в случае возникновения вопросов. Развитие персонифицированной учебной среды. Эффективное использование учебных платформ содействует расширению возможностей в области самостоятельного и персонифицированного обучения. Учащиеся могут работать в удобном для них темпе и стиле в процессе формирования навыков командной работы и взаимодействия. Примечательно, что самостоятельное обучение может иметь место не только в учебном заведении, но и дома (London Knowledge Lab, 2010). Расширение возможностей сотрудничества и взаимодействия. Предоставляемые учебными платформами инструменты для сотрудничества (такие как дискуссионные форумы, вики и социальные сети) могут быть объединены с инструментами и услугами из обширного пространства Интернета и реорганизованы (перемешаны) в каждом классе учителем в зависимости от намеченного учебного результата. Реализация обучающей системы параллельному программированию на базе языка Кубик разрабатывается в модульно объектно-ориентированной динамической среде с интегрированным приложением виртуального «3Б-мира Second Life®». Second Life® - это трехмерный виртуальный мир с элементами социальной сети, его пользователи могут создавать трехмерные фигуры, управлять их поведением, общаться с другими пользователями с помощью текстовых и голосовых инструментов. Дополнительные возможности курсов в Second Life®, в первую очередь, заключаются в предоставлении виртуального пространства для встреч студентов, временно находящихся для обучения или стажировки за рубежом, и потому не способными встретиться для обсуждения проблем и обмена опытом. Но возможности Second Life® в обучении не ограничиваются виртуализацией совместной работы в группах географически удаленных друг от друга людей. Виртуальные миры предлагают и другие важные преимущества: симуляторы, деловую информацию и контакты, а также доступ к другим учебным заведениям. Каждая встреча в Second Life® - всегда испытание в полевых условиях и экскурсия одновременно, а богатство виртуальных предложений в этом ориентированном почти исключительно на социальное взаимодействие мира в мире явилось одной из основных причин выбора Second life® в качестве платформы для обучения. Формирование навыком и умений обеспечивается на практических заданиях, реализация которых проходит в среде Second Life®. В среде Second life® студенты смогут через опери- рование трехмерными объектами изучать параллельные процессы. Second Life® включает средство для того, чтобы задавать сценарии в пределах существующих объектов. Для проведения практических занятий допроизводственного обучения старшеклассников, при которых основное внимание уделяется изучению базовых моделей параллельных вычислений, навыков программирования, отладки и оптимизации параллельных алгоритмов, будет уместно изучение моделей параллелизма, представленных на языке Linden Scripting Language (LSL). LSL - скриптовый язык программирования, используемый при создании контента резидентами (пользователями) виртуального мира Second Life, созданного компанией Linden Lab. С помощью LSL-скрипов можно управлять поведением объектов виртуального мира. LSL позволяет объектам взаимодействовать с миром Second life и Интернетом посредством электронной почты, XML-RPC и HTTP-запросов. Внешне LSL похож на язык C без переключателей и иерархических структур данных. Программы на LSL описываются в терминах динамики состояний. Начальное состояние, в котором объявляются и описываются все события, задается функцией default {событие 1 {} событие2 {} событие {}}. Пользователь может определять свои состояния с помощью функции state состояние 1 {событие 1 {} событие2 {} событие {}}. Вызов любого из объявленных и описанных состояний может быть произведен из любого места в программе, описанной в терминах обработки событиях. Используются обычные типы данных integer, float, string. Кроме того, используется тип данных key для представления и хранения уникальных ключей, идентифицирующих сетевой доступ, тип данных vector - для хранения координат или схожих данных в виде <x, y, z>, тип данных rotation - для хранения угловых параметров или схожих данных в виде <x, y, z, s> и смешанный тип данных list, объединяющий понятия структуры и массива. Можно хранить списки любых типов данных в любом порядке. Примеры записи значений переменных разных типов: key - "a822ff2b-ff02-461d-b45d-dcd10a2de0c2" vector - < 0.35, 1.456, 234.23 > rotation - < 0.35, 1.456, 234.23, 12.3 > list - [1234567, "stroka", "a822ff2b-ff02-461d-b45d-dcd10a2de0c2", < 0.35, 1.456, 234.23, 12.3 >, < 0.35, 1.456, 234.23 >]. Организована служба Errors, дающая по специальному каналу DEBUG_CHANNEL сообщения об ошибках, происходящих в работе программы. В языке LSL имеется большое количество библиотек для разного рода взаимодействий изображаемых объектов с объектами и пользователями. LSL обеспечивает ряд функций для того, чтобы связать и управлять наборами примитивных объектов, иногда называемых «link_sets». Примитивные объекты, которые соединены, будут вести себя как единый сконструированный объект. Объекты могут быть настроены так, чтобы общаться друг с другом и обмениваться определенной информацией между собой. Заключение Представлен проект языка низкого уровня Кубик, предназначенный для начального ознакомления с проблемами параллельного программирования и организации взаимодействующих процессов в программистских факультативах для старшеклассников и студентов младших курсов. Для обучения старшеклассников и студентов нужен еще язык высокого уровня, поддерживающий типизацию схем управления вычислениями. Проблема и пути ее решения обсуждались на ряде конференций «Научный сервис в сети Интернет» (Москва - Новороссийск - Абрау), и научно-исследовательских семинаров в Новосибирске. ]]></text>
</doc>
