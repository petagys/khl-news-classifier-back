<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/testirovanie-konformnosti-na-osnove-sootvetstviya-sostoyaniy]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Бурдонов И.Б.]]></item>
    <item type="str"><![CDATA[Косачев А.С.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Тестирование конформности на основе соответствия состояний]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[ТЕСТИРОВАНИЕ СООТВЕТСТВИЯ (КОНФОРМНОСТИ) РЕАЛИЗАЦИИ ТРЕБОВАНИЯМ СПЕЦИФИКАЦИИ]]></item>
    <item type="str"><![CDATA[БЕЗОПАСНОЕ ТЕСТИРОВАНИЕ]]></item>
  </keywords>
  <annotation auto="true" type="str" verify="true"><![CDATA[Статья посвящена тестированию соответствия (конформности) реализации требованиям спецификации. Идея безопасного тестирования, предложенная авторами для конформности, основанной на трассах наблюдений, распространяется на случай (слабой) симуляции конформности, основанной на соответствии состояний реализации и спецификации. Строится теория безопасной симуляции и ее тестирования. Предлагаются общий алгоритм полного тестирования и его модификация для практического применения, опирающаяся на некоторые ограничения на реализацию и спецификацию.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Бурдонов И.Б., Косачев А. С. {^gor, ко а} @1А'ргаА\ ги Аннотация. Статья посвящена тестированию соответствия (конформности) реализации требованиям спецификации. Идея безопасного тестирования, предложенная авторами для конформности, основанной на трассах наблюдений, распространяется на случай (слабой) симуляции - конформности, основанной на соответствии состояний реализации и спецификации. Строится теория безопасной симуляции и ее тестирования. Предлагаются общий алгоритм полного тестирования и его модификация для практического применения, опирающаяся на некоторые ограничения на реализацию и спецификацию. 1. Введение Тестирование конформности - это проверка в процессе эксперимента соответствия (конформности) реализации требованиям, заданным в виде спецификации. Эго соответствие определяется семантикой тестового взаимодействия, которая описывает возможные тестовые воздействия и возможные наблюдения ответного поведения реализации. Если при тестировании мы можем наблюдать только (внешние) действия, выполняемые реализацией в ответ на тестовые воздействия или отсутствие таких действий (отказ), то конформность определяется на основе трасс наблюдений, то есть последовательностей действий и отказов. Спецификация в этом случае описывает те трассы, которые допускаются в реализации. Тестирование, при котором гарантировано конечное время ожидания наблюдения после тестового воздействия, называется безопасным. Возможны две причины бесконечного ожидания: дивергенция и ненаблюдаемые отказы. Дивергенция - это бесконечное выполнение реализацией внутренних (ненаблюдаемых) действий. Ненаблюдаемый отказ - это отсутствие выполняемых реализацией внешних действий, которое тест не может определить за конечное время1. В обоих случаях тест не может ни продолжить 1 Например, интервал времени между тестовым воздействием и ответным внешним действием ограничен некоторым тайм-аутом. Превышение тайм- тестирование, ни закончить его, так как неизвестно, нужно ли ждать наблюдения или никакого наблюдения не будет. Тестирование, при котором не возникает дивергенции и ненаблюдаемых отказов, называется безопасным. Кроме этого возможно специальное, не регулируемое тестовыми воздействиями, действие реализации, которое называется разрушением. Оно моделирует любое нежелательное поведение системы, в том числе и ее реальное разрушение. Семантика разрушения предполагает, что оно также не должно возникать при безопасном тестировании. Спецификация описывает те ситуации, при которых тестовое воздействие должно быть безопасно в реализации. Соответственно, конформность основана только на безопасном поведении реализации. Конформность, учитывающая безопасность, введена авторами этой статьи в [1,2,3,5]. Кроме конформности, основанной только на трассах наблюдений, в литературе рассматриваются разные виды конформностей, основанных на соответствии состояний реализации и спецификации (обзор см. в [6]). Такие конформности называются симуляциями. Симуляция требует, чтобы правильным было не только наблюдаемое внешнее поведение реализации, но и изменение ее состояний. Все рассматриваемые в литературе симуляции либо не учитывают безопасности тестирования, предполагая отсутствие дивергенции и ненаблюдаемых отказов, либо предполагают возможность прямого наблюдения дивергенции и всех отказов. Также они не учитывают возможность разрушения. В данной статье вводится симуляция, учитывающая безопасность, называемая безопасной симуляцией. Спецификация описывает не только класс конформных ей реализацией, но и гипотезу о безопасности, определяющую более широкий класс реализаций, которые можно безопасно тестировать для проверки конформности. Выбор симуляции в качестве конформности наиболее естественен, когда состояния реализации доступны для их наблюдения. Тестирование, при котором в любой момент времени можно опросить текущее состояние реализации, называется тестированием с открытым состоянием. Задача тестирования - обнаружение ошибок в реализации, понимаемое как несоответствие ее поведения спецификационным требованиям. Тестирование полное, если обнаруживается любая ошибка и не фиксируются «ложные» ошибки. В данной статье рассматривается полное тестирование с открытой состоянием безопасной симуляции. Это рассмотрение проводится как в общетеоретическом, так и в практическом планах. Теоретическое полное тестирование должно обнаруживать любую ошибку за конечное время, но при отсутствии ошибок может продолжаться бесконечно. Причины бесконечного тестирования - это бесконечность аута при ожидании внешних действий означает наблюдение отказа. При отсутствии такого рода ограничений отказ ненаблюдаем. 184 реализации и/или спецификации, а также неограниченный недетерминизм поведения реализации. При некоторых ограничениях возможно построение полных тестов, в любом случае завершающих свою работу за конечное время. Такие тесты уже можно использовать на практике. 2-ой раздел статьи содержит основные положения теории конформности: семантика взаимодействия и безопасное тестирование, математическая модель реализации и спецификации, определение симуляции, гипотеза о безопасности и определение безопасной симуляции. В 3-ем разделе рассматривается связь безопасной симуляции с трассовой конформностью. 4-ый раздел посвящен теоретическому тестированию: определяется полнота тестирования, описывается общий алгоритм тестирования и вводится достаточное условие его полноты. 5-ый раздел посвящен практическому тестированию: определяются ограничения на реализацию и спецификацию, позволяющие так модифицировать общий алгоритм тестирования, чтобы он стал конечным и полным, а также предлагается более практический алгоритм, состоящий из алгоритма обхода реализации и последующей верификации симуляции, приводится пример верификации симуляции. 2. Теория конформности 2.1. Семантика взаимодействия и безопасное тестирование Данная работа развивает теорию тестирования конформности, изложенную в [1,2,3,5]. Тестирование понимается как проверка в процессе эксперимента соответствия (конформности) реализации требованиям, заданным в виде спецификации. Семантика тестового взаимодействия определяется в терминах действий и кнопок. Действие - это внешнее действие тестируемой системы (реализации), которое может наблюдаться при тестировании. Множество внешних действий называется алфавитом действий и обозначается Ь. Кнопка - это подмножество РсЬ; нажатие кнопки Р моделирует тестовое воздействие на реализацию, сводящееся к разрешению выполнять любое действие из Р. При нажатии кнопки Р наблюдается либо действие аеР, выполняемое реализацией, либо (для некоторых кнопок) отсутствие таких действий, называемое отказом Р. Семантика взаимодействия задается алфавитом Ь и двумя наборами кнопок: с наблюдением соответствующих отказов - семейство ИсП (Ь) и без наблюдения отказов - семейство С)сП (Ь). Предполагается, что Кп()=0 и и11ии(2=Ь. Такая семантика называется -семантикой. При нажатии кнопки <2е(), вообще говоря, неизвестно, нужно ли ждать наблюдения или никакого наблюдения не будет, поскольку возник ненаблюдаемый отказ. Тем самым, нельзя ни продолжить тестирование, ни закончить его. Поэтому при правильном взаимодействии с реализацией, в том числе при тестировании, должна быть уверенность, что при нажатии кнопки Q е Q не возникает отказа. Кроме внешних действий реализация может совершать внутренние (ненаблюдаемые) действия, обозначаемые х. Эти действия всегда разрешены. Предполагается, что любая конечная последовательность любых действий совершается за конечное время, а бесконечная - за бесконечное время. Бесконечная последовательность х-действий («зацикливание») называется дивергенцией и обозначается Д. Дивергенция сама по себе не опасна, но при попытке выхода из нее, когда нажимается любая кнопка PeRuQ, неизвестно, нужно ли ждать наблюдения или бесконечно долго будут выполняться только внутренние действия. Эта ситуация аналогична возникновению ненаблюдаемого отказа при нажатии кнопки QeQ: нельзя ни продолжить тестирование, ни закончить его. Поэтому при правильном взаимодействии с реализацией, в том числе при тестировании, следует избегать тестовых воздействий, если в реализации возникла дивергенция. Кроме этого вводится специальное, также не регулируемое кнопками, действие, которое называется разрушением и обозначается у. Оно моделирует любое нежелательное поведение системы, в том числе и ее реальное разрушение. Семантика разрушения предполагает, что оно не должно возникать при правильном взаимодействии с реализацией, в том числе при тестировании. Взаимодействие с реализацией, в том числе тестирование, при котором не возникает ненаблюдаемых отказов, попыток выхода из дивергенции и разрушения, называется безопасным. 2.2. LTS-модель В качестве модели реализации и спецификации используется система помеченных переходов (LTS - Labelled Transition System) - ориентированный граф с выделенной начальной вершиной, дуги которого помечены некоторыми символами. Формально, LTS - это совокупность S=LTS (VS,L, Es, s0), где Vs - непустое множество состояний (вершин графа), L - алфавит внешних действий, EscVsx (Lu{x,y}) xVs -множество переходов (помеченных дуг графа), s0eVs - начальное состояние (начальная вершина графа). Переход из состояния s в состояние s' по действию z обозначается s—z—>s'. Обозначим s—z—у = 3s' s—z—»s ' и s—z| = fs' s—z—»s'. Маршрутом LTS называется последовательность смежных переходов: начало каждого перехода, кроме первого, совпадает с концом предыдущего перехода. Выполнение LTS сводится к выполнению того или иного перехода, определенного в текущем состоянии (начиная с начального состояния) и разрешаемого нажатой кнопкой (х- и у-переходы всегда разрешены)2. Состояние s дивергентно (обозначается sT), если в нем начинается бесконечная цепочка х-переходов (в частности, х-цикл); в противном случае состояние конвергентно (s^). Состояние s стабильно, если из него не выходят х- и у-переходы: s—х | & s—у |. Отказ Р є R порождается стабильным состоянием, из которого нет переходов по действиям из Р: VzePu{x,y} S—z|. Для определения трасс LTS S добавим в каждом ее стабильном состоянии виртуальные петли s—Р—>s, помеченные порождаемыми отказами, и Д-переходы из дивергентных состояний s—Д—В полученной LTS рассмотрим маршруты, не продолжающиеся после Д- и у-переходов. Трассой назовем последовательность ст пометок на переходах такого маршрута с пропуском символов х. Будем обозначать для s,s 'eVs, ueLuRuQufy, Д}, (LuRuQu{у,Д}) *: S=>S ' = S = S ' V 3sx,...,sn S — S ]_-X—2--X—K..--X—^Sn—S , S=(u)=>S ' = 3 S ! , S2 S=>S !-u—»S2=>s', S=CT=>S ' = 3si,...,sn+i s = si=(ui)=>s2...sn=(un)=>sn+i=s ', S=CT=> = 3s' s=ct=>s', s=ctJ = —i(s=ct=>), s after ст = { s ' I s=ct^>s ' }. Запись s=ct=>s ' (или s=>s ) понимается как наличие маршрута, начинающегося в состоянии s (пресостоянии), заканчивающегося в состоянии s ' (постсостоянии) и имеющего трассу ст (или пустую трассу ()). R-трассой будем называть трассу, не содержащую отказов из Q, a R-маршрутом - маршрут с R-трассой. Множество R-трасс, начинающихся в состоянии s, обозначим Т (s). По умолчанию, будем считать, что трасса начинается в начальном состоянии LTS: будем обозначать S after ст = s0 after ст и T(S)=T(s0). 2.3. Слабая симуляция В наших предыдущих работах [1,2,3,5] рассматривалась конформность, основанная только на трассах наблюдений и не учитывающая состояний 2 При параллельной композиции двух LTS, моделирующей взаимодействие, нажатой кнопке для одной LTS соответствует состояние другой LTS, в котором определены переходы по всем действиям, разрешаемым этой кнопкой (при композиции в CCS это противоположные им действия), и только они. реализации и спецификации. В то же время в литературе рассматриваются разные виды конформностей, основанные на соответствии R состояний реализации и спецификации3. Такие конформности называются симуляциями (обзор см. в [6]). Симуляция требует, чтобы каждое наблюдение и, возможное в реализационном состоянии i с постсостоянием i', было возможно в каждом соответствующем ему спецификационном состоянии s, и в спецификации для s и и нашлось бы постсостояние s', соответствующее i '. Разные симуляции отличаются друг от друга, главным образом, отношением к наблюдаемости внутренних действий (т). В данной статье мы исходим из основного допущения о принципиальной ненаблюдаемости т-действий: при тестировании мы не можем различать наличие или отсутствие т-действий как до, так и после внешнего действия (при наблюдении отказа т-действия возможны, очевидно, только до отказа). Этому соответствует слабая симуляция (weak simulation), называемая также наблюдаемой симуляцией (observation simulation). Мы дадим три эквивалентных определения слабой симуляции (0). 1 So=(J=*)3 ! ; i о= (7 =*®i ' 2 So=*flS 1 1 gel/ zeL Рис. 1. Три определения слабой симуляции. 1<\,83 = ЭКсУ1хУ5 (10, Эо) еИ & \/(л_,з)еК \/стеЬ* VI' (:1=ст=>л_' => Эе' з=ст=>з ' & (л_',з')еК). 1<~И83 = ЭКсУ1хУ5 (10, Эо) еИ & \/(л_,з)еК \/иеЬ VI' —т—»л_' => Эе' з=>г ' & (л_',з')еК) & —и—»л_' => Эе' з=(и)=>з ' & |1',з') еИ). I Э = ЭКсУ1хУ5 (1 г,, э о) е И & V (л_, г ) еИ \/иеЬ VI' (:1=(и)=>л_' =^> Эе' з=(и)=>з ' & (л_',з')еК). Соответствие И, для которого выполнены условия слабой симуляции <\, назовем <’ И8-соответствием или просто конформным соответствием. Первые два определения, принадлежащие Милнеру [9,10], эквивалентны. 3 Мнемоника: R - Relation. 188 Лемма 1: <^3 = <2И3. Доказательство. Легко показать, что эти определения эквивалентны даже в более сильном смысле: если И является < -соответствием, то оно же является <2ИЗ-соответствием, и обратно.□ Лемма 2: <^3 = <3из. Доказательство. Поскольку трасса (и)еЬ*, любое < -соответствие является <3ИЗ-соответствием. Обратное, однако, не верно; зато верно следующее утверждение: из существования <3ИЗ-соответствия следует существование, быть может, другого соответствия, которое является как < -соответствием, так и <1из-соответствием. Пусть И - некоторое <3из-соответствие. Пополним его каждой такой парой (1', э), для которой (1, з) е К и :1=>л_ ', и покажем, что полученное соответствие РГ также является <3из-соответствием. Нам надо показать, что для добавленной пары (л_', г) и любого маршрута 1' =(и)=>1' ', где иеЬ, существует б'' такое, что г=(и)=>з & , э") еИ'. Действительно, если ±^>± ' и л_' =(и)=>1 ' ', то 1=(и)^>1' ', а, поскольку И является <3ИЗ-соответствием для I и Б, то для а, з) еК существует в ' ' такое, что з=(и)=>з ' ' & (л_' ', б ' ') е ИсИ.', что и требуется. Теперь докажем основное утверждение индукцией по трассе ст. Для пустой трассы из 11,з) еИ' и :1=>л_' по построению имеем |1',з) еИ' и, очевидно, б =>б. Пусть утверждение верно для трассы ст и докажем его для трассы ст-(и), где иеЬ. Пусть (л_,з)еК и :1=ст-(и)=>л_' '. Тогда существует 1' такое, что :1=ст=>1' и л_' =(и)=>1' '. По предположению шага индукции, Эе' з=ст^>з & (1, з ) е Р.. Поскольку И' является <3ИЗ-соответствием для I и Б, то для И , з ) еР, существует г ' такое, что з'=(и)=>з'' & Наконец, з=ст=>з' и б ' =(и)=>з' влечет з=ст-(и)^>з что и требуется: соответствие РГ является <1из-соответствием для I и Б. 2.4. Отказы В данной статье под наблюдениями понимаются не только внешние действия из Ь, но и наблюдаемые отказы из Ы. Модификация слабой симуляции с отказами выглядит так (изменения по сравнению с П3ИЗ подчеркнуты волнистой линией): 1<4из3 = ЭКсУ1хУ5 |10, Эо) еИ & \/(л_,з)еК \ZueLuR VI' (:1=(и)=>л_' => Эе' з=(и)=>з ' & 11',з' ) еИ). Лемма 3: <4ИЗ с <3из. Доказательство. Отношение <4ws предъявляет больше требований к реализации: требуется верификация не только наблюдаемых действий, но и наблюдаемых отказов. □ На классе реализаций, не имеющих наблюдаемых отказов, эти соответствия совпадают: <4ИЗ = <3из. Заметим, что после отказа ueR не может быть х-действий, то есть маршрут с трассой (и) не может заканчиваться х-переходом, а только виртуальной петлей по отказу i'—u—»i ' и s'—u—»s'. Лемма 4: Отношения < . где к=1-ь4, являются предпорядками (рефлексивны и транзитивны). Доказательство. Для доказательства рефлексивности отношений достаточно взять тождественное соответствие R={ (s,s) |seVs}. Для доказательства транзитивности отношений достаточно взять композицию соответствий R=Ri°R2={ (а, с) | ЭЬ (a,b)eRi & (b,c)eR2}. Если (a,c)eR, то существует b такое, что (a,b)eRi и (b,c)eR2. Если а=(и)=>а', то, поскольку (а, b) е Rb существует b' такое, что b=(u)^>b' & (a',b')eRi. Тогда, поскольку (b,c)eR2, существует с' такое, что с=(и)=>с' & (b ', с' ) е R2. Тогда (а ', с' ) е R, что и требуется. □ 2.5. Безопасность Мы будем рассматривать проверку конформности типа слабой симуляции только при безопасном взаимодействии с реализацией. Состояние s называется безопасным, если в этом состоянии не начинается у-трасса: s=(y)J. При безопасном взаимодействии проходятся только безопасные состояния реализации. Кнопка PeRuQ называется безопасной в состоянии s, если ее можно нажимать при безопасном взаимодействии: состояние s безопасно, конвергентно и нажатие кнопки Р в состоянии s не вызывает ненаблюдаемого отказа или разрушения после действия, разрешаемого кнопкой: Р safe s = s=(y)J & & (PeQ => s=(P)J) & VzeP s=(z,y)J. Будем называть наблюдение u безопасным в состоянии s, если оно разрешается некоторой кнопкой Р (uеРи{ Р}), безопасной в этом состоянии Р safe s; в частности должно быть безопасно состояние s. Внутреннее действие х безопасно в состоянии, если это состояние безопасно. Переход s—u—>s ' безопасен, если действие и (внешнее или внутреннее) безопасно в пресостоянии s этого перехода. Пустой маршрут безопасен, если безопасно его пресостояние, а непустой маршрут безопасен, если каждый его переход безопасен. Состояние безопасно достижимо, если оно является концом безопасного маршрута, начинающегося в начальном состоянии. Теперь мы можем определить модификацию слабой симуляции с отказами и безопасностью. Прежде всего, заметим, что, если начальное состояние спецификации не безопасно, то есть s0=(y)=>, то это разрешает любое поведение реализации, в том числе разрушение с самого начала i0=(y)=>. В этом случае любая реализация конформна спецификации, но некоторые реализации нельзя не только тестировать, но даже запускать на выполнение, поскольку они могут разрушиться с самого начала. Если же s0=(y)J, то начальные состояния должны соответствовать друг другу (i 0, s 0) е R. Далее, при безопасном взаимодействии с реализацией может нажиматься только такая кнопка Р, которая безопасна в текущем состоянии реализации i. Если кнопка Р безопасна в некотором соответствующем i спецификационном состоянии s, то в этом состоянии s спецификация описывает те наблюдения uePu{P}, которые допустимы в конформной реализации после нажатия кнопки Р в состоянии i, и постсостояния s ' спецификации, хотя бы одно из которых должно соответствовать постсостоянию i' реализации. Иными словами, любое наблюдение в реализации после нажатия кнопки Р в состоянии i должно быть и в спецификации после нажатия той же кнопки Р в соответствующем состоянии s при условии, что эта кнопка безопасна в s, и в этом случае постсостоянию i' реализации должно соответствовать хотя бы одно постсостояние S '. Если же кнопка Р опасна в некотором соответствующем i спецификационном состоянии sb то такое состояние si никак не регламентирует поведение реализации после нажатия кнопки Р. Это, однако, не означает, что в состоянии i могут быть любые наблюдения ue Ри { Р} с любыми постсостояниями i ', поскольку наблюдение и может разрешаться той же кнопкой Р в другом спецификационном состоянии s, в котором кнопка Р безопасна, или другой кнопкой, безопасной в том же или другом спецификационном состоянии, соответствующем состоянию i. Для проверки конформности сравниваются наблюдения и постсостояния в реализации и спецификации только после нажатия кнопок, безопасных в них обеих. Модификация слабой симуляции с отказами и безопасностью выглядит так (изменения по сравнению с D4„s подчеркнуты волнистой линией): I<5„sS = BRcVjXVs (so^x)J^ (i0,s0)eR) & V(i,s)eR VP safe i VuePu{ P} Vi' (P safe s & i=(u)=>i' => 3s' s=<u)^>s' & (i',s')eR). Лемма 5: <4ИЗ с <5„s. Доказательство. Отношение <\.,3 предъявляет больше требований к реализации: требуется верификация наблюдений, разрешаемых не только безопасными кнопками. □ На классе реализаций и спецификаций, в которых нет ненаблюдаемых отказов, дивергенции и разрушения (то есть все кнопки безопасны), эти соответствия совпадают: <4ИЗ = <5И3. Лемма 6: Доказательство. Смотри пример на 0. □ X -----к R=<U)h Q={{у}: І! <3ws S II 5 h S І2 <\s S Рис. 2. Соотношение симуляций и Лемма 7: Симуляция <5ИЗ рефлексивна, но не транзитивна. Доказательство. Для доказательства рефлексивности симуляции достаточно взять тождественное соответствие Р= { (б, б) з є У5}. Пример нетранзитивности симуляции на 0. □ X X А о----К В с---- —►f'-ч С о A <5WS В В <5WS С A С Рис. 3. Нетранзитивностъ отношения ^ws. 2.6. Гипотеза о безопасности Поскольку спецификация задана, мы можем проверять по ней условие Р safe s. Но при тестировании (в отличие от аналитической верификации) реализация неизвестна, и судить о безопасности кнопок в состояниях реализации (Р safe i) мы можем только на основании некоторой гипотезы о безопасности. В данной работе такая гипотеза основана на некотором соответствии HcV^Vs состояний реализации и спецификации4. Мы будем 4 Мнемоника: Н - Hypothesis. 192 называть ее Н-гипотезой о безопасности. Она предполагает 1) безопасность начального состояния i0 реализации, если безопасно начальное состояние s о спецификации, 2) безопасность кнопки в состоянии реализации, если она безопасна хотя бы в одном в соответствующем по Н состоянии спецификации. Определим соответствие Н рекурсивно. Начальные состояния i0 и s0 соответствуют друг другу, если они оба безопасны. Также соответствуют друг другу любые два состояния, достижимые из безопасных начальных состояний по пустой трассе. Два состояния i ' и s ' соответствуют друг другу, если они достижимы из соответствующих друг другу состояний i И S по одному и тому же наблюдению и, разрешаемому кнопкой Р, которая безопасна в обоих состояниях i и s. Формально соответствие Н определяется как минимальное соответствие, порождаемое следующими правилами вывода: Vij.i'eV'! Vs,s'eVs VPeRuQ VuePu{P} so=(y)~J & io=(y)~J & io^i & s0^>s □ (i, s ) eH, (i, s ) eH & P safe i & P safe s & i=(u)=>i ' & s=(u)=>s ' □ (i ', s ' ) eH. Соответствие H похоже на соответствие R слабой симуляции <5„s, но имеет три существенных отличия. 1) Начальные состояния i0 и s0 соответствуют друг другу по R, если безопасно состояние s0, а соответствие Н требует безопасности обоих состояний i0 и s0. 2) Постсостоянию i' после наблюдения и, разрешаемому кнопкой Р, которая безопасна в обоих соответствующих состояниях i и s, по R должно соответствовать хотя бы одно постсостояние s ', а по Н - каждое постсостояние. 3) Соответствие Н минимальное, то есть состояния соответствуют друг другу только в том случае, когда они достижимы из безопасных начальных состояний нажатием одних и тех же безопасных кнопок; соответствие R может содержать пары состояний, которые недостижимы таким образом (даже вообще недостижимы из начальных состояний). Кнопку Р будем называть Н-безопасной в реализационном состоянии i, если она безопасна хотя бы в одном соответствующем i спецификационном состоянии s: Р Н-safe i ; 3s (i,s)eH&P safe s. Теперь дадим формальное определение Н-гипотезы: I Н-safe S = (s о=(у> J =S> i0=(y)J) & VPeRuQ (Р Н-safe i => Р safe i). Реализацию, удовлетворяющую Н-гипотезе, будем называть Н-безопасной. Лемма 8: Отношение безопасности E-safe не рефлексивно и не транзитивно. Доказательство. Пример нерефлексивности на 0. Пример нетранзитивности на А Н-т/е В Б Н-т/е С А И-ф С Рис. 5. Нетранзитивностъ отношения безопасности. Если Н-гипотеза выполнена, то либо Н=0, если з„=(у)=>, либо (л_0, &») еН в противном случае. При условии выполнения Н-гипотезы определим маршруты реализации, которые могут быть пройдены при безопасном тестировании (Н-безопасные маршруты), и состояния реализации, которые при этом могут достигаться (Н-достижимые состояния). Маршрут реализации Н-безопасен, если начальное состояние спецификации безопасно (тем самым по Н-гипотезе начальное состояние реализации тоже безопасно) и каждый переход 1—и—>а' маршрута, кроме т-переходов, помечен наблюдением и, разрешаемым кнопкой, которая Н-безопасна в пресостоянии 1 этого перехода (то есть безопасна в некотором состоянии в спецификации, соответствующем по Н состоянию 1, и тем самым по Н-гипотезе безопасна в состоянии 1). Состояние реализации Н-достижимо, если оно достижимо по Н-безопасному маршруту, то есть является его постсостоянием. Заметим, что пресостоянию 1 каждого перехода 1—и—>а ' Н-безопасного маршрута соответствует по Н хотя бы одно состояние спецификации, а для постсостояния 1' это не обязательно верно, если это не пресостояние следующего перехода (постсостояние маршрута). Соответствие Н естественным образом индуцирует соответствие Н' маршрутов реализации и спецификации. Во-первых, каждому переходу по наблюдению одного маршрута соответствует переход по тому же наблюдению другого маршрута, причем это наблюдение разрешается кнопкой, которая безопасна в 0. □ $ №={00, 11,12,21,22} (у} аф 1 => {у} Н-м/е 2, мо (у) аф 2, {{х}}, <Н(у}] Рис. 4. Нерефлексивность отношения безопасности. х х А о пресостояниях этих переходов как в спецификации, так и в реализации. Во-вторых, каждому состоянию одного маршрута соответствует по Н некоторое состояние другого маршрута таким образом, что, если пресостояния переходов маршрутов соответствуют друг другу, то постсостояния этих переходов тоже соответствуют друг другу. Все реализационные маршруты, имеющие по Н' соответствующие спецификационные маршруты, являются Н-безопасными. Продолжения таких реализационных маршрутов, получаемые нажатием кнопок, которые Н-безопасны в постсостояниях маршрутов, могут не иметь по Н' соответствующих спецификационных маршрутов, но также являются Н-безопасными5. 2.7. Безопасная симуляция Теперь, соединяя Н-гипотезу о безопасности и слабую симуляцию, мы получаем окончательный вариант слабой симуляции с отказами и безопасностью (изменения по сравнению с D5„s подчеркнуты волнистой линией), которую будем называть безопасной симуляцией и обозначать ss:6 X ss S = BRcVjXVs (s0=<y)j =S> (i0,s0)eR) & V(i,s)eR VP E-safe i VuePu{P) Vi' (P safe s & i=(u)=>i' => 3s' s=(u)=>s' & (i',s')eR). Если реализация задана явно, то можно аналитически проверять как Н-гипотезу, так и безопасную симуляцию. Когда реализация неизвестна, верификация симуляции выполняется с помощью тестирования. В этом случае Н-гипотеза является предусловием безопасного тестирования. Если s 0=(у)=>, то Н=0, безопасное тестирование невозможно, но и не нужно, так как любая реализация конформна (при любом R). Если s0=(y)J, то тестирование заключается в проверке тестируемого условия (нижние две строки определения ss). Если существует кнопка Р E-safe i, то состояние i Н-достижимо. Для каждого Н-достижимого состояния i нажимается каждая Н-безопасная в нем кнопка Р, и полученные наблюдение и и постсостояние i' верифицируются по спецификации: наблюдение и должно быть в каждом соответствующем ему ПО R СОСТОЯНИИ s, в котором кнопка Р безопасна, а среди постсостояний s' хотя бы одно должно соответствовать i' по R. Лемма 9: Н-safe п < с ss. Доказательство. Отношение <5„s, во-первых, не требует выполнения Н-гипотезы о безопасности, и, во-вторых, требует верификации наблюдений, разрешаемых не только Н-безопасными кнопками, а любыми кнопками, 5 Эти продолжения аналогичны безопасным продолжениям безопасных трасс (то есть тестовым трассам) в теории трассовой конформности [2,3]. 6 Мнемоника: ss - Safe Simulation. безопасными как в реализационном, так и в соответствующем ему по И спецификационном состояниях. □ Для класса спецификаций без ненаблюдаемых отказов, дивергенции и разрушения (когда все кнопки безопасны в спецификации), имеем: Н- safe п < = «ж, а на поддомене безопасных реализаций < = «ж. Лемма 10: Отношение «ж, вообще говоря, нерефлексивно, но на классе спецификаций, удовлетворяющих собственной Н-гипотезе, рефлексивно: \/Б Э Н-яа/е Б Б \\ Б. Доказательство. Нерефлексивность «ж в общем случае следует из нерефлексивности отношения \i-safe (лемма 8). Рефлексивность «ж для спецификаций, удовлетворяющих собственной гипотезе о безопасности, следует из леммы 9 и рефлексивности отношения < . □ Лемма 11: Для конформного по «ж соответствия И соответствие РпН тоже конформно. Доказательство. Если б 0=(у)=>, то Н=0 и любая реализация конформна при любом соответствии И, в частности при Р.Г',0=0. Если з0=(у)и, то, выполнение Н-гипотезы влечет (1,5) еН, а конформность соответствия И влечет (л_ о, в о) еИ, следовательно, (1 , з ) е РпН. Пусть для некоторых состояний, кнопки и наблюдения выполняется: И, з) е РпН & р н-жа/е 1 & иеРи{Р} & Р эа/е в & :1=(и)=>1'. Тогда по Н-гипотезе Р Н-эа/е 1 влечет Р «а/е 1, а по конформности соответствия И, существует такое состояние в', что з=(и)^>з & (± , з ) еР,. Тем самым выполнены условия второго правила вывода в определении соответствия Н. Следовательно, (л_',з')еН. В результате имеем а, з) еРпН. что и требовалось доказать. □ Эта лемма позволяет переформулировать определение безопасной симуляции следующим образом: I «ж Б = I Н-«а/е Б & ЭИсН (з0=(у)и => |10, з0) еИ) & V (1,з) еИ V Р «а/е г \/иеРи{Р} VI' (:1=(и)=>л_' => Эе' з=(и)=>з' & 11',з' ) еИ). Лемма 12: Объединение конформных по «ж соответствий конформно. Доказательство. Тривиально. Из последних двух лемм следует, что можно ограничиться только такими соответствиями И, которые вложены в Н. Мы имеем два естественных конформных соответствия: Их - объединение всех конформных соответствий, и Р. =РпН. Ниже в разделе, посвященном практическому тестированию конформности «ж, мы покажем, как можно при некоторых ограничениях в процессе тестирования строить такие конформные соответствия или доказывать их несуществование для заданной спецификации 196 и любой фиксированной, но неизвестной реализации, удовлетворяющей Н-гипотезе. Лемма 13: Отношение ss транзитивно. Доказательство. Пусть A ss В и В ss С. Обозначим соответствующие отношения Н и конформные соответствия через Ндв, Нвс, НАС, Р-ав- Р-вс- По лемме 11 будем считать, что Рав^Н_дд. Rbc£HBc. Обозначим RAC=RABoRBC={ (а, с) | ЭЬ (a,b)eRAB & (b,c)eRBC}. Если с0=(у)=>, то любая реализация конформна спецификации С, в частности A ss С. Далее будем считать, что c0=(y)J. Сначала покажем, что А Н-safe С. Так как c0=(y)J, то по конформности соответствия RBC имеем b0=(y)J, а тогда по конформности соответствия имеем а0=(у)Д Теперь нам нужно доказать, что, если (а,с)еНАС & Р safe с, то Р safe а. Мы докажем более сильное утверждение, включающее дополнительное требование: ЭЬ (а,Ь)еНдв & (Ь,с)еНвс. Сначала покажем, что утверждение верно для пары (а, с), полученной по 1-ому правилу вывода для НАС. Действительно, если c0=(y)J, a0=(y)J, а =>а и с0=>с, то по Нвс-безопасности В имеем b0=(y)J. 1-ое правило вывода применимо к паре (а, Ь0), то есть (а, Ь0) еНдв- Также 1-ое правило вывода применимо к паре (Ь0, с), то есть (Ь0, с) еНвс. Тогда по Нвс-безопасности В имеем Р safe b0, а отсюда по Ндв-безопасности А имеем Р safe а. Теперь предположим, что утверждение верно для пары (а, с) и выполнены условия 2-го правила вывода: (а, с) еНАС & р safe а & Р safe с & а=(и)=>а ' & с=(и)=>с'. Докажем утверждение для пары (а ', с' ) еНАС & Р ' safe с'. По предположению ЭЬ (а,Ь)еНдв & (Ь,с)еНвс. Тогда по Небезопасности В имеем Р safe b, а тогда по Рдц-конформности существует Ь' такое, что b=(u)^>b & (a' ,b') eRabEHsb. Тогда по 2-ому правилу вывода для Нвс имеем (Ь', с') еНвс. Тогда по Нвс-безопасности В имеем Р' safe b', а тогда по Ндв-безопасности А имеем Р' safe а'. Утверждение о том, что A E-safe С, доказано. Теперь докажем, что для А и С выполнено тестируемое условие конформности SS для соответствия RAC. Действительно, пусть (a,c)eRAC, Р safe с, uePu{P} и а=(и)=>а'. Тогда существует b такое, что (a,b)eRAB и (Ь, с) 6RBC. По Нвс-безопасности В имеем Р safe b, а тогда по Рдв-конформности А существует b' такое, что b=(u)=>b' и (а', b') е Р.дв. Но по Rbc" конформности В существует с' такое, что с=(и)=>с' и (b',c')eRBC. Тем самым, (а ', с' ) е RAC. □ Суммируя леммы 1-ь13, получаем следующую теорему, описывающую соотношение различных симуляций: Теорема 1: 1 <4 С<3 =<2 = <' А • — WS — WS — WS — WS • 2 4 с<5 WS------- WS* 3 • -ws^-wsH^ws ^ WS. 4. Симуляции <kws, где к= 1-5-4, являются предпорядками. 5. Симуляция <5wS рефлексивна, но не транзитивна. 6. Отношение Н-safe нерефлексивно и нетранзитивно. 7. Н -safe г, <5WS с ss 8. Отношение ss, вообще говоря, нерефлексивно, но на классе спецификаций, удовлетворяющих собственной Н-гипотезе, рефлексивно. 9. Отношение ss транзитивно и на классе спецификаций, удовлетворяющих собственной Н-гипотезе, является предпорядком. 3. Связь симуляции с трассовой конформностью 3.1. Трассовые гипотеза о безопасности и конформность В трассовой теории конформности гипотеза о безопасности основывалась на трассах реализации и спецификации [1,2,3,5] и не требовала соответствия состояний реализации и спецификации. Напомним основные определения этой теории. Для реализации I определяется отношение safe in безопасности кнопки PeRuQ после трассы стеГ(1): Р safe in I after ст = (PeR v ст-(Р)гГ(1) ) & VzeP ct-(z,y)gT(I) & ст-(Д)гГ(I). Очевидно, что если кнопка безопасна по safe in после трассы (Р safe in I after ст), то она безопасна в каждом состоянии после этой трассы: Vie (I after ст) Р safe i. Для спецификации отношение safe by безопасности кнопок после трасс определяется неоднозначно: это любое отношение, удовлетворяющее трем требованиям: VaeT{ S) VReR VzeL VQeQ 1) R safeby S after ст VueR CT-(u,y)gT{S) & a-{A)^T{S), 2) CT-(z)er(S) & BTeRuQ zeT & VueT ct-(u, y)g T( S) & ст-(Д)гГ( S) => BPeRuQ zeP & P safeby S after ст, 3) Q safeby S after ст => 3veQ CT'(v)er(S) & VueQ a-(u,y)<£T(S) & ст-(Д)?Г(S). Будем считать, что вместе со спецификацией задано отношение safeby, удовлетворяющее этим трем требованиям. R-трасса ст спецификации S называется безопасной, если спецификация не содержит трассу (у), а трасса ст не заканчивается на дивергенцию и разрушение, и каждый встречающийся в ней символ и (внешнее действие или R-отказ) безопасен после непосредственно предшествующего ему префикса трассы: SafeBy {S) = {CTef(S) | (y)gJ'(S) & V|a,X,u (ct=|j.-(u)-X => u safe by E after ц) }. Для кнопок ReR отношения safe by и safe in совпадают. Поэтому, если кнопка ReR безопасна по safe by после трассы (R safe by S after ст), то она безопасна в каждом состоянии после этой трассы: Vse (S after ст) R safe s. Однако кнопка Q е Q, которая безопасна по safe by после трассы, может быть опасна в некоторых (но не всех) состояниях s е (S after а). Тем не менее, верна следующая лемма: Лемма 14: Если трасса безопасна по отношению safe by (в спецификации) или safe in (в реализации), то все маршруты с этой трассой безопасны (соответственно, в спецификации или в реализации). Обратное, вообще говоря, не верно. Доказательство. Доказательство будем вести индукцией по трассе. Пустая трасса безопасна, если нет трассы (у), а это означает безопасность всех состояний, достижимых по пустой трассе и, следовательно, безопасность всех маршрутов с пустой трассой. Пусть утверждение верно для трассы ст, и докажем его для трассы ст-(и), где наблюдение и разрешается кнопкой Р, которая безопасна после ст по отношению safe by или safe in. Нам нужно показать, что в каждом состоянии после трассы ст, в котором имеется переход по и (включая виртуальные переходы по отказам из R), кнопка Р безопасна. Действительно, если кнопка PeR, то отношения safe by и safe in для такой кнопки совпадают, и ее безопасность по этим отношениям означает ее безопасность в каяедом состоянии после трассы ст. Если кнопка PeQ, то ее безопасность по safe in также означает ее безопасность в каждом состоянии после трассы ст. А безопасность кнопки PeQ по отношению safe by означает ее безопасность в каждом состоянии после трассы ст, в котором нет отказа { Р}. Поскольку для PeQ должно быть {Р}, то есть наблюдение и - это внешнее действие (не отказ), кнопка Р безопасна в каждом состоянии после трассы ст, в котором есть переход ПО U. Из безопасности всех маршрутов с данной трассой, вообще говоря, не следует безопасность этой трассы, что показывается примером на 0. □ R={ (x, a}, {x, b}}, Q=0 Трасса (x) опасна, но все ее маршруты безопасны Рис. 6. Пример опасной трассы, все маршруты которой безопасны. Трассовая гипотеза о безопасности определялась следующим образом: I safefor S = ((y)gJ'(S) =>(у)гГ(1)) & VaeSafeBy (S) пГ(I) VPeRuQ (P safe by S after ст => P safe in I after ст). Трассовая конформность определялась так: I saco S = I safe for S & VaeSafeBy (S) пГ (I) VP safe by S after ст Vie (I after <5) VuePu{P} (i=(u)=> => 3s e (S after ст) s=(u)=>). 3.2. Связь н-гипотезы с трассовой гипотезой о безопасности Лемма 15: Н-гипотеза предъявляет к реализации более сильные требования, чем трассовая гипотеза о безопасности: Н-safe с safe for. Доказательство. Пусть I Я-safe S. Покажем, что I safe for S. Сначала покажем, что (y)g Т (S) => (y)g Т (I). Условие (y)g Т( S) эквивалентно условию s 0=(y)J, а условие (у)£ Т ( I ) эквивалентно условию i0=(y)J. По Н-гипотезе имеем S0=(y)J => io=(y)J. Теперь нам нужно показать, что если ueSafeBy (S) пГ(I) и кнопка Р safe by S after ст, то Р safe in I after ст. Условие P safe in I after ct эквивалентно условию Vi e (I after ст) P safe i. Из условия P safe by S after ст следует, что кнопка Р safe s хотя бы для одного состояния se (S after а). Если (i,s)eH, то по Н-гипотезе Р safe i. Поэтому нам достаточно показать, что Vct е Safe Ну (S) ri 7’ (I) Vse (S after <5) Vie {1 after a) (i,s)eH. Будем вести доказательство индукцией по трассе aeSafeBy (S) пГ(1). Пустая трасса ст=() всегда есть в реализации и безопасна в спецификации, если (y)g Т (S), то есть s =(y)J. а тогда по доказанному (y)g Т (I), то есть i0=(y)J. А тогда по 1-ому правилу вывода для соответствия Н имеем Vs е (S after ()) Vi е (I after ()) (i, s ) еН. Пусть утверждение верно для трассы ст и докажем его для трассы ст-(и), где наблюдение и разрешается кнопкой Р safe by S after ст. Пусть s e (S after ст-(и)) и i ' e (I after ct-(u)) . Тогда 3se (S after <з) P safe s & s=(u)=>s'. Также 3ie (I after <5) i=(u)=>i'. По предположению шага индукции (i,s) еН, следовательно, по Н-гипотезе Р safe i. А тогда выполнены условия 2-го правила вывода для соответствия Н, и мы имеем (i',s')eH, что и требовалось доказать. □ Можно рассматривать симуляцию с трассовой гипотезой о безопасности. Такая симуляция определяется следующим образом (изменения по сравнению с ss подчеркнуты волнистой линией): I sst S = I safejor S & 3RcVIxVs (s0=<y)J =S> (i0,s0)eR) & V(i,s)eR VaeSafeBy (S) nl VP safe by S after a VuePu{P} Vi' (P safe s & i e (I after a) & i=(u)=>i ' => 3 s ' s=(u)=>s ' & (i ', s ' ) eR). Симуляция с Н-гипотезой о безопасности предъявляет более сильные требования к реализации, чем симуляция с трассовой гипотезой о безопасности. Лемма 16: Из симуляции с Н-гипотезой о безопасности следует симуляция с трассовой гипотезой о безопасности, но не наоборот: ss с sst. Доказательство. Из леммы 15 непосредственно следует, что симуляция с Н-гипотезой влечет симуляцию с трассовой гипотезой о безопасности: ss с sst. Это объясняется тем, что множество кнопок, безопасных в состоянии реализации по safe for, вложено во множество кнопок, Н-безопасных в этом состоянии. Иными словами, для sst нужно выполнять меньше проверок, чем для ss. Но из sst, вообще говоря, не следует ss. Пример на 0. □ Рис. 7.Пример симуляции с трассовой гипотезой о безопасности при отсутствии симуляции с Н-гипотезой о безопасности. 3.3. Симуляция с трассовой гипотезой о безопасности Симуляция с трассовой гипотезой о безопасности, в свою очередь, предъявляет более сильные требования к реализации, чем трассовая конформность, основанная на той же гипотезе о безопасности. Лемма 17: Из безопасной симуляции с трассовой гипотезой о безопасности следует трассовая конформность, но не наоборот: sst с \асо. Доказательство. Пусть I Э и Р - конформное соответствие. Пополним соответствие, добавив в него все пары (1, э 0). где л-о=>1. при условии безопасности начального состояния спецификации: з0=(у)Д Пополненное 201 соответствие R' также является конформным соответствием. Действительно, нам надо показать, что если для некоторой трассы aeSafeBy (S), кнопки Р safe by S after а и наблюдения uePu{P} в реализации для состояния ie (I after а) имеет место i=(u)=>i', то в спецификации кнопка Р либо опасна в s0, либо найдется такое состояние s', что s0=(u)=>s' и (i', s') е R. Поскольку i0=>i и i=(u)=>i ', имеем i0=(u)=>i'. Если Р safe s0, то по конформности соответствия R в спецификации найдется такое состояние s', что s0=(u)=>s' и (i ', s ') е RcR', что и требовалось доказать. Теперь докажем вспомогательное утверждение: если трасса ст безопасна в спецификации, то есть aeSafeBy {S), и заканчивается в реализации в состоянии i, то есть ie (I after а), то (S after ст) nR' (i) Ф0. Доказательство будем вести индукцией по трассе ст. Сначала рассмотрим случай пустой трассы ст=(). Тогда QeSafeBy (S) влечет s0=(y)J, что влечет для пополненного соответствия (i, s0) е R'. то есть s еR (i). Но также s е (S after 0) и, следовательно, (S after ()) nR' (i ) Ф0. Пусть утверждение верно для трассы ст и докажем его для трассы ст-(и). Если i 1 е (I after CT-(u)) и a-{u)eSafeBy (S), то найдется такое состояние ie (1 after а) и такая кнопка Р safe by S after ст, что uePu{P} и i=(u)=>ii. Поскольку п-(и) eSafe By (S) влечет aeSafeBy (S), то по предположению шага индукции найдется состояние s е (S after ст) nR' (i). По конформности соответствия R' найдется такое состояние s . что s=(u)=>s 1 и (i 1, Si) eR', то есть SieR' (ix). Но также se (S after а) и s=(u)=>S! влечет s1e {S after а-{и)). Тем самым, (S after ст-(и)) nR (ii) Ф0. что и требовалось доказать. Из доказанного вспомогательного утверждения непосредственно следует, что безопасная симуляция с трассовой гипотезой о безопасности влечет трассовую конформность. Действительно, если ст е Safe Ну (S) и ie (I after а), то найдется состояние se (S after ст) nR (i). Тогда, если Р safe by S after ст, uePu{P) и i=(u)=>i', то по конформности соответствия R' имеем s=(u)=>, что и требуется для трассовой конформности. Мы доказали, что sst с saco. Для завершения доказательства леммы заметим, что из трассовой конформности, вообще говоря, не следует симуляция. Пример на 0. □ s I x R={(x), {у)} f Q=0 I saco S I M s Puc. 8. Пример трассовой конформности при отсутствии симуляции с трассовой гипотезой о безопасности. Как итог мы имеем следующую теорему, описывающую соотношение трассовой конформности и безопасных симуляций с различными гипотезами о безопасности. Теорема 2: ss с sst с saco. Усиление требований к реализации идет сначала как введение дополнительных требований к соответствию состояний реализации и спецификации для симуляции при сохранении той же гипотезы о безопасности sst с saco и далее как усиление гипотезы о безопасности ss с sst. что ведет к большему количеству безопасных нажатий кнопок в состояниях и, тем самым, к большему числу проверок. 4. Теоретическое тестирование 4.1. Полнота тестирования Симуляция основана на соответствии состояний реализации и спецификации. Спецификация должна быть задана и ее состояния мы видим. При тестировании реализация неизвестна, поэтому для проверки симуляции нам нужна специальная операция опроса текущего состояния реализации (status message [8]). Тестирование с такой тестовой возможностью называется тестированием с открытым состоянием. Операция опроса состояния будет применяться в начале тестирования и после каждого наблюдения7. Тест - это инструкция, состоящая из пунктов, описывающих тестовые воздействия и получаемые наблюдения и постсостояния, а также указаний по выполнению следующих пунктов или вынесению вердикта (pass или fail). В начале опрашивается состояние реализации, и для каждого возможного состояния указывается следующий пункт. В каждом другом пункте 7 Отказ возникает в стабильном состоянии. Поэтому, если после наблюдения отказа (когда реализация гарантированно оказалась в стабильном состоянии) снова наблюдается отказ (быть может, другой), то состояние можно не опрашивать, поскольку оно не изменяется. указывается кнопка, которую нужно нажимать, и для каждого наблюдения и постсостояния, возможных после нажатия этой кнопки, - пункт инструкции, который должен выполняться следующим, или вердикт, если тестирование нужно закончить. В [1,2,3] такая инструкция соответствует формальному определению управляемого LTS-теста, который однозначно определяет тестирование (без лишнего не детерминизма). Реализация проходит тест, если ее тестирование всегда (то есть при любом проявлении недетерминизма реализации) не заканчивается с вердиктом fail. Реализация проходит набор тестов, если она проходит каждый тест из набора. Набор тестов значимый, если каждая конформная реализация его проходит; исчерпывающий, если каядая неконформная реализация его не проходит; полный, если он значимый и исчерпывающий. Основная задача заключается в генерации полного набора тестов по спецификации. На практике требуется, чтобы каждый тест заканчивался за конечное время, а набор тестов был конечным. К сожалению, это возможно только при некоторых ограничениях на семантику, спецификацию, реализацию и недетерминизм ее выполнения. Иногда требуют конечности времени выполнения теста, но допускают бесконечные наборы тестов. На самом деле это не лучше и не хуже конечного набора тестов с бесконечным выполнением тестов. Различие между тестом и набором тестов условно, в основном это вопрос удобства построения тестовой системы. Дело в том, что завершение теста и запуск другого (или того же самого) теста эквивалентно выполнению рестарта исследуемой системы в рамках одного теста. Предлагаемые в данной статье алгоритмы тестирования ориентированы на использование одного теста с рестартом системы в любой момент времени. Прежде всего, для полноты тестирования безопасной симуляции ss требуется для каждого Н-достижимого состояния i реализации и каждой Н-безопасной в нем кнопки Р верифицировать каждое имеющееся в реализации наблюдение uePu{P} и постсостояние i', то есть маршрут i=(u)=>i'. Для этого предполагается, что такой маршрут можно получить через конечное число нажатий кнопки Р в состоянии i. Для того, чтобы можно было попасть из начального состояния реализации в каяедое Н-достижимое состояние, мы должны предположить, что некоторые маршруты i=(u)=>i' получаются достаточное число раз (и каждый маршрут - за конечное время). Это предположение называется гипотезой о глобальном тестировании [6]. Без каких-либо ограничений на класс реализаций глобальное тестирование, очевидно, требует наблюдения каждого маршрута i=(u)=>i' бесконечное число раз при бесконечной последовательности нажатий кнопки Р в состоянии i. В дальнейшем будем считать, что гипотеза о глобальном тестировании выполняется. 4.2. Дерево вывода неконформности Для конформности, основанной только на трассах наблюдений и не использующей соответствие состояний, доказано существование полного тестового набора для любой спецификации [3]. Для безопасной симуляции такой полный тестовый набор существует уже не всегда. Исследуем эту проблему. Если s0=(y)=>, то все реализации конформны, и тестирование не требуется. Поэтому далее будем считать, что s0=(y)J. Рассмотрим минимальное множество N пар состояний (i, s), которое порождается следующими правилами вывода: V(i,s)eH VP Н-safe i VuePu{P} 1. i=(u)=> & P safe s & s=(u)J □ (i,s)eN, 2. i=(u)=>i' & P safe s & {i'}x(s after (u)) cN □ (i,s)eN. Пары из N будем называть неконформными. Лемма 18: I ss S о (i0,s0)£N. Доказательство. Очевидно, что неконформная пара не может принадлежать никакому конформному соответствию. Если (i0,s0)eN, то конформного соответствия не существует, так как оно должно было бы содержать (i0,s0). Обратно, если (i , s ) ^ N. то соответствие H\N, очевидно, конформно. □ Заметим, что, если i0=>io , то условие (i0 , s ) eN. очевидно, влечет (i0, s0) eN. Поэтому нам достаточно проверить условие (i0 ,s0) eN для любого состояния i0 е (i о after ()) • Правила вывода для N определяют граф вывода. Вершинами этого графа являются пары (i,s) eN. Если пара (i,s) получена применением 1-го правила вывода, соответствующую вершину будем называть вершиной 1-го типа, в противном случае (применением только 2-го правила вывода) -вершиной 2-го типа. Помеченная дуга (i,s) — (u, i ') —>■ (i ', s') соответствует применению второго правила вывода для i, u, i ', s и s ' е (s after (и)). Набор таких дуг для всех s ' е (s after (и)) проводится тогда и только тогда, когда i=(u)=>i' & Р safe s & { i ' } х (s after (u))cN. Для каждой пары (i, s) е N в графе вывода существует (быть может, не единственное) дерево маршрутов, которое мы будем называть деревом вывода. Каждый маршрут, принадлежащий дереву, начинается в (i, s). Корень дерева - пустой маршрут. Листья дерева - маршруты, заканчивающиеся в вершинах 1-го типа. Каждый маршрут, принадлежащий дереву и заканчивающийся в графе вывода в вершине 2-го типа, продолжается в дереве теми и только теми дугами, которые соответствуют одному применению 2-го правила вывода, то есть помеченными одной и той же меткой (и,i '). Лемма 19: Дерево вывода конечно тогда и только тогда, когда оно имеет конечное ветвление: каждый маршрут продолжается в дереве конечным числом дуг, что эквивалентно конечности каждого множества s after (и), участвующего в построении этого дерева. Доказательство. Количество дуг, которыми продолжается маршрут в дереве вывода, по построению определяется применением 2-ого правила вывода и совпадает с количеством состояний в соответствующем множестве состояний s after (и). Если дерево конечно, то, очевидно, оно имеет конечное ветвление и все эти множества состояний конечны. Обратно, если все эти множества состояний конечны, то дерево имеет конечное ветвление. А тогда, поскольку в дереве нет бесконечных маршрутов, оно конечно (по теореме Кёнига [7]). □ 4.3. Общий алгоритм тестирования Если (i0,s0)eN, то для (i0,s0) существует (быть может, не единственное) дерево вывода. Опишем алгоритм тестирования, определяющий неконформность любой Н-безопасной реализации, для которой хотя бы одно из таких деревьев конечно. Этот алгоритм будем называть общим алгоритмом тестирования. Сначала рассмотрим необходимые для работы теста ограничения. Кроме глобального тестирования, нам требуется выполнение следующих условий: 1) начальное состояние спецификации s0 известно; 2) перечислимо множество спецификационных состояний, достижимых из начального состояния по пустой трассе S0= (s0 after ()), и имеется итератор этого множества; 3) для каждого спецификационного состояния s перечислимо множество безопасных кнопок Р (s) ={ PeRuQ| Р safe s}, и имеется итератор этого множества; 4) для каждого спецификационного состояния s и каждого безопасного в нем наблюдения и перечислимо множество постсостояний маршрутов с трассой (u): S (s, и) = (s after (и)), и имеется итератор этого множества. В каждый момент времени работы алгоритма будет построена некоторая LTS I', являющаяся представлением некоторой (конечной) части реализации I. Множеством состояний I' будет конечное множество Vz'cVj «пройденных» реализационных состояний. Переход i—u—>i ' добавляется тогда, когда обнаруживается, что реализация «прошла» маршрут i=(u)=>i '. Вместе с каждым переходом i—u—>i ' будем хранить управляющую кнопку Р (i—u—>i'), то есть кнопку, нажатие которой вызвало появление этого перехода. По мере построения I' будет постепенно формироваться для каждого пройденного состояния i множество Н (i) соответствующих ему по Н спецификационных состояний. Эго множество в каждый момент времени будет конечным, но может постепенно расти. Тест состоит из управляющего алгоритма и нескольких итераторов перечислимых множеств. Набор итераторов динамический и в каждый момент времени конечный: какие-то итераторы появляются и работают постоянно, а некоторые из появившихся могут потом исчезнуть. Одни из итерируемых множеств могут быть бесконечными, но они не меняются в процессе работы, другие множества конечны, но могут увеличиваться. Управляющий алгоритм вызывает работающие итераторы по циклу. Мы будем описывать эти перечислимые множества и их итераторы по мере описания алгоритма тестирования. В начале тестирования, а также после рестарта, опрашиваем состояние и получаем не обязательно начальное состояние реализации i0, а любое состояние л-о е I = (i after 0). После опроса состояния i0 , оно добавляется во множество 10 (до начала тестирования пустое) и во множество Vz и, если до этого было i0 <£VX , то устанавливаем Н (iо ) : =0. Запускается9 итератор S0 (iо'), который, итерируя множество S0, добавляет состояния из этого множества к Н (i0 ). Будем считать, что в первую очередь добавляется состояние s 0. Если множество S0 конечно, итератор S0 (i0') удаляется после завершения итерации. Каждый раз, когда добавляется новое состояние s к множеству Н (i), запускается итератор Р (i, s), итерирующий множество Р (s). Итератор Р (i, s) перечисляет безопасные в s кнопки и для каждой кнопки Р запускает итератор тестового воздействия Т (i, s, Р) для нажатия кнопки Р в состоянии i. Если множество Р (s) конечно, итератор P(i,s) удаляется после завершения итерации. 8 Мы говорим о «представлении части», а не просто о «части» реализации, поскольку 1=(и)^>1' означает лишь существование маршрута с такими пре-и пост-состояниями и с такой трассой, а не сам этот маршрут, имеющийся в реализации, который остается неизвестным и может быть, вообще говоря, не единственным. Этот маршрут мы заменяем в Г на переход 1—и—>1'. Тем самым, алфавит ЬТ8 I' - это объединение Ьи И множества внешних действий и И-кнопок ЬТ8 I. 9 Итератор Э0 (10') можно не запускать, если он уже один раз запускался. 207 Итератор Т (i, s, Р) работает бесконечно следующим образом. Сначала делается рестарт, после чего по пройденной части I' ищется маршрут, ведущий из состояния после рестарта i0 el0 в состояние i. Такой маршрут, очевидно, существует и соответствует Н-безопасному маршруту реализации. Итератор пытается пройти такой маршрут, нажимая управляющие кнопки. Каждый раз, когда ему не удается пройти нужный маршрут до конца (из-за недетерминизма реализации), выполняется рестарт и попытка повторяется. Глобальное тестирование гарантирует, что каждый переход i—u—>i в I' может быть получен за конечное время (I' может при этом расти, то есть появляться новые переходы), и, следовательно, итератор за конечное время попадет в состояние i. После этого нажимается кнопка Р и получается переход i—u—>i ', который добавляется в I' вместе с кнопкой Р как управляющей кнопкой. Итератор Т (i, s, Р) - это единственный итератор, который взаимодействует с реализацией. По построению для Н-безопасной реализации такое взаимодействие безопасно. Когда итератор Т (i, s, Р) первый раз проходит переход i—u—>i ', запускается итератор S (i, s, u, i '), который, итерируя множество S (s, и), добавляет постсостояния s ' маршрутов s=(u)=>s ' к множеству Н (i ') и запускает при необходимости итератор Р (i ', s '). Если множество S (s, и) конечно, итератор S (i, s, u, i '), обнаруживая это (то есть завершение итерации), переходит во второй режим работы - режим проверки. В режиме проверки итератор S (i, s, u, i ') проверяет, пусто ли множество S (s, и). Если оно пусто, пара (i, s) добавляется к множеству N по 1-ому правилу вывода, а итератор заканчивает свою работу и удаляется. В противном случае итератор опрашивает по циклу состояния из (конечного) множества S (s, и), проверяя для каждого состояния s ' е S (s, и) условие (i ', s ') eN. Если это условие выполнено для всех СОСТОЯНИЙ ИЗ S ( S , U), пара (i, s) добавляется к множеству N по 2-ому правилу вывода, а итератор заканчивает свою работу и удаляется. В любом случае при удалении итератора S(i,s,u,i') проверяется условие i е I & s=s0. Если оно выполнено, тест заканчивает свою работу с вердиктом fail. Пока итератор не удален, он работает в цикле по указанному алгоритму (после завершения итерации начинает ее сначала). Итак, при тестировании работают итераторы: S0(i0), P(i,s), T(i,s,P) и S(i,s,u,i). Число итераторов в каждый момент времени конечно, и они организованы в список, который перебирается по циклу управляющим алгоритмом, вызывающим итераторы по очереди. Однако список итераторов может расти. Поэтому для того, чтобы каждый итератор делал очередной шаг итерации через конечное время после предыдущего шага, новые итераторы добавляются в начало списка. Из описания общего алгоритма следует, что тест, работающий по этому алгоритму, выносит вердикт fail только для таких реализаций, в которых для пары (і о, s о) существует конечное дерево вывода. Теорема 3: Тест, работающий по общему алгоритму, является значимым на классе всех Н-безопасных реализаций и полным на подклассе реализаций, в которых для пары (i0,s0) дерево вывода либо не существует (реализация конформна), либо конечно (реализация неконформна). 4.4. Достаточное условие полноты тестирования Тест, работающий по общему алгоритму, не является полным на классе всех Н-безопасных реализаций. Он работает бесконечно долго и не выносит вердикт fail для всех конформных реализаций (что правильно), но также (что неправильно) и для тех неконформных реализаций, в которых для пары (і о, s о) существуют деревья вывода, но все такие деревья бесконечны. На 0 показан пример, когда реализация неконформна, но все деревья вывода бесконечны. Здесь I ss S для любой R/Q-семантики (из 22 возможных при алфавите L= {х, у}), кроме трех семантик {{х}}/{{у}}, {{у}}/{{х}} и 0/{{х},{у}},то есть для всех семантик таких, что {х}, {у} є R или {х, у} є RuQ. Для этих семантик действия х и у безопасны во всех состояниях реализации и спецификации. Состояние 1 не может соответствовать состоянию s0, так как 1=(у)=>, но s0=(y)J; но оно не может соответствовать и любому другому состоянию спецификации, так как 1=(х, х, ...)=> для любого числа действий х, а в спецификации такие трассы есть только в состоянии s0. Через I (п) обозначим под-LTS реализации I, содержащую состояния 0,1,...,п и все переходы между ними. Легко видеть, что I (n) ss S для каждого n (I (п) совпадает с частью спецификации S, определяемой одним переходом s0—х—>s). Любой тест за конечное время п может исследовать часть реализации, содержащую не более п состояний. Эта часть реализации, очевидно, является частью конформной LTS I (п), и поэтому тест не может вынести вердикт о неконформности реализации I на основе этой ее части, то есть через время п. Тем самым никакой тест не может за конечное время вынести вердикт fail, поэтому любой набор тестов не может быть исчерпывающим. So L={x, у} Рис. 9. Пример отсутствия полного набора тестов. Теперь мы наложим на спецификацию ограничение, которое достаточно для существования полного теста на классе всех Н-безопасных реализаций. Это спецификации: 1) в каждом безопасно достижимом состоянии спецификации число переходов по каждому безопасному действию конечно, 2) из каждого такого состояния по т-маршрутам достижимо конечное число состояний. спецификаций тест, работающий по общему алгоритму, полон на классе всех Н-безопасных реализаций. Доказательство. По лемме 19 и теореме 3 нам достаточно показать, что в спецификации все множества состояний s after (и), где uePu{P} и Р safe s конечны для всех безопасно-достижимых состояний s. А такие множества всегда конечны для локально-конечно-ветвящейся и т-ограниченной LTS-спецификации. □ 5. Практическое тестирование 5.1. Ограничения Алгоритм полного тестирования, описанный в предыдущем разделе, для локально-конечно-ветвящихся и т-ограниченных LTS-спецификаций обнаруживает ошибку за конечное время, но при отсутствии ошибок может выполняться бесконечно долго. Эго не приемлемо на практике. В данном разделе мы сформулируем ограничения на семантику, спецификацию и реализацию, которые позволят выполнять полное тестирование за конечное время, и опишем алгоритм тестирования. Эти ограничения аналогичны тем, которые делают полное тестирование конечным для конформности saco, основанной только на трассах наблюдений без соответствия состояний [5]. Сформулируем эти ограничения: ограничение локалъно-конечно-ветвимости и т-ограниченности Теорема 4: На классе локально-конечно-ветвимых и т-ограниченных 1) Ограничения на семантику, число кнопок конечно и задан алгоритм разрешения кнопки относительно всех действий. Наличие такого алгоритма не означает, что все кнопки (как множества действий) конечны (и, тем самым, конечен алфавит действий). Но для конечных кнопок алгоритм всегда существует. 2) Ограничения на спецификацию: ЬТ8-спецификация конечна: конечно число состояний и переходов. В этом случае, очевидно, спецификация локально-конечно-ветвящаяся и т-ограниченная. 3) Ограничения на реализацию: реализация (точнее, ее часть, порождаемая Н-безопасными маршрутами) конечна и ограниченно недетерминирована. Ограниченность недетерминизма - это более сильное предположение, чем глобальное тестирование. При глобальном тестировании требуется, чтобы каждое поведение, разрешаемое кнопкой, могло быть получено за конечное время, а при ограниченном недетерминизме - за ограниченное время. Это означает, что существует такое число t (степень недетерминизма), что в любом состоянии і реализации после t нажатий любой кнопки Р будут получены все возможные пары (наблюдение иєРи { Р}, постсостояние і '). При t=l реализация (наблюдаемо) детерминирована. 5.2. Модификация общего алгоритма тестирования Сначала покажем, что при этих ограничениях можно так модифицировать общий алгоритм тестирования, описанный в предыдущем разделе, чтобы он всегда заканчивался за конечное время. Поскольку при наших ограничениях спецификация локально-конечно-ветвящаяся и т-ограниченная, общий алгоритм обнаруживает ошибку в любой неконформной реализации, удовлетворяющей Н-гипотезе, за конечное время. Нужно, чтобы он заканчивал свое выполнение за конечное время и для конформных реализаций. Теорема 5: При указанных в подразделе 5.1 ограничениях на семантику, спецификацию и реализацию общий алгоритм может быть так модифицирован, что тест, работающий по этому алгоритму, полон. Доказательство. При указанных ограничениях каждый из итераторов Б0 (і0') и Р(і,з) удаляется, а итератор 3 (і, з, и, і ) переходит в режим проверки через конечное число шагов. При t-недетерминизме реализации итератор Т (і, э, Р) модифицируется: теперь он выполняет не более t шагов (тестовое воздействие + получение наблюдения и постсостояния). Заметим, что если наблюдается отказ Р в том же состоянии, кнопку Р можно нажимать в этом состоянии не t раз, а только один раз: ничего другого, кроме отказа Р, мы все равно не получим. При указанных ограничениях число всех возможных итераторов конечно. Поскольку в режиме проверки итератор Б (і, б , и, і ') не создает новых итераторов, через конечное число шагов останутся только итераторы Б (і,б,и,і'), работающие в режиме проверки. Очевидно, что, если за один цикл вызова всех этих итераторов не было изменения множества N (или, что эквивалентно, ни один итератор не был удален), то это множество уже больше не изменится. Управляющий алгоритм модифицируется так, чтобы в этом случае он заканчивал работу теста с вердиктом pass. □ 5.3. Алгоритм обхода реализации Общий алгоритм выполняет «исследование» реализации и верификацию симуляции параллельно, поскольку для бесконечной реализации нельзя ее сначала исследовать (за конечное время), а потом провести верификацию. Теперь мы опишем частный алгоритм тестирования, работающий только при ограничениях из подраздела 5.1, но зато более быстрый, и дадим оценку его сложности. Будем использовать обозначения, введенные для общего алгоритма. Из конечности семантики и реализации следует конечность LTS I', порождаемой Н-безопасными маршрутами реализации I. Из конечности спецификации следует конечность всех множеств Н (i) для состояний i из I'. Поэтому мы можем сначала построить LTS I' и множества Н (i) (будем называть это обходом реализации), а потом провести верификацию симуляции. С каждым пройденным состоянием i свяжем, кроме множества Н (i), которое будет пополняться постепенно, множество Р (i) =' J { Р (s) | s e Н (i) } кнопок безопасных хотя бы в одном состоянии из Н (i), а с каждой такой кнопкой Р - счетчик С (i, Р) числа нажатий кнопки Р в состоянии i. Будем называть кнопку PeP(i) полной в состоянии i, если 1) c(P,i)=l ив I' получен переход i—(Р)—»i или 2) c(P,i)=t. Это означает, что уже получены все возможные наблюдения и постсостояния при нажатии кнопки Р в состоянии i. В случае 1 после первого нажатия кнопки Р в состоянии i наблюдался отказ Р в этом же состоянии, повторное нажатие кнопки Р даст тот же отказ. В случае 2 после t нажатий кнопки получены все возможные переходы. Состояние i будем называть полным, если каждая кнопка из Р (i) полна в нем. Эго означает, что все возможные переходы i—(и)—>л_',где иеLuR, уже получены. Общая схема обхода реализации изображена на 0. В начале тестирования после опроса состояния i0 el0 имеем: Н (i0 ) =S0, Р (i0 )=u{P(s) |seS0}, С (iо ,Р)=0 длякаяедойкнопки PeP(i0 ). Рис. 10. Схема алгоритма обхода реализации. Пусть тест находится в некотором текущем состоянии i из I'. Если текущее состояние i неполное, то некоторая кнопка Р е Р (i) неполна в i. В этом случае осуществляем тестовое воздействие и наблюдение: нажимаем кнопку Р и получаем переход i—(u)—>i ', постсостояние i ' становится новым текущим состоянием. Увеличиваем счетчик c(P,i) :=c(P,i)+l. Если получен новый переход i—(u)—>i ', то добавляем его в I', запоминаем кнопку Р как управляющую кнопку Р (i—u—>i ') этого перехода, и корректируем Н (i ) : =Н (i ) и3 (s, и) для каждого s еН (i) при условии Р safe s. Каждый раз, когда новое состояние s добавляется во множество Н (i), корректируем Р (i) :=P(i)uP(s) и для каждого полученного ранее перехода i—(u)—>i ' при условии Р (i—(u)—>i') safe s корректируем H(i ) :=H(i )uS(s,u). отмечая вновь добавленные состояния. Эта рекурсивная процедура повторяется до тех пор, пока возможно. В силу конечности реализации и спецификации процедура закончится за конечное число шагов. Если текущее состояние i полное, то в нем все тестовые воздействия выполнены нужное число раз и получены все возможные переходы в I'. Для продолжения тестирования нужно перейти в любое неполное состояние. Если таких состояний нет, построение I' заканчивается. Рассмотрим переход в неполное состояние. В LTS I' всегда существует лес деревьев, ориентированных к своим корням, которыми являются все неполные состояния. Этот лес покрывает все состояния. Выберем любой такой лес и для каждого его перехода i—u—>i ' обозначим связанную с ним управляющую кнопку через A(i)=P(i—u—»i'). Будем двигаться, нажимая в каждом текущем состоянии i кнопку А (i). Из-за недетерминизма мы можем оказаться не в состоянии л_', а в другом состоянии 1' ', где будем нажимать кнопку А (л_' ' ) . Обозначим: Ь - число кнопок, п - число состояний реализации, т - число переходов реализации, к - число состояний спецификации. Заметим, что т=0 (Ьг^). Лемма 20: Алгоритм обхода реализации, описанный в данном подразделе, при указанных в 5.1 ограничениях заканчивает свою работу за конечное время и строит ЬТ8 I', порождаемую Н-безопасными маршрутами реализации I, и множества Н (1) для всех состояний из I '. При этом число тестовых воздействий имеет оценку 0(Ы;П) для 1:>1 и 0(Ьп2)для t=l. Объем вычислений имеет оценку О (Ьп1;п) +0 (Ьпт) +0 (тк) для Ь>1, для t=l первое слагаемое заменяется на 0(Ьп3). Доказательство. В силу конечности семантики и реализации, а также ограниченности недетерминизма реализации, блок «Воздействие+наблюдение» вызывается конечное число раз. Поскольку каждый цикл в схеме алгоритма содержит блок «Воздействие+наблюдение», любой другой блок алгоритма также вызывается конечное число раз. При вызове каждого блока, кроме перехода в неполное состояние и коррекции данных, выполняется, очевидно, конечное число действий. Каждый переход в неполное состояние также выполняется за конечное число шагов, как показано в [5]. Рекурсивная процедура коррекции данных работает конечное время в силу конечности реализации и спецификации. Тем самым алгоритм заканчивает свою работу за конечное время. Алгоритм заканчивается, когда все пройденные состояния стали полными. В этом случае, очевидно, все Н-достижимые состояния реализации и Н-безопасные переходы из них уже получены, то есть построенная ЬТ8 I' порождена всеми Н-безопасными маршрутами реализации. Все множества Н (1) для всех состояний из I' также построены, поскольку коррекция данных завершена. Число тестовых воздействий определяется главным образом временем работы блока перехода в неполное состояние. Хотя один такой переход может потребовать 0(1:п) для 1:>1 и 0(п) для t=l тестовых воздействий, суммарное число тестовых воздействий, как показано в [7], имеет оценку для 1:>1 не 0(п1;п),а 0(Ы;п),и 0(Ьп2)для t=l. Оценка объема вычислений состоит из трех слагаемых. 1) Число тестовых воздействий умножается на п для оценки числа операций, требуемых для поиска полученного постсостояния среди уже имеющихся состояний. Суммарная оценка: 0(Ьп1;п) для 1:>1 и 0(Ьп3)для t=l. 2) Построение леса деревьев. Лес деревьев строится не более bn раз, так как каждое состояние становится полным только в тот момент времени, когда в нем становится полной некоторая кнопка10. Как показано в [7], лес деревьев строится за О (т) операций. Суммарная оценка О (Ьпт). 3) Коррекция данных при получении нового перехода (рекурсивная процедура). Для каждого перехода i—u—>i' и каждого состояния seH(i) один раз выполняется следующее корректирующее действие: состояния из S (s, и) добавляются в Н (i ') и определяются те из них, которые ранее не принадлежали Н (i '). Сложность корректирующего действия зависит от представления данных. Заметим, что множества S (s, и) определяются только спецификацией и могут быть подготовлены заранее до начала тестирования. Корректирующее действие может быть выполнено за 0(1) операций, если множества состояний S (s, и) и H(i') задаются в виде битовых шкал11. Число пар (i—u—»i',s) имеет оценку О (mk). Поэтому суммарная оценка равна О (mk). Итоговая оценка объема вычислений О (bntn) +0 (bnm) +0 (mk) для t>l, для t=l первое слагаемое заменяется на О (bn3). □ 5.4. Два алгоритма верификации симуляции Мы опишем два алгоритма верификации симуляции после построения LTS I'. Каждый из них пытается построить конформное соответствие R, выдавая вердикт pass, если такое соответствие существует и построено, или вердикт fail, если такого соответствия быть не может. Один из этих алгоритмов строит наибольшее конформное соответствие Ri, а другой - соответствие R =RnH. Начнем со второго алгоритма. Сначала строится двудольный граф. Вершины первого типа - это пары (i, s), где i - состояние I', a s е Н (i). Вершины второго типа - это пары (i—u—>i ', s), где i—и—>i ' - переход I', a seН (i). В каждую вершину второго типа входит одна дуга (дуга первого типа) (i, s) —> (i—u—>i ', s). Дуга второго типа (i—u—>i ', s) —> (i', s ') проводится тогда, когда s'eS(s,u). Одновременно составляется список терминальных вершин второго типа. 10 Заметим, что полное состояние 1 может впоследствии стать неполным, если в Р (1) добавляется новая Н-безопасная кнопка. Однако это не может случиться после того, как все пройденные состояния стали полными, и коррекция данных завершена. 11 Если множество Б (в, и) задано в виде списка, а множество Н (1') - в виде битовой шкалы, то потребуется О ( к) операций. Если оба множества заданы в виде списка, то потребуется О ( к2) операций. После построения двудольного графа начинается собственно верификация. Каждая терминальная вершина v2 второго типа удаляется вместе с входящей в нее дугой vi—>v2, начальной вершиной v этой дуги - вершиной первого типа, и каждой входящей в нее дугой vx' -3>v . Одновременно для vi= (i, s) состояние s удаляется из множества Н (i). Эти операции повторяются до тех пор, пока не будет удалена одна из вершин первого типа (i0', s0), где io' el о, или пока не будут удалены все терминальные вершины второго типа. В первом случае алгоритм заканчивается с вердиктом fail, а во втором случае - с вердиктом pass. Первый алгоритм отличается от второго тем, что при построении двудольного графа мы каждое Н (i) делаем равным множеству Vs всех состояний спецификации. Лемма 21: Алгоритмы верификации, описанные в данном подразделе, при указанных в 5.1 ограничениях заканчивают свою работу за конечное время и выносят вердикт fail, если реализация неконформна, и вердикт pass, если реализация конформна. В последнем случае строится соответствие R={(i,s)|ieVI' & seH(i) }, которое для первого алгоритма совпадает с Ri, а для первого - с R2. Объем вычислений имеет оценку 0(mk2). Доказательство. Поскольку реализация и спецификация конечны, двудольный граф тоже конечен и, следовательно, строится за конечное время. Продолжение верификации связано с удалением некоторых вершин и друг из этого конечного графа, поэтому эта часть каждого из алгоритмов также завершается за конечное время. По построению этих алгоритмов очевидно, что они выносят правильный вердикт и при вердикте pass строят требуемое соответствие. Оценим сложность алгоритмов. Число вершин второго типа, то есть пар (i—u—>i ', s), имеет оценку О (mk). Поскольку в каждую вершину второго типа входит одна дуга первого типа, число таких дуг имеет оценку О (mk). Поскольку из каяедой вершины второго типа выходит число дуг, не превышающее число состояний спецификации, число таких дуг имеет оценку О (mk2). Поэтому суммарно построение двудольного графа требует О (mk2) операций. В наихудшем случае верификация требует однократного просмотра всех дуг двудольного графа, то есть имеет оценку 0(mk2) операций. Эта оценка сложности верификации по двудольному графу совпадает с оценкой сложности его построения. □ Последние две леммы дают следующую теорему. Теорема 6: Тест, основанный на алгоритме обхода реализации из подраздела 5.3 и любом из алгоритмов верификации из данного подраздела, является полным на классе семантик, спецификаций и реализаций, удовлетворяющих ограничениям из подраздела 5.1. Если тест заканчивает свою работу с вердиктом pass, то строится соответствие R= { (i, s) | i е Vn; - & seH(i) }, которое для первого алгоритма совпадает с Ri, а для второго - с R2. При этом число тестовых воздействий имеет оценку 0(btn) для t>l и О (bn2) для t=l. Объем вычислений имеет оценку О (bntn) +0 (bnm) +0 (mk2) для t>l, для t=l первое слагаемое заменяется на О (bn3). Учитывая, что m=0 (bnt), оценку объема вычислений можно записать в виде О (bntn) +0 (b2n2t) +0 (bntk2) для t>l, для t=l первое слагаемое заменяется на О (bn3). 5.5. Пример верификации симуляции На 0 приведен пример верификации симуляции. Семантика содержит как R-, так и Q-кнопки. Спецификация S демонстрирует все виды опасности: ненаблюдаемый отказ {у} (в состоянии 3), дивергенцию (в состоянии 4) и разрушение (в состоянии 5). Спецификация удовлетворяет собственной Н-гипотезе12 и, по лемме 10, конформна сама себе как реализация. Также приведены примеры еще одной конформной реализации Ii и одной не конформной реализации 12. После обхода реализаций будут построены LTS S', Ii' и 12'. Приведены двудольные графы для верификации соответствия по второму алгоритму с указанием соответствия Н, в которых серым фоном отмечены терминальные вершины второго типа, а пунктиром -удаляемые дуги. Для конформных реализаций приведены соответствия R2, а также соответствия Rx без двудольных графов, которые строятся аналогично. 12 Единственное проявление недетерминизма в спецификации - это два перехода 0—у—>1 и 0—у—>3. Но в этих состояниях безопасны одни и те же кнопки (кнопка {х}). к= I {х} >, <3={{уИ II х у © 51)—О У V X СОТ "Г ф V К ®= 3 и 3 К1={ 00,01,02 , 04, 1(1,11,12, 14, 20,21,22,2.1,24, 32,33, 34, 4(1,41,42,43,-14 } II и з Й:=( 00,01,02, 04, 12,13,14, 21),21,22,23,24 } Рис. 11. Пример верификации симуляции ]]></text>
</doc>
