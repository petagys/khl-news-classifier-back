<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/svoystva-shem-dannyh-xml]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Новак Л.Г.]]></item>
    <item type="str"><![CDATA[Кузнецов С.Д.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Свойства схем данных xml]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[Приводится формальное определение структурных частей (сигнатур) схем XML, основанное на регулярных грамматиках деревьев. Преимущество такого представления структурных ограничений заключается в том, что любую схему, выраженную на языке регулярных грамматиках деревьев, можно отобразить на существующие языки спецификаций схем XML, и наоборот, структурные ограничения, выраженные на наиболее распространенных языках спецификаций схем выразимы с помощью регулярных грамматик деревьев. Далее приводится классификация типов регулярных грамматик и их соответствие языкам спецификаций схем XML. Вводятся преобразования схем XML, приводящие их к эквивалентному виду (с точностью до отношения эквивалентности). Определяются нормальные формы схем и приводятся теоремы существования нормальных форм для любой схемы. Обсуждаются методы использования алгоритмов нормализации для решения практических задач, связанных с управлением XML-данными, в частности, для построения отображения моделей данных. Описываются логические языки, предназначенные для формулирования ограничений целостности XML.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Л.Г. Новак, С.Д. Кузнецов 1. Введение Расширяемый Язык Разметки (XML) [1] становится в последнее время доминирующим стандартом представления и обмена данными в Интернете. Подобно языку HTML, XML является поднабором языка SGML. Однако существует набор фундаментальных отличий XML от других языков разметки, одно из которых заключается в том, что разметка документа является семантической. Перечислим основные свойства языка XML [2]: - Независимый формат данных. При использовании XML как формата выходных и входных данных приложения, данные становятся независимы от самого приложения, что повышает способность взаимодействия. - Одни данные, несколько представлений. В силу того, что формат не зависит от приложения, очевидно, что одни и те же данные можно отображать разными способами и разными приложениями. - Улучшенные возможности поиска данных. Поскольку XML определяет семантическую структуру документа, это способствует созданию дополнительных возможностей для поиска информации. Например, индексирующие и поисковые средства могут работать не только с самими данными, но и с разметкой (метаданными) - Облегчение доступа к данным. В мире в настоящее время существует большое количество информации, доступ к которой затруднен из-за того, что она хранится в разнородных и несовместимых форматах. Перевод в формат XML откроет доступ к таким данным. - Более простая разработка приложений. XML делает необязательной реализацию поддержки большого количества бинарных форматов, вследствие чего разработка приложений становится значительно проще. - Использование готовых решений. При управлении данными, как правило возникает необходимость решения «шаблонных» задач, таких, как верификация данных, лексический и синтаксический разбор, и т.д. * Работа частично поддержана грантом РФФИ 02-01-01088-а Переход к формату XML способен убрать необходимость создания своих собственных реализаций для решения подобных задач. - XML файл может быть прочитан человеком. - XML поддерживается большим количеством стандартов. Эти стандарты предназначены для того, чтобы гарантировать совместимость приложений пользователя и готовых решений. В их число входят стандарты API для лексического и синтаксического анализа (SAX), стандарт для управления объектной моделью документа (DOM) и другие стандарты, которые будут рассмотрены ниже. Как видно из перечисленных свойств, в XML заложен потенциал для революционных изменений в области хранения и обработки данных. Из множества задач программирования, решаемых с помощью XML, можно выделить подкласс, включающий такие задачи, как обмен сообщениями между приложениями, управление данными некоторой предметной области, хранение полуструктурированных данных и т.д. [2,3]. Для каждой отдельно взятой задачи необходимо сужение допустимого множества XML-документов. Поэтому зачастую необходима спецификация множества возможных XML-документов, которые будут обрабатываться. Для этого используются словари XML-документов, по сути являющиеся схемами данных, представленных в формате XML. Здесь необходимо заметить, что логическая модель данных XML довольно близка к модели полуструктурированных данных [4]. Схемы XML (как и схемы данных, представленных в терминах любой другой модели данных) предназначены для описаний структурных и семантических ограничений, которые должны выполняться в любом экземпляре данных, соответствующем этой модели. Про множество данных, на которых выполняются ограничение схемы, говорят, что оно удовлетворяет данной схеме. Характерным примером структурного ограничения для XML-документов является спецификация содержания элементов (например, элемент с именем А может содержать только элементы с именем В), а примером семантического ограничения - спецификации ключей (атрибут а, содержащийся в элементе А, должен обладать уникальным значением среди множества значений атрибутов а). В текущее время существует около дюжины языков спецификаций схем данных, поддерживаемых различными организациями (W3C, OASIS и т.д.). Наиболее популярными языками являются DTD [1], XML Schema [5], RelaxNG [6], XDR [7]. Как отмечалось выше, все они предназначены для спецификации структурного и семантического содержания XML документов. Несмотря на то, что языки спецификации схем достаточно сильно различаются по выразительной силе, многие принципы построения ограничений схожи. В большей степени это касается структурных ограничений. Поэтому многие свойства структурных ограничений в терминах одного языка имеют свои аналоги для другого языка спецификации. Язык DTD является одним из наиболее простых языков спецификации схем. Выразительная мощность этого языка существенно ниже, чем в других [17], однако этот язык имеет определенные преимущества. Во-первых, DTD является де-факто стандартом спецификации схем (по крайней мере, пока стандарт XML Schema не будет окончательно утвержден). В большом количестве алгоритмов и программных средств, предназначенных для управления XML-данными, для определения используется именно DTD. Во-вторых, схемы DTD можно однозначно отобразить на другие XML-схемы. Стоит заметить, что решения многих задач управления данными XML инвариантны по отношению к выбору языка спецификаций, что облегчает переход от одной схемы к другой. Основной целью данной работы является изучение свойств XML-схем и методов преобразования схем данных над моделью XML, которые могут быть использованы в качестве вспомогательного инструмента для создания и реализации некоторых задач, связанных с управлением данными и метаданными XML. Основная идея нашего подхода заключается в разработке методики, позволяющей существенно упростить реализацию этих алгоритмов, за счет выделения подклассов из всего многообразия XML-схем. Выделенный подкласс должен обладать следующим свойством: реализация алгоритма для схем, принадлежащих данному подклассу, существенно упрощается по сравнению с алгоритмом, работающим на всем многообразии схем XML. Схемы, принадлежащие определенному подклассу, называются схемами, представленными в нормальной форме. Статья организована следующим образом. В начале мы приводим формальное определение структурных частей (сигнатур) схем XML, основанное на регулярных грамматиках деревьев. Преимущество такого представления структурных ограничений заключается в том, что любую схему, выраженную на языке регулярных грамматиках деревьев, можно отобразить на существующие языки спецификаций схем XML и наоборот, структурные ограничения, выраженные на наиболее распространенных языках спецификаций схем выразимы с помощью регулярных грамматик деревьев. В следующем разделе, мы приводим классификацию типов регулярных грамматик и их соответствие языкам спецификаций схем XML. Далее мы вводим преобразования схем XML, приводящие их к эквивалентному виду (с точностью до отношения эквивалентности). В четвертом разделе мы определяем нормальные формы схем и приводим теоремы существования нормальных форм для любой схемы. Затем, мы обсуждаем методы использования алгоритмов нормализации для решения практических задач, связанных с управлением XML-данными, в частности для построения отображения моделей данных. Наконец, в последнем разделе, мы описываем логические языки, предназначенные для формулирования ограничений целостности XML. 2. Структурные ограничения XML В этом разделе мы приводим формальное определение схем, состоящих из структурных ограничений, и формулируем термин «валидируемость». Также мы приводим определения эквивалентности схем и отношения порядка на схемах, которые будут использоваться в дальнейшем. Раздел начинается с определения регулярных выражений хорошо известных из литературы по грамматикам и языкам программирования. Определение 1 (Регулярные выражения над множеством символов Е). Множество регулярные выражения над множеством Е (reg(E))o^^enHKm^ следующим образом: 1) 6 - регулярное выражение, где е обозначает «пустой список». 2) Ve е Е: е- регулярное выражение. 3) Если ei - регулярное выражение, то (ei), ei*, ei?, ei+ - тоже регулярные выражения. 4) Если ei и е2- регулярные выражения, то ei,e2 и ei |ег - тоже регулярные выражения Определение 2(Порождаемые последовательности). Пусть г- регулярное выражение над множеством Е. Тогда конечная (м.б. пустая) последовательность s=[e0> еп] символов, где с,еЕ. порождается выражением г (s|=r), тогда и только тогда, когда выполняется одно из следующих соотношений: 1) Если г^е и s=[] - пустая последовательность; 2) 3eeE:i^eHS=[e]; 3) r=(ri) и s|=r ; 4) rsrj* и s e S, где S={[],[su sj }, где Vi: s, |=Гь 5) i=ri+ и s e S, где S={[si> }, где Vi: Si |=Гь 6) rsrj? и s e S, где S={[],[si] }, где Si |=Гь 7) 1=Г1 r2 и s=[e0,... ek, f0, fn], где [e0,... ej |=rj и [f0, fn] |=r2; 8) i^ri |r2 и s |=ri или s |=r. Множество всех порождаемых последовательностей регулярного выражения г над множеством Е называется регулярным множеством и обозначается так: ад. Пример 1. Пусть Е={0,1}. Множество последовательностей, порождаемых регулярным выражением (0|1)(0|1) состоит из множества последовательностей длины 2, содержащих элементы 0 и 1: [0,0];[0,!];[!,0];[1,1]. Регулярное выражение (0|1)* порождает множество последовательностей произвольной длины, состоящих из 0 и 1, то есть полное множество всех последовательностей над множеством Е. □ Определение 3 (Эквивалентность регулярных выражений). Пусть rbr2e reg(E). Тогда Гх =г2= если V s =[е0,.. еп] : s|= ri» s|= r2 Определение 3’ (Эквивалентность регулярных выражений). Пусть гьг2е reg(E). Тогда Ii=r2, если SRE(ri)<=> SRE(r2) Пример 2. Регулярные выражения г*,г и г+ эквивалентны, где г - произвольное регулярное выражение над множеством г. Покажем это. Пусть s|= г+ . Тогда по определению 2 s=[S| sM|. где Vi : s, |=r. Тогда Si|=r и [s2,..,sn]|=r* и, значит, s|= r*,r . В обратную сторону утверждение доказывается аналогично. □ Теорема 1 (Замена выражений). Пусть и f2 - есть идентичные регулярные выражения над множеством {Е,г}} и {Е,г2}, соответственно ,где г} и г2 -обозначения регулярных выражений над множеством Е (fi получается из f2 путем замены символа г2 на г} и наоборот). Пусть f i и f 2 - это два регулярных выражения над множеством Е, получаемые, соответственно, из fi и f2 с помощью замены символов г} и г2 на регулярные выражения над множеством Е. Тогда r2 = r1=>f ¡=f □ Например, из этой теоремы следует, что выражение а|а+ = а|(а*,а), так как а+ = (а*,а). Определение 4 (Структурные схемы XML документов). [12] Структурная схема XML документов есть совокупность (Т,Е,А,р,а,г), где: • Т - множество, состоящее из всевозможных доменов. • Е - множество типов элементов; тип элемента состоит из имени и условного обозначения, являющегося уникальным идентификатором типа. • А - множество типов атрибутов. Каждый тип включает в себя: о имя атрибута, о домен принимаемых значений о идентификатор обязательности (должен ли атрибут быть заполнен) о уникальный идентификатор типа атрибута. • р есть функция из множества Е в reg({E,T}). р:Е->- reg({id(E),Tj), где id(E)- множество уникальных идентификаторов типа элемента. • а есть функция из множества Е в множество всех подмножеств множества А - pows(A). a: E—>pows(A), причем для любого типа элементов е типы атрибутов из множества а(е) должны обладать уникальным именем. • г е Е и называется типом корневого элемента. Для Множества Е должно быть соблюдено следующее условие: Ve0e Е, е фх 3 (еоА^.еп): Vi<n е,еЕ и 3 последовательность s=[ao,..,aJ.be1,aJ,..an] se'.li; ij(E),T} (p(e1+i)), en=r. Это условие означает «достижимость до любого элемента от корня». Определение, данное выше, является достаточно универсальным способом спецификации структурных ограничений схем XML. Достаточно легко показать, что структурные ограничения, заданные выражениями на таких языках спецификации схем, как XML Schema, DTD, Relax NG отображаются в структурные схемы. В качестве примера, мы приведем пример отображения схемы, выраженной на языке DTD в структурную схему: Пример 3. <!ELEMENT Product (Name, Developer?, Summary?, Description?)> <!ELEMENT Name (#PCDATA)> <!ELEMENT Developer (#PCDATA)> <!ELEMENT Summary (#PCDATA)> <!ELEMENT Description (Para | List)+> <!ELEMENT Para (#PCDATA | Link)*> <!ELEMENT List (Item+)> <!ELEMENT Item (#PCDATA | Link)*> <!ELEMENT Link (#EMPTY)> <!ATTLIST Link URL СDATA #REQUIRED> Данной схеме DTD соответствует структурная схема (Т,Е,А,р,а,г), где: TS{#PCDATA} Es{{Product, product}, {Name, name}, {Developer, developer}, {Summary, summary} ,{Description, description },{Para, para },{List, list}, {Item, item}, {Link, link}} (здесь и далее тип элемента представляется как пара - {имя, Идентификатор}) AS{ (URL, СDATA, Required, url) } P = p(product)= (name, developer?, summary?, description?) p(name)= p(Developer)=p(Summary)= #PCDATA p(description)= (para | list)+ p(para)=p(Item) = (#PCDATA | link)* p(list)= Item+ p(link)= 6 a: a(link)={URL} a(product)=a(name)=...=a(list) S{ } r=productD Таким образом, можно установить, что при отображении в структурную схему каждому имени элемента в DTD соответствует уникальный тип элемента. Множество Т состоит из типа #PCDATA (Термин PCDATA обозначает произвольный набор символов, интерпретируемый синтаксическим анализатором как текстовый узел). Каждому атрибуту соответствует свой тип атрибута, значения которого устанавливаются согласно свойствам типа атрибута в DTD. Наконец, отображение р задается исходя из регулярных выражений, определяющих структуру элемента DTD. Однако, стоит отметить, что ограничения целостности, которые могут присутствовать в DTD (атрибуты типа ID или IDREF) никоим образом не отображаются на структурную схему. Ограничения целостности мы обсудим в последнем разделе работы. Заметим, что в зависимости от регулярного выражения, соответствующего элементам их типы можно классифицировать следующим образом: элементы пустого содержания : р(е) е {е}, элементы, содержащие данные : р(е) е reg(T)/{e}, элементы элементного содержания: р(е) е reg(id(E))/ {е}, элементы смешанного содержания : р(е) 6 reg({id(E),T})/{ reg(E)u reg(T)} В нашем примере, link - это элемент пустого содержания, name, developer, summary - элементы содержащие данные, product, description и list -элементного содержания, и наконец para и item - смешанного. Стоит заметить, что структурным схемам вида (Т,Е,А,р,а,г) однозначно соответствуют регулярные грамматики деревьев [13], если положить следующее: множество F и id(E) являются нетерминальными символами грамматики, где F - множество типов текстовых узлов, id(E) -множество уникальных идентификаторов типов элементов; Т и name(E) - терминалы грамматики, где name(E) - множество имен элементов; Отображение р(е) заменяется правилом продукции одного из следующих двух видов: х —> а г, где хе id(E), ае name(E), re reg({E,F}) или х —^ а s,где хе F, аеТ. В следующем разделе мы опишем классы регулярных грамматик и их соответствие языкам спецификаций схем. Следующие определения описывают понятие валидируемости XML документа. Здесь и далее XML документ рассматривается в рамках модели XML, представленной в первой главе. Определение 5 (Интерпретация). Интерпретация I XML документа D в терминах структурной схемы S=(T,E,A,p,a,r) - это набор отображений 1=(ф,Ф,ст), где: ф - это отображение Ес, -множества элементов документа, на множество Е; Ф - это отображение AD, -множества атрибутов документа на множество А; ст - это отображение TD, - множества текстовых узлов документа на множество Т. Также должны выполняться следующие условия: (согласование имен элементов) Пусть name - функция, ставящая в соответствие узлу документа его имя. Тогда Vee Ed: name(e)= name (ф(е)); (согласование имен и значений атрибутов) Пусть value-функция, ставящая в соответствие узлу документа его значение. Тогда Vae AD: name(a)= name (ф (a)), value(a) e do 111(9 (а)), где dom(x) - это домен принимаемых значений типа атрибута; (согласование текстовых узлов) Vte TD: value(t) ест (t) (согласование атрибутов с элементами) Пусть Ае= ¡а, | i=[0,..,ne] - множество атрибутов элемента е. Тогда Vee ED: Vi е [О,.., Пе] ф(аО еа(ф(е)); (согласование обязательных атрибутов) ф_1(е8) - множество элементов документа D, которые отображаются в тип элемента es. Также пусть R(es) - это подмножество a(es), в которое входят те и только те типы атрибутов, у которых проставлен идентификатор обязательности. Тогда VeseE Vase R(es) Veeф" '(es) Эае Ae: ф(а)= as; (согласование корневого элемента) Для rD - корневого элемента документа D : ф( rD)=r; (согласование содержания элемента) Пусть Се = [ео,..,еп] - есть упорядоченная последовательность элементов и текстовых узлов, вложенных в е. Тогда Vee ED: 1(е0),.-> 1(е„) |= р(ф(е)), где 1(е0 - это одно из двух отображений {ф,а} (в зависимости от типа узла). Определение 6 (Валидность). Документ D является валидным документом для структурной схемы S (удовлетворяет схеме S'), если существует интерпретация I в терминах S (Обозначается D|=S). Данное определение является ключевым для всего дальнейшего рассмотрения. Введем следующее обозначение: DB(S) - множество всех документов XML, удовлетворяющих данной схеме. Утверждение 1 (Корректность валидности). Пусть D - схема, выраженная на языке спецификации DTD и S - соответствующая ей структурная схема. Тогда DB(D)c3DB(S). Если схема D не содержит ограничений целостности, тогда DB(D)=DB(S). Для доказательства утверждения достаточно использовать свойства отображения схем DTD в структурные схемы (они очевидно следуют из примера 3). □ Аналогичные утверждения можно сформулировать и доказать для других языков спецификации схем. Заметим, что далеко не всегда существует единственная интерпретация одного и того же документа. Нижеследующий пример демонстрирует случай множественной интерпретации одного и того же документа. Пример 4. На Рис. 1 представлена структурная схема и документ XML. Т={#РСОАТА} Е=||А а}, {В, Ь4, {В, ад, {С, с}} R- р(а)= (bil hi) p(bi)= (с) p(bj)= (с)* Р(С)= s а: а(а)={Ь}= а(с) =0 а) Рис. 1. а) структурная схема; б) документ Документ XML содержит три элемента: А, В и С. Исходя из определения интерпретации, отображение I должно ставить в соответствие каждому элементу тип элемента из множества Е с таким же именем, как и у элемента. Поэтому в любой интерпретации элементу А соответствует тип а, элементу С тип с. А вот для элемента В существует два разных типа в которые он мог бы отображаться bi и b Достаточно легко убедиться, что в обоих случаях будут выполняться условия интерпретации.□ Определение 7 (Тривиальные схемы). Структурная схема называется тривиальной, если существует и притом единственный XML документ, валидный для данной схемы. Утверждение 2 (Существование тривиальной схемы). Для любого XML документа существует тривиальная структурная схема, для которой данный документ валиден. Для доказательства утверждения достаточно воспользоваться индукцией по глубине документа XML - максимальному расстоянию от корня дерева XML до листа. База индукции при п= В этом случае документ XML должен иметь следующий вид (представление в терминах модели XML [1]) - Рис. 2. <?xml version="1.0" encoding="UTF-8" ?> - <А> - <В> <С /> </В> </А> б) Рис 2. XML документ глубины 1 Как видно из рисунка, все узлы дерева помимо корня являются листами. Для формирования структурной схемы, необходимо выполнить следующие действия: 1) Множество Е формируется следующим образом: для каждого узла типа «элемент», мы создаем отдельный тип элемента. 2) Множество А формируется следующим образом: для каждого узла типа «атрибут», мы создаем отдельный тип атрибута. Доменный тип состоит из одного значения - значения данного узла в документе. 3) Множество Т формируется следующим образом: для каждого текстового узла в документе мы создаем отдельный домен, состоящий только из одного значения. 4) Отображение а задается по следующим правилам: для любого типа элемента е - множество а(е) состоит из типов атрибутов, соответствующих атрибутам того элемента XML, который задавал е. 5) Отображение е задается по следующим правилам: для любого типа элемента е - р(е) - это выражение вида (е0,..,еп) где с, это либо тип элемента, либо домен, задаваемый i-м дочерним узлом того элемента XML, который задавал е. 6) Тип элемента г (корневой тип) задается корневым элементом дерева XML. Легко убедиться, что исходный документ удовлетворяет данной схеме. Также любой XML документ, удовлетворяющий данной схеме, совпадает с исходным документом. То есть схема является тривиальной. Индуктивный переход осуществляется следующим образом. Пусть утверждение доказано для документа, максимальная глубина которого равна п. Пусть у нас есть документ XML глубины п+1. В терминах XML модели, его можно представить в виде дерева глубины п+1. Рассмотрим множество поддеревьев, с корнями в дочерних узлах корневого документа исходного дерева. Их максимальная глубина не превышает п. По предположению индукции им ставятся в соответствие тривиальные схемы. Общая схема формируется путем объединения множеств Е,Т,А каждой из этих тривиальных схем и продлением отображений аир. Затем мы формируем еще один тип элемента г, соответствующий корню исходного XML документа, и продляем отображения а и р на него. Отображение а(г) возвращает множество атрибутов корневого элемента, a p(r)=(r0> гп), где г, - корневой тип элемента тривиальной схемы, порожденный i-м узлом. □ Способ создания тривиальной схемы, использованный в утверждении 2, задает инъективное отображение множества документов XML на множество схем. Этот результат используется в работе [15] для реализации алгоритмов трансляции выражений алгебры управления структурными схемами в выражения языка запроса к данным XML. Легко показать, что все домены из множества Т - доменных типов тривиальной схемы содержат в точности одно значение. Лемма 1 (Достаточное условие тривиальности). Любая схема S=(T,E,A,p,a,r) такая, что для любого типа элементов е, регулярное выражение р(е) имеет вид rh..,rn, где г, есть символы базового алфавита, является тривиальной или пустой схемы. □ 3. Классы регулярных грамматик В этом разделе мы приводим классификацию структурных схем. Данный метод заимствован из работы [13], где он используется для классификации грамматик деревьев. Определение 8 (Локальные структурные схемы). Структурная схема называется локальной, если не существует двух типов элементов с одинаковым именем. Структурная схема из примера 3 является локальной, в то время как схема из примера 4 не является таковой. Следующее утверждение выполняется для локальных схем. Утверждение 3 (Единственность интерпретации). Пусть S=(T,E,A,p,a,r) локальная структурная схема и XML документ D валиден для S. Пусть также любые два домена из множества Т не пересекаются и для любого типа элемента е, мультимножество имен типов атрибутов из множества а(е) содержит только уникальные значения. Тогда существует, и, притом единственная интерпретация документа D в терминах S. Существование интерпретации следует из самой формулировки утверждения. Для доказательства единственности воспользуемся формулировкой интерпретации. Из правила согласования имён элементов, и локальности схемы следует, что в любой интерпретации каждый элемент документа XML должен отображаться на один и тот же тип элемента, так как имена всех типов уникальны. Из того, что любые два домена не пересекаются и из свойства согласования текстовых узлов следует, что в любой интерпретации каждый узел документа XML должен отображаться на один и тот же домен. Таким образом, достаточно проверить, что отображение атрибутов сохраняется в любой интерпретации. Эго следует из свойств согласования атрибутов с элементами, согласования имен и значений атрибутов и из того, что для любого типа элемента е, мультимножество имен типов атрибутов из множества а(е) содержит только уникальные значения. □ Прежде чем описать следующий класс структурных схем, приведем следующее определение, относящееся к регулярным выражениям: Определение 9 (Допустимые символы). Пусть г- регулярное выражение над множеством М. Тогда Ам(г) - это множество, содержащее все элементы из М, которые присутствуют в записи регулярного выражения. Например, если Е={0,1,2}, то Дм((0*,1*))= {0,1} Теорема 2 (Критерий допустимости). Пусть г- регулярное выражение над Е. Тогда Ve еЕ: е еДм(г) Э s=[e0i..ei.1, e,ei+1,.., еп]: s \ =г Определение 10 (Однотипные структурные схемы). Структурная схема S=(T,E,A,p,a,r) называется однотипной, если для любого типа элемента е, все типы элемента из множества ДЕ(р(е)) обладают разными именами. Определение 11 (Ограничено-однотипные структурные схемы). Структурная схема S=(T,E,A,p,a,r) называется ограниченно-однотипной, если для любого типа элемента е, выполняется следующее условие: Vs1=(e0,..,en), Vs2=(е’0,..,е’щ), где s1\=p(e) и s2\=p(e), и Vi: Vj<i е)= ej => пате(е)^пате(е У Следующие два утверждения очевидны и будут приведены без доказательств. Утверждение 4 (Вложение типов). Любая локальная структурная схема является однотипной структурной схемой. Любая однотипная структурная схема является ограниченно-однотипной структурной схемой. □ Утверждение 5 (Достаточное условие однотипности). Пусть структурная схема S=(T,E,A,p,a,r) обладает следующим свойством: VeeE: \Ам(р(е))\<=1 (Количество допустимых символов не превышает 1). Тогда S является однотипной структурной схемой. □ Утверждение 6 (Единственность интерпретации) Пусть S=(T,E,A,p,a,r) ограниченно-однотипная структурная схема и XML документ D валиден для S. Пусть также любые два домена из множества Т не пересекаются и для любого типа элемента е, мультимножество имен типов атрибутов из множества а(е) содержит только уникальные значения. Тогда существует и притом единственная интерпретация документа D в терминах S. Для доказательства этого утверждения необходимо воспользоваться свойством согласования содержания элемента. В заключении этого раздела, заметим, что исследования, проведенные в работе [13] показали, что множество структурных схем, соответствующих схемам, выраженным на языке DTD принадлежит классу локальных структурных схем. Множество структурных схем, соответствующих схемам, выраженным на языке DTD принадлежит классу однотипных структурных схем. И наконец, множество структурных схем, соответствующих схемам, выраженным на языке Relax NG, является полным множеством структурных схем. 4. Преобразования структурных схем В этом разделе мы обсудим различные методы преобразования структурных схем. Эти преобразования можно разделить на три вида: Эквивалентные преобразования - приводящие к схеме эквивалентной исходной. Слабо-эквивалентные - приводящие к схеме, множество валидируемых документов, которой совпадает с множеством валидируемых документов исходной схемы с точностью до перестановки порядка элементов в документе. Упрощающие - приводящие к схеме не эквивалентной исходной. Однако для любого документа, валидируемого исходной схемой должен существовать документ валидируемый получаемой схемой, отличающийся только порядком следования элементов. Определение 12 (Эквивалентность структурных схем). Схемы D и D’ эквивалентны, если множества валидируемых XML документов каждой из этих схем совпадают. Теорема 3 (Достаточное условие эквивалентности). Дее схемы S=(T,E,A,p,a,r) и S’=( Т’,Е’,А’,р’,а’,г) эквивалентны если существует взаимно однозначное отображение М=(ф,ср,ст), где ф:Е—> Е’ ; ср: Е—> Е’; ст: Т—> Т’ обладающее следующими свойствами (отображение М'1 обладает аналогичными свойствами): 1) a(t)^t 2) пате(е)= пате(ф( е)) 3) ф(г) 4) а=(р (а) (сохраняются все свойства типов атрибута) 5) Ve Vaea(e): ср(а) еа’(ф(е)) иЩф(е))сср(а(е)) 6) Vs=[sa..,snJ s\ =p(e)^s ’=[М(е0),..,М(е„)]\ =р ТФ(е); Для доказательства достаточно проверить, что каждый XML документ, удовлетворяющий схеме S должен удовлетворять схеме S’ . Проверка того, что каждый XML документ, удовлетворяющий схеме S’ удовлетворяет схеме S, производится аналогично. Итак, пусть D|=S , где D - XML документ. В силу определения 6 должна существовать интерпретация 1=(ф’,ср’,ст’) документа D в терминах S. Рассмотрим отображение Г=М«1 =(ф«ф’, <р«<р'. ст»ст’). Докажем, что это интерпретация документа D в терминах S’. 1) Vee Ed: name(e)= name (ф’(е))=пате(ф»ф’(е)) (согласование имени элементов). 2) Vae Ad: name(e)= name (<p'(a))=name(<p«<p' (a)) value(a) edom(cp’(a)) = dom(<p«<p'(a)) (согласование имен и значений атрибутов). 3) Vte TD: value(t) ест’ (t) =ст»ст’ (t) (согласование текстовых узлов) 4) V Эе £ Ае : ср ‘( Эе) еа(ф’(е)) =лр»ф’ ( aj е а(ф»ф’ (е)) (согласование атрибутов с элементами). 5) Vee Ed: I(e0),.., I(en) |= р(ф’(е)) I(e0),.., I(e„) |= р(ф.ф’ (e)) (согласование содержания элемента). Остальные свойства интерпретации проверяются аналогично. □ В случае, когда Е=Е’ шестое условие принимает следующий вид р=р. Следствие 1 (Критерий эквивалентности схем, отличающихся только структурами). Пусть S=(T,E,A,p,a,r) и S’=( Т,Е,А,р’,а,г) две структурные схемы, у которых множество валидируемых XML документов непустое, и отличающиеся только регулярными выражениями, задающими структурное вложение. Тогда схемы S и S’ эквивалентны тогда и только тогда, когда Vee Ер(е) =р ’(е). Достаточное условие является следствием теоремы 3, а необходимое условие проверяется на множестве экземпляров XML документов, удовлетворяющих схемам. □ 4.1. Эквивалентные преобразования Утверждение 7 (Эквивалентные регулярные выражения). Следующие регулярные выражения являются эквивалентными: (г) =г (3.1.1) r?=r|s (3.1.2) r+sr*,r (3.1.3) r**=r* (3.1.4) rl| r2 = r2|rl (3.1.5) Oil r2),r3s ( ru r3)|( ru r2) (3.1.6) 8*se (3.1.7) (rx| r2)* = ( Г!*, r2*)* (3.1.8) r*= r+|s (3.1.9) r, e=r (3.1.10) I-!*, rf= rt* (3.1.11) rt*, n+s rt+ (3.1.12) rt*, rt?s rt* (3.1.13) r?*=r* (3.1.14) r+*=r* (3.1.15) r++=r+ (3.1.16) (rx|r2)+ = ( rx+,r2+)+|( r2+, rt+)+| n+| r2+|( rt+, r2+)+,n+|( r2+, rx+),r2+ (3.1.17) Доказательство этого утверждения хорошо известно из теории регулярных грамматик. Заметим, что перечисленные пары регулярных выражений далеко не исчерпывают полный список эквивалентных регулярных выражений. □ Утверждение 8 (Эквивалентные преобразования структурных схем). Пусть 8=( Т,Е,А,р,а,г) - структурная схема. Тогда любая схема, получаемая из данной путем замены регулярного выражения на эквивалентное приводит к схеме 8’=( Т,Е,А,р ’,а,г) эквивалентной исходной схеме. □ 4.2. Слабо-эквивалентные преобразования Определение 13 (Слабо-эквивалентные регулярные выражения). Два выражения ^ и г2 являются слабо-эквивалентными (г, и г2) , если для любой последовательности 5=[50..5П], такой что в|= Г! существует последовательность 5 =[5к(о)- 5к(п)] • где к есть подстановка на множестве {0,..,п} , такая что 5'|= г2 и наоборот, ДЛЯ любой последовательности 5=[50..5П], такой что в|= г2 существует последовательность 5'=|5|1()|..5|:1М1 ] , где к есть подстановка на множестве {0,..,п}, такая что 8’|= Г1 . Утверждение 9 (Слабо-эквивалентные регулярные выражения). Следующие регулярные выражения являются слабо-эквивалентными: Г1,Г2® г2, Гх (3.2.1) (гх*, г2)*я е| Гх*, г2+ (3.2.2) Докажем сначала первое утверждение. Пусть 5=|sO .su| |= гьг2 Тогда из Определения 2 Следует, ЧТО 5=[е0>... вь Г() ГМ|. где [е0>... ек] | = Г| и |Г, ГМ| |=г2 Значит 5 =| ^ ,4 ,е0,...,ек] |= г2, ^ Докажем второе утверждение. Пусть 5|=(Г1*, г2)* Рассмотрим два случая: в-пустая или непустая последовательность. Если в=[], то 5|=е. Пусть в непустая последовательность символов. Тогда в можно представить в следующем виде [8^-Х(1)У,--,8о,--,8к(п),8П], где 81|= Г1 ^ 8‘|= г . Тогда последова- тельность 8,= [во8^(1)в”8^(п),в1в"] 1= Г!*, г2+. Что и требовалось доказать. В обратную сторону утверждение доказывается аналогично. □ Определение 14 (Ослабленная интерпретация). Ослабленной интерпретацией I ХМЬ документа Б в терминах структурной схемы 8=(Т.Е. А.р.а.г) называется набор отображений 1=(ф,ср,ст), удовлетворяющий всем свойствам интерпретации, кроме согласования содержания элемента. Условие согласования содержания элемента заменяется следующим: (согласование содержания элемента) Пусть Се = [ео,..,еп] - есть упорядоченная последовательность элементов и текстовых узлов, вложенных в е. Тогда \/ее Е,,: 1(е |:1()1).... 1(е |1М1) |= р(ф(е)), где к(0- есть подстановка на множестве {0,..,п}. Определение 15 (Ослабленная Валидность). Документ Б является ослабленно-валидным документом для структурной схемы 8 (слабо удовлетворяет схеме 5^, если существует ослабленная интерпретация I в терминах 8 (Обозначается БИБ). Определение 16 (Слабая эквивалентность структурных схем). Схемы D и D’ слабо эквивалентны, если множества слабо валидируемых XML документов каждой из этих схем совпадают. Следующие утверждения являются очевидными и приводятся без доказательства. Утверждение 10 (Слабая эквивалентность эквивалентных регулярных выражений). Если регулярные выражения являются эквивалентными, то они являются слабо-эквивалентными. □ Следствие 2 (Достаточное условие слабой эквивалентности). Если схема S и S’ являются эквивалентными, то они являются слабо-эквивалентными. □ Теорема 4 (Критерий слабой эквивалентности схем, отличающихся только структурами). Пусть S=(T,E,A,p,a,r) и S’=( Т,Е,А,р’,а,г) две структурные схемы, у которых множество валидируемых XML документов непустое, и отличающиеся только регулярными выражениями, задающими структурное вложение. Тогда схемы S и S’ эквивалентны тогда и только тогда, когда Vee Ер(е) &p’(e). □ Как будет показано в дальнейшем, в силу того, что при слабо-эквивалентных преобразованиях (замене регулярного выражения на слабо-эквивалентное) теряется только семантика порядка следования элементов, то их удобно использовать для трансляции из XML модели в модели, не использующие порядок в структурном описании. Также, преобразование 3.2.2 ведет к «выравниванию» схемы (в английской литературе используется термин “flattening”), тем самым, приводя её к более простому виду - без вложенных операторов Клини (*). Отдельно стоит заметить, что преобразование (rl9 г2)*-> Гх*, г2* , часто встречающееся в алгоритмах трансляции XML модели в реляционную, не является слабо-эквивалентным. 4.3. Упрощающие преобразования Все преобразования, которые будут представлены ниже, ведут к потере определенной, достаточно большой части информации о структуре документа. Однако они достаточно часто используются на практике. Обусловлено это тем, что упрощение структурных ограничений приводит к существенному уменьшению сложности решения многих задач, встречающихся на практике. Определение 17 (Упрощение регулярного выражения). Регулярное выражение г2 над Е является упрощением р. в. г} над Е (г} { г2) , если множество символов Е, формирующих г2 , совпадает с множеством символов, формирующих г}, и выполняется следующее условие. Для любой последовательности s=[s0..s„] такой, что s|= г} существует последовательность 5’=/%о>.%идУ , где к есть подстановка на множестве [0,п] и s’|= г. Утверждение 3 .Для регулярных выражений г1 и г2 г1 (г2, г2 (г1<^>г1 &г2, г1 =г2=>г1 (г2, г2 (г1 Для доказательства первого предложения в прямую сторону (г} ( г2, ( ?!=>?! г2) достаточно воспользоваться определением упрощения. Чтобы доказать утверждение в обратную сторону, необходимо воспользоваться критерием допустимости символов из множества Е (теорема 2). Вторая часть утверждения вытекает из первой и из утверждения 10. □ Из этого утверждения непосредственно вытекает, что слабо-эквивалентные и эквивалентные преобразования являются упрощающими. Утверждение 4. (Упрощающие преобразования) Следующие преобразования регулярных выражений являются упрощающими: (гь г2)* < г,*, г2* (3.3.1) Оь г2)+ < г,+, г2+ (3.3.2) (г19 г2)? < Г1?, г2? (3.3.3) (Г1|Г2) < Г1?, г2? (3.3.4) Г1?, Г!? < Г1* (3.3.5) гх+, |-1+( г,+ (3.3.6) Доказательство этого утверждения напрямую следует из определения порождаемых последовательностей. Заметим, что мы перечислили не все упрощающие преобразования. □ Пример 5. Дано следующее описание элемента : <!ЕЬЕМЕЫТ а ((Ь|с|е|)?,(е?|(1?,(Ь,Ь)*))*)> ((Ь|с|е|)?,(е?|(Г?,(Ь,Ь)*))*) < (Ь|с|е|)?,(е?|(ет,Ь*,Ь*))* < (Ь|с|е|)?,(е?|(Г?,Ь*))* < (3.3.1) (3.1.11) (3.3.4) (Ь|с|е|)?,(е??,(17,Ь*)?)* < (Ь|с|е|)?,(е??,1??,Ь*?)* <Ь?,с?,е?,(е??Л?,Ь*?)* < (3.3.3) (3.3.4) (3.3.1) Ь?,с?,е?,е??*,1??*,Ь*?* Ь?,с?,е?,е*,1^*,Ь* (Ь*,с?,е*,Р (3.1,4),(3.1.14) (3.1),(3.1.13) Как видно из примера исходная схема приобретает весьма простой вид. Следует учесть, что информация об относительном порядке элементов утеряна, но при этом семантика множественности сохранена (например, элемент с может быть максимум один у элемента а). Определение 18 (Упрощение схемы). Схема Б’ является упрощением схемы Б, если множество валидируемых документов первой схемы принадлежит множеству слабо-валидируемых элементов второй. Критерий и достаточное условие того, что схема Б является упрощением схемы Б’, формулируются и доказываются таким же образом, как и для слабоэквивалентных схем. В следующем разделе, мы определим нормальные формы схем ХМЬ документов и докажем теоремы существования нормальных форм произвольных структурных схем. 5. Нормальные формы структурных схем В этом разделе мы опишем нормальные формы структурных схем: представлений структурных ограничений, записанных определенным образом. Также мы сформулируем и докажем теоремы существования нормальных форм для любой структурной схемы. 5.1. Первая нормальная форма Определение 19 (Конъюнктивно-множественные регулярные выражения). Конъюнктивно-множественные (к.-м.) регулярные выражения над множеством Е (геяхм^)определяются следующим образом: 1) 6 - к.-м. регулярное выражение, где е обозначает «пустой список». 2) \/е е Е: е- к.-м. регулярное выражение. 3) Если Г1 - к.-м. регулярное выражение, то (Г1), Г1*- к.-м. регулярные выражения. 4) Если Г1 и г2— к.-м. регулярные выражения, то гь г2 - к.-м. регулярные выражения. Определение 20 (Первая нормальная форма). Схема 8=(Т,Е,А,р,а,г) представлена в первой нормальной форме (эквивалентная форма), если : Уе е Ер(е)=г0|..|гп, где VI г; е геякм({¡ё(Е),Т}) Теорема 5 (Существование первой нормальной формы). Для любой схемы 8=(Т.Е. А.р.а.г) существует схема эквивалентная ей, которая представлена в первой нормальной форме. Для доказательства этой теоремы следует воспользоваться следствием 1 из теоремы 3. Пусть е - некий элемент схемы 8=(Т,Е,А,р,а,г). Соответственно р(е) - регулярное выражение. Используя эквивалентные преобразования регулярных выражений г?=г|е (3.1.2) и г+=г*,г (3.1.3) мы приходим к регулярному выражению, соответствующему исходному, но не содержащему операций ? и +. После чего следует воспользоваться преобразованиями (1*1! |'2),|'з= ( г„ г3)|( гь г2) (3.1.6) и (г,| г2)* = ( г,*, г2*)* (3.1.8), после которых 208 операция конкатенации (“|”) «поднимается». Таким образом, для любого типа элемента е, р(е) преобразуется в выражение р’(е) вида г0|..|гп, где VI г, е rcgк\|( {¡сКЮ/Т'). В силу следствия 1 новая схема 8’=(Т,Е,А,р’,а,г), представленная в первой нормальной форме, эквивалентна схеме 8. □ Следует заметить, что для регулярных выражений с использованием операции позитивного замыкания (“+”) вместо операции Клини (“*”)теорема о существовании нормальной формы также верна. Определение 19’ (Конъюнктивно-множественные регулярные выражения). Конъюнктивно-множественные (к.-м.) регулярные выражения над множеством Е (гея^(^)определяются следующим образом: 1) 6 - к.-м. регулярное выражение, где е обозначает «пустой список»; 2) \/е е Е: е- к.-м. регулярное выражение; 3) Если Г1 - к.-м. регулярное выражение, то (Г1), Г1+- к.-м. регулярные выражения. Если Г1 и г2 - к.-м. регулярные выражения, то гь г2 - к.-м. регулярные выражения. Принимая альтернативное определение конъюнктивно-множественных регулярных выражений, доказательство теоремы 5 частично меняется. Так, вместо преобразования г+=г*,г используется г*=г+|е (3.1.9). А вместо преобразования (гх| г2)* = ( г,*, г2*)* для поднятия конкатенации применяется (г1|г2)+ = (Г1+,Г2+)+|( г2+, Г!+)+| гх+| г2+|( гх+, г2+)+,Г!+|( г2+, Г!+),Г2+ (3.1.17) Пример 6. Приведем к первой форме г0|..|гп , где У\ г, е regкм({ЩЕ),Т}) следующее регулярное выражение: ((Ь|с)?,(17,Ь*)*), используя эквивалентные преобразования: (Ь|с)?,(17,Ь*)*г(Ь|с|б),((^б),Ь*)*г(Ь|с|б),((^Ь*)|(Ь*))*г(Ь|с|б),((^Ь*)*,(Ь**))*г (Ь|с|б),((^Ь*)*,Ь*)*г(Ь|с|б),((^Ь*)*)*г(Ь|с|б),(^Ь*)*гЬ,(^Ь*)*| с,(^Ь*)*| (^Ь*)*. □ 5.2. Вторая нормальная форма Определение 21 (Конъюнктивные регулярные выражения). Конъюнктивные (к.) регулярные выражения над множеством Е (ге."к(/0 Определяются следующим образом: 1) 6 - регулярное выражение, где е обозначает «пустой список»; 2) \/е е Е: е- к. регулярное выражение; 3) Если Г1 - к. регулярное выражение, то (г, )-к. регулярные выражения; 4) Если Г1 и г2— к. регулярные выражения, то гь г2 - тоже к. регулярное выражение; 5) Если г =(ео, еп), где VI: с,е Е, то г* и г+ - к. регулярные вьфажения. Определение 22 (Вторая нормальная форма). Схема 8=(Т,Е,А,р,а,г) представлена во второй нормальной форме (слабо-эквивалентная нормальная форма), если: Уе е Ер(е)=г0|..|гп, где VI г; е геяк(Е) Теорема 6 (Существование второй нормальной формы). Для любой схемы Б=(Т,Е,А,р,а,г) существует схема слабо-эквивалентная ей, представленная во второй нормальной форме. Для доказательства этой теоремы, необходимо воспользоваться результатами Теоремы 5. Для исходной схемы 8 существует эквивалентная схема 8’, структурные ограничения которой имеют вид г0|..|гп , где VI г, е regкм(E). Далее, для каждого ^ мы воспользуемся преобразованием (г,*, г2)*» в| г,*, г2+ (3.2.2) для уменьшения вложенных операторов * и +. После чего, если выражение г2 содержит операцию *, то воспользуемся преобразованием (3.1.3) для замены оператора г2+ на г2*,г Таким образом, используя индукцию по длине регулярного выражения и по глубине «вложенности» операций * и +, приходим к доказательству теоремы. Используя преобразования (3.2.1) и (3.1.11)-(3.1.16) можно добиться существенного упрощения выходной формы. □ Пример 7. Приведем регулярное выражение из предыдущего примера ко второй нормальной форме. (Ь|с)?,(17,Ь*)*гЬ,(^Ь*)*| с,(^Ь*)*| (^Ь*)*»(Ь|с|б)(Ь^+|е)«1^+|Ь|сЬ*1'+|с|1^+|б« Ь|с1^+|сЦ^+|б (в последнем переходе использовалось эквивалентное преобразование г*|г+=г*). □ 5.3. Третья нормальная форма Определение 23 (Простые регулярные выражения). Простые (п.) регулярные выражения над множеством Е («%//ООпределяются следующим образом: 1) 6 -п. регулярное выражение, где е обозначает «пустой список»; 2) \/е е Е: е- п. регулярное выражение; 3) Если Г1 и г2— п. регулярные выражения, то гь г2 - тоже п. регулярное выражение; 4) Если г =е , где ее Е, то г* ,г? г+ - п. регулярные выражения. Определение 24 (Третья нормальная форма). Схема 8=(Т,Е,А,р,а,г) представлена во третьей нормальной форме (простая нормальная форма), если: \/е е Е р(е)=г, где г е regs(E) Теорема 7 (Существование третьей нормальной формы). Для любой схемы Б=(Т,Е,А,р,а,г) существует схема, являющаяся ее упрощением, и представленная в третьей нормальной форме. Для доказательства этой теоремы следует воспользоваться упрощающими преобразованиями для построения новой структурной схемы, являющейся упрощением исходной схемы и представленной в третьей нормальной форме. Для доказательства того, что такая схема существует необходимо воспользоваться индукцией по длине регулярного выражения. □ Пример 8. Рассмотрим регулярное выражение из примера 7. (b|c)?,(f?,b*)*—>(b?,c?)?,f?*,b**—>b??,c??,f?*,b**—>b?,c?,f*,b*—>b*,c?,f* В отличие от первой и второй нормальных форм, для третьей нормальной формы можно сформулировать и доказать теорему единственности. Пусть на множестве Е введено отношение порядка. Тогда, определим простые упорядоченные регулярные выражения следующим образом. Определение 25 (Простые упорядоченные регулярные выражения). Простые упорядоченные (п. у.) регулярные выражения над множеством Е (геяда(^)определяются следующим образом: 1) 6 -п. у. регулярное выражение, где е обозначает «пустой список»; 2) Ve е Е: е- п. у. регулярное выражение; 3) Если г =е , где ее Е, то г* ,г? г+ - п. у. регулярные выражения; 4) Если Ti и г2— п. регулярные выражения, и Vai,a2 е Е. таких, что 3si= [e0,..,ei-i,ai,ei+i,..,en], s2= [e’0,..,e’i-i,a2,e’i+i,..,e’J Si|=rb и s2|=r2 верно, что ei<e2, то rb r2 - тоже п. у. регулярное выражение. Определение 24’ (Третья нормальная форма). Схема S=(T,E,A,p,a,r) с заданным отношением порядка на множестве Е представлена в третьей нормальной форме (простая нормальная форма), если: Ve е Е р(е)=г, где г е regSO(E) Если не существует двух типов элементов с одинаковым именем, то отношение порядка на множестве Е может соответствовать лексикографическому порядку на множестве имен элементов. Теорема 8 (Существование и единственность третьей нормальной формы). Для любой схемы S=(T,E,A,p,a,r), такой, что на множестве Е задано отношение порядка, существует и единственная схема S’=(T,E,A,p’,a,r) , представленная в третьей нормальной форме, являющаяся ее упрощением. □ 6. Применение Нормальных форм В этом разделе мы приводим краткий обзор способов применения нормальных форм при решении типичных задач управления данными. Валидация XML документов. Валидация XML документов является одним из наиболее распространенных средств управления XML документами. Валидация документов используется при создании XML-СУБД, обмене сообщениями, трансформации XML документов. Одна из основных проблем при валидации документа заключается в том, что до сих пор не существует единого стандарта для XML схем: схемы могут быть выражены на языках DTD, XML Schema, Relax NG, и т.д. Однако на сегодняшний день существует ряд исследований, ориентированных на создание универсального валидатора. В этих работах схемы представляются в виде регулярных грамматик деревьев, аналогичных структурным схемам. Основная часть алгоритмов валидации -разбор списка потомков - заключается в следующем: определить 211 удовлетворяет ли упорядоченный список потомков данного элемента его модели содержания (структурному ограничению). Преобразование схем к первой нормальной форме, как впрочем, и применение эквивалентных преобразований имеют следующее значение для алгоритмов валидации: 1) После преобразования к 1НФ операции ? и + устраняются, что позволяет воспользоваться алгоритмами валидации «классических» регулярных выражений, определяемых как замыкание операций “*”, ”|”, над базовым алфавитом. 2) Все операции конкатенации (“|”) становятся внешними, что сильно структурирует модель содержания. Эго приводит к упрощению алгоритма разбора списка потомков. Сопоставление схем. Задача сопоставления схем заключается в поиске эквивалентных частей в разных схемах. Решение этой проблемы применяется для интеграции данных. В текущее время ведутся исследования по автоматическому поиску зависимостей [16]. Методы автоматического сопоставления схем можно классифицировать следующим образом [16]: - Поиск в схемах/поиск в данных. Алгоритмы сопоставления схем могут исследовать зависимости только в схемах или зависимости по удовлетворяющим XML-документам. Элементный/структурный поиск. Поиск зависимостей может применяться либо к отдельным элементам, либо к структурам (фактически, учитываются или нет структурные ограничения). - Лингвистический/логический поиск. Поиск зависимостей осуществляется по лингвистическому принципу (например, по именам элементов) или по семантическим ограничениям (например, по типам данным). В первую очередь, приведение схем к нормальным формам оказывает влияние на элементный лингвистический поиск. Приведение схем к ЗНФ с заданным отношением порядка существенно упрощает поиск зависимостей и фактически сводит задачу к поиску изоморфных поддеревьев в деревьях с именованными узлами и с ребрами, размеченными «*», «+» и «?». Подробнее способы сопоставления схем будут описаны в следующей главе. Трансляция моделей. Одна из основных задач, встречающихся при создании систем хранения, управления и интеграции данных, заключается в трансляции моделей, в терминах которых экземпляры данных предоставляются, в термины «единой» модели данных. Так, несмотря на то, что XML и языки запросов к XML-данным завоёвывают в последнее время всё большую популярность, потребность хранения XML данных в «традиционных» СУБД и, соответственно, необходимость трансляции до сих пор остаётся. Обосновано это тем, что многолетний опыт, накопленный при изучении и реализациях реляционных и объектно-ориентированных СУБД невозможно игнорировать. Рассмотрим основные виды трансляции данных, определенных в терминах модели XML. 6.1. XML->Relational Одним из основных направлений исследования методов трансляции моделей является трансляция XML-модели данных в реляционную [9,10]. Отличительными особенностями реляционной модели данных являются: - отсутствие упорядоченности кортежей и атрибутов, - трехуровневая модель (отношение-кортеж- атрибут), в отличие от произвольной глубины XML схем, - отсутствие атрибутов, имеющих своим значением множество, - отсутствие рекурсии. Существует различные методы автоматического представления XML документов в реляционных СУБД: - Хранение XML- данных в BLOB. - Модельно-ориентированная трансляция. Данный вид трансляции не зависит от структурных ограничений, определенных в схеме схемы, а целиком опирается на свойства модели данных XML [20]. Трансляция, ориентированная на данные. Данные алгоритмы трансляции оперируют с XML-данными, не представленными никакой схемой [19]. На начальном этапе трансляции производится вывод схемы, представляющей XML-данные. Трансляция с оценкой эффективности. Алгоритм трансляции, представленный в работе [18], анализирует способ трансляции XML-данных таким образом, чтобы запросы, предопределенные приложением, выполнялись наиболее эффективно. Структурно-ориентированная трансляция. Эта трансляция опирается на информацию, полученную из XML-схемы. В алгоритмах этого типа [9,10] используются структурные ограничения, явно присутствующие в схеме, а также выводятся неявные ограничения, исследуемые в процессе анализа схемы. Проведенные исследования [9,10], касающиеся проблемы структурноориентированной трансляции из XML в реляционную модель выявили ряд возникающих трудностей и показали методы решения: 1) Наличие оператора конкатенации в модели содержания. Например, пусть у нас есть определение модели содержания элемента <!ELEMENT г (а|Ь)>. Переводя в реляционную модель, наиболее близким отображением будет таблица г с двумя полями: а и Ь. Однако эта схема не будет отражать тот факт, что в элементе г может встретиться либо а либо Ь. Поэтому необходимо добавить семантическое ограничение: «если значение в поле а непустое, то значение в поле b должно быть пустым и наоборот». Если есть вложенные конкатенации (то есть конкатенации не на самом верхнем уровне регулярного выражения), мы должны использовать 1НФ для вынесения конкатенаций на самый верхний уровень. 2) Наличие оператора Клини (*). Если в модели содержания какого-то узла встречается другой элемент с оператором * (<!ELEMENT г а*>), то в этом случае для элемента придется создавать отдельное отношение. Если же структура содержит вложенные операторы * (<!ELEMENT г (а*,Ь)*), то количество отношений существенно увеличится. Обычно для решения этой проблемы используются преобразования схем аналогичных ЗНФ (упрощение схемы). Однако, на наш взгляд, правильнее использовать 2 НФ для представления схемы XML: - Во первых, 2НФ оставляет практически всю семантику схемы. - Во вторых, семантика порядка, которая теряется во 2НФ, не оказывает никакого влияния на трансляцию в реляционную модель, вследствие отсутствия семантики порядка в реляционной модели. 6.2. XML->Semistructured Другим направлением трансляции XML является трансляция в полуструктурированные и объектно-ориентированные модели. Существенное отличие этих моделей от реляционной заключается в том что, данные представляются в виде ориентированного графа с именованными узлами. Последнее свойство, как правило, снимает необходимость использования 2НФ и ЗНФ. Поэтому, в общем случае транслируется схема, приведенная к 1НФ или непосредственно исходная схема. Например, для полуструктурированной модели данных YAT [14] мы использовали представление структурных схем в 1НФ, в силу особенностей данной модели (отсутствие операторов + и ? и наличие оператора | с ограниченными свойствами)[15]. 6.3. Relational -> XML В работе [21] перечислены основные методы автоматизации представления реляционных данных в терминах модели данных XML: - Плоская трансляция. Данный подход является наиболее тривиальным способом отображения схемы реляционной базы данных в XML-схему. Трансляция задается следующим образом: 1. Имя отношения переходит в элемент с таким же именем. Содержимое корневого элемента состоит из произвольного набора элементов, имена которых соответствуют именам отношения в базе данных. 2. Каждому отношению базы данных ставится в соответствие тип элемента, имя которого совпадает с именем отношения. Множество типов атрибутов, относящихся к данному типу элемента, соответствуют паре {тип домена, имя атрибута} из заголовка отношения. - Вложенная трансляция (Nesting-Based Translation). Основной недостаток плоской трансляции заключается в том, что при создании XML-схемы не используются такая структурная возможность для моделирования XML, как наличие повторяющихся подэлементов. Вложенная трансляция устраняет этот недостаток. В работе [22] показано, каким образом достигается вложенная трансляция для отношений, представленных в ЗНФ. Трансляция с использованием «зависимостей по включению». Термин «зависимость по включению» используется в теории баз данных [21] как обобщение внешних ключей. Использование трансляции такого типа [21] позволяет вкладывать элементы, построенные из разных отношений друг в друга, исходя из информации о внешних ключах отношений и прочих зависимостей по включению. Если у отношения существует внешний ключ «на себя», получаемая схема XML будет рекурсивной. Дополнительную информацию об этих и прочих видах трансляции из модели XML в другие модели и наоборот, можно получить в работе [21]. 7. Ограничения целостности XML В последнем разделе главы мы опишем различные виды ограничений целостности для XML-данных. Эти исследования, направленные на систематизацию логических способов задания ограничений целостности, были проведены в работах [8,12]. Итак, пусть S=(T,E,A,p,a,r) - Структурная схема, D- произвольный XML-документ, валидируемый S. Рассмотрим следующие логические выражения, являющиеся определениями ограничений целостности над схемой S. Определение 26 (Ограничение ключа). Ограничением ключа X над схемой S=(T,E,A,p,a,r) называется логическое выражение вида К(е)—>е, где ееЕ, К(е)са(е). Определение 27 (Документ удовлетворяет ограничению ключа). XML-документ D, валидируемый схемой S=(T,E,A,p,a,r) удовлетворяет ограничению ключа Х=К(е)—>е, если для любой интерпретации 1=(ф,ср,ст) выполняется следующее условие: \/х,уеф-1(е): P|(x.l = у.1) ->х=у /еК(е) где х.1 — это прообраз типа атрибута 1, являющийся атрибутом элемента х. Под равенством атрибутов в документе, здесь и далее, подразумевается равенство значений. <?xml version="1.0" encoding="UTF-B" ?> - <a> <b c="l" d="l" /> <b c="l" d="2" /> <b c="2" d="3" /> </a> Puc. 3. Пример документа XML. На Рис. 3 представлена документ XML, удовлетворяющий следующей структурной схеме: Т={а} Es{{a, А}, {Ь, В}} А={(С.с. CDATA, Required), (D,d, CD AT A, Required)} p:p(a)= (b*) p(b)= 6 a:a(b)={C,D} a(a)={} Из утверждения 3 следует, что существует единственная интерпретация документа в терминах этой схемы. Рассмотрим следующее ограничение ключа Х= {С}—>В. Существует два элемента с именем Ь, у которых значения атрибута с совпадают. Следовательно, документ не удовлетворяет данному ограничению ключа. Однако тот же самый документ удовлетворяет другому ограничению ключа: {C,D}—>В. □ Определение 28 (Ограничение включения). Ограничением включения X над схемой S=(T,E,A,p,a,r) называется логическое выражение вида Li (ei )—> L2(e2). где ei,e2eE, LiH L2 упорядоченные множества, такие что Liça(ei), L2ça(e2), | Li|=| L2|. Определение 29 ( документ удовлетворяет ограничению включения). XML-документ D, валидируемый схемой S=(T,E,A,p,a,r) удовлетворяет ограничению включения Х= L](с 1 ) —> L2(e2), если для любой интерпретации 1=(ф,ф,ст) выполняется следующее условие: Ухеф_1(е1) 3 уеф_1(е2): Р| (x.i = y.i) '=[l.|Lil] где x.i и y.i - это прообразы i-x по порядку типов атрибута из упорядоченных множеств Li(ei) и L2(e2) , являющихся атрибутами элементов х и у соответственно. Пример 10. Рассмотрим структурную схему и XML-документ из предыдущего примера. Приведенный XML-документ удовлетворяет следующему ограничению включения: Х={С}в —>{D}B. □ Определение 30 (Ограничение внешнего ключа). Ограничением включения X над схемой S=(T,E,A,p,a,r) называется комбинация ограничения включения Li(ei)—> L2(e2) и ограничения ключа Ь2(е2) —> е. Определение 31 (Документ удовлетворяет ограничению внешнего ключа). XML-документ D, валидируемый схемой S=(T,E,A,p,a,r) удовлетворяет ограничению внешнего ключа Х= Li(ei)—> L2(e2); L2(e2) —> е2, если он удовлетворяет обоим ограничениям целостности, составляющим ограничение внешнего ключа для любой интерпретации. После того, как мы определили логические выражения, предназначенные для формулирования ограничений целостности, мы можем сформулировать определения, соответствующие формальным определениям из раздела 1.6 (определение 1.4-1.7). Определение 32 (Схема данныхXML). Схема данных XML - это пара (S,E), где S - это структурная схема, а Е- множество ограничений целостности над S, сформулированных в виде логических выражений следующего вида -ограничение ключа, ограничение включения, ограничение внешнего ключа. Определение 33 (Валидируемостъ документа XML). XML-документ D валидируется схемой (S,E), если D|=S и D удовлетворяет всем ограничениям целостности из Е. 8. Заключение Основной целью данной работы является изучение свойств схем данных XML-документов. В работе представлено формальное определение структурных схем и изучены методы преобразования схем-экземпляров, обладающих свойством сохранения той или иной семантики. Также в работе представлены нормальные формы структурных ограничений и доказаны теоремы существования нормальных форм для произвольной структурной схемы. Как уже было показано выше, в большинстве исследований, касающихся проблем управления данными и моделями XML тем или иным образом можно установить класс семантических правил, которыми можно пренебречь для эффективности реализации. Нормальные формы схем как раз и являются способом приведения схемы к более простому виду с потерей части семантики. В заключительной части работы мы описываем способы поддержки ограничений целостности. В данный момент нами разработаны алгоритмы преобразования схем DTD и Relax NG в структурные схемы с последующим приведением к нормальным формам. На следующем этапе мы планируем расширить список поддерживаемых языков спецификаций схем (XDR, XML Schema). Затем мы планируем перейти к более детальному изучению способов применения нормальных форм схем на практике. ]]></text>
</doc>
